var lib;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./JS/helper.js":
/*!**********************!*\
  !*** ./JS/helper.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsyncFunction: () => (/* binding */ AsyncFunction)
/* harmony export */ });
const AsyncFunction = (code) => (async function () {}).constructor(code);


/***/ }),

/***/ "./JS/prism-celincm.js":
/*!*****************************!*\
  !*** ./JS/prism-celincm.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   celincm: () => (/* binding */ celincm)
/* harmony export */ });
const celincm = Prism.languages.extend('javascript', {
  italic: /\b(?:onMenu|onCql|onCsl|func)\b/,
});


/***/ }),

/***/ "./JS/prism-celinql.js":
/*!*****************************!*\
  !*** ./JS/prism-celinql.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   celinql: () => (/* binding */ celinql)
/* harmony export */ });
const celinql = {
    string: /"[^"]*"/,
    comment: /\/\*[^*]*\*\//,
    bold: /[fFvVwW]\w{4,7} |#\w+|@\w+|\$.+\"/,
    italic: /(?:-demo|-v2|-max)/,
    keyword: /\b(?:all|any|and|or|by|having|sum|min|max|avg|count|count_distinct|avg_distinct|group|desc|asc)\b/,
    operator: />=?|<[=>]?|\b(bw|in)\b|[=?_!^$]/,
    punctuation: /[{}[\];(),\.]/,
    number: /\b\d+\b/,
};


/***/ }),

/***/ "./JS/prism-celinsl.js":
/*!*****************************!*\
  !*** ./JS/prism-celinsl.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   celinsl: () => (/* binding */ celinsl)
/* harmony export */ });
const celinsl = {
    string: /"[^"]*"/,
    comment: /\/\*[^*]*\*\//,
    bold: /#\w+|@\w+/,
    variable: /\$(?:row|col\[\d+\]|form|title|datacol|gridcol\[\d+\]|records)/,
    keyword: /\b(?:do|set|select|qbe|open|action|output|each|close|demo|dump|data|grid|insert|update|continue|breakOnError|radio)\b/,
    punctuation: /[{}[\];(),\.]/,
    number: /\b\d+\b/,
};


/***/ }),

/***/ "./node_modules/@floating-ui/core/dist/floating-ui.core.umd.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@floating-ui/core/dist/floating-ui.core.umd.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports) {

(function (global, factory) {
   true ? factory(exports) :
  0;
})(this, (function (exports) { 'use strict';

  /**
   * Custom positioning reference element.
   * @see https://floating-ui.com/docs/virtual-elements
   */

  const sides = ['top', 'right', 'bottom', 'left'];
  const alignments = ['start', 'end'];
  const placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
  const min = Math.min;
  const max = Math.max;
  const oppositeSideMap = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
  };
  const oppositeAlignmentMap = {
    start: 'end',
    end: 'start'
  };
  function clamp(start, value, end) {
    return max(start, min(value, end));
  }
  function evaluate(value, param) {
    return typeof value === 'function' ? value(param) : value;
  }
  function getSide(placement) {
    return placement.split('-')[0];
  }
  function getAlignment(placement) {
    return placement.split('-')[1];
  }
  function getOppositeAxis(axis) {
    return axis === 'x' ? 'y' : 'x';
  }
  function getAxisLength(axis) {
    return axis === 'y' ? 'height' : 'width';
  }
  function getSideAxis(placement) {
    return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';
  }
  function getAlignmentAxis(placement) {
    return getOppositeAxis(getSideAxis(placement));
  }
  function getAlignmentSides(placement, rects, rtl) {
    if (rtl === void 0) {
      rtl = false;
    }
    const alignment = getAlignment(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const length = getAxisLength(alignmentAxis);
    let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';
    if (rects.reference[length] > rects.floating[length]) {
      mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
    }
    return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
  }
  function getExpandedPlacements(placement) {
    const oppositePlacement = getOppositePlacement(placement);
    return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
  }
  function getOppositeAlignmentPlacement(placement) {
    return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);
  }
  function getSideList(side, isStart, rtl) {
    const lr = ['left', 'right'];
    const rl = ['right', 'left'];
    const tb = ['top', 'bottom'];
    const bt = ['bottom', 'top'];
    switch (side) {
      case 'top':
      case 'bottom':
        if (rtl) return isStart ? rl : lr;
        return isStart ? lr : rl;
      case 'left':
      case 'right':
        return isStart ? tb : bt;
      default:
        return [];
    }
  }
  function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
    const alignment = getAlignment(placement);
    let list = getSideList(getSide(placement), direction === 'start', rtl);
    if (alignment) {
      list = list.map(side => side + "-" + alignment);
      if (flipAlignment) {
        list = list.concat(list.map(getOppositeAlignmentPlacement));
      }
    }
    return list;
  }
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);
  }
  function expandPaddingObject(padding) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...padding
    };
  }
  function getPaddingObject(padding) {
    return typeof padding !== 'number' ? expandPaddingObject(padding) : {
      top: padding,
      right: padding,
      bottom: padding,
      left: padding
    };
  }
  function rectToClientRect(rect) {
    const {
      x,
      y,
      width,
      height
    } = rect;
    return {
      width,
      height,
      top: y,
      left: x,
      right: x + width,
      bottom: y + height,
      x,
      y
    };
  }

  function computeCoordsFromPlacement(_ref, placement, rtl) {
    let {
      reference,
      floating
    } = _ref;
    const sideAxis = getSideAxis(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const alignLength = getAxisLength(alignmentAxis);
    const side = getSide(placement);
    const isVertical = sideAxis === 'y';
    const commonX = reference.x + reference.width / 2 - floating.width / 2;
    const commonY = reference.y + reference.height / 2 - floating.height / 2;
    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
    let coords;
    switch (side) {
      case 'top':
        coords = {
          x: commonX,
          y: reference.y - floating.height
        };
        break;
      case 'bottom':
        coords = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;
      case 'right':
        coords = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;
      case 'left':
        coords = {
          x: reference.x - floating.width,
          y: commonY
        };
        break;
      default:
        coords = {
          x: reference.x,
          y: reference.y
        };
    }
    switch (getAlignment(placement)) {
      case 'start':
        coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
        break;
      case 'end':
        coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
        break;
    }
    return coords;
  }

  /**
   * Computes the `x` and `y` coordinates that will place the floating element
   * next to a given reference element.
   *
   * This export does not have any `platform` interface logic. You will need to
   * write one for the platform you are using Floating UI with.
   */
  const computePosition = async (reference, floating, config) => {
    const {
      placement = 'bottom',
      strategy = 'absolute',
      middleware = [],
      platform
    } = config;
    const validMiddleware = middleware.filter(Boolean);
    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
    let rects = await platform.getElementRects({
      reference,
      floating,
      strategy
    });
    let {
      x,
      y
    } = computeCoordsFromPlacement(rects, placement, rtl);
    let statefulPlacement = placement;
    let middlewareData = {};
    let resetCount = 0;
    for (let i = 0; i < validMiddleware.length; i++) {
      const {
        name,
        fn
      } = validMiddleware[i];
      const {
        x: nextX,
        y: nextY,
        data,
        reset
      } = await fn({
        x,
        y,
        initialPlacement: placement,
        placement: statefulPlacement,
        strategy,
        middlewareData,
        rects,
        platform,
        elements: {
          reference,
          floating
        }
      });
      x = nextX != null ? nextX : x;
      y = nextY != null ? nextY : y;
      middlewareData = {
        ...middlewareData,
        [name]: {
          ...middlewareData[name],
          ...data
        }
      };
      if (reset && resetCount <= 50) {
        resetCount++;
        if (typeof reset === 'object') {
          if (reset.placement) {
            statefulPlacement = reset.placement;
          }
          if (reset.rects) {
            rects = reset.rects === true ? await platform.getElementRects({
              reference,
              floating,
              strategy
            }) : reset.rects;
          }
          ({
            x,
            y
          } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
        }
        i = -1;
      }
    }
    return {
      x,
      y,
      placement: statefulPlacement,
      strategy,
      middlewareData
    };
  };

  /**
   * Resolves with an object of overflow side offsets that determine how much the
   * element is overflowing a given clipping boundary on each side.
   * - positive = overflowing the boundary by that number of pixels
   * - negative = how many pixels left before it will overflow
   * - 0 = lies flush with the boundary
   * @see https://floating-ui.com/docs/detectOverflow
   */
  async function detectOverflow(state, options) {
    var _await$platform$isEle;
    if (options === void 0) {
      options = {};
    }
    const {
      x,
      y,
      platform,
      rects,
      elements,
      strategy
    } = state;
    const {
      boundary = 'clippingAncestors',
      rootBoundary = 'viewport',
      elementContext = 'floating',
      altBoundary = false,
      padding = 0
    } = evaluate(options, state);
    const paddingObject = getPaddingObject(padding);
    const altContext = elementContext === 'floating' ? 'reference' : 'floating';
    const element = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = rectToClientRect(await platform.getClippingRect({
      element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),
      boundary,
      rootBoundary,
      strategy
    }));
    const rect = elementContext === 'floating' ? {
      x,
      y,
      width: rects.floating.width,
      height: rects.floating.height
    } : rects.reference;
    const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
    const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    };
    const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements,
      rect,
      offsetParent,
      strategy
    }) : rect);
    return {
      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
  }

  /**
   * Provides data to position an inner element of the floating element so that it
   * appears centered to the reference element.
   * @see https://floating-ui.com/docs/arrow
   */
  const arrow = options => ({
    name: 'arrow',
    options,
    async fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        platform,
        elements,
        middlewareData
      } = state;
      // Since `element` is required, we don't Partial<> the type.
      const {
        element,
        padding = 0
      } = evaluate(options, state) || {};
      if (element == null) {
        return {};
      }
      const paddingObject = getPaddingObject(padding);
      const coords = {
        x,
        y
      };
      const axis = getAlignmentAxis(placement);
      const length = getAxisLength(axis);
      const arrowDimensions = await platform.getDimensions(element);
      const isYAxis = axis === 'y';
      const minProp = isYAxis ? 'top' : 'left';
      const maxProp = isYAxis ? 'bottom' : 'right';
      const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';
      const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
      const startDiff = coords[axis] - rects.reference[axis];
      const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
      let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;

      // DOM platform can return `window` as the `offsetParent`.
      if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {
        clientSize = elements.floating[clientProp] || rects.floating[length];
      }
      const centerToReference = endDiff / 2 - startDiff / 2;

      // If the padding is large enough that it causes the arrow to no longer be
      // centered, modify the padding so that it is centered.
      const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
      const minPadding = min(paddingObject[minProp], largestPossiblePadding);
      const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);

      // Make sure the arrow doesn't overflow the floating element if the center
      // point is outside the floating element's bounds.
      const min$1 = minPadding;
      const max = clientSize - arrowDimensions[length] - maxPadding;
      const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
      const offset = clamp(min$1, center, max);

      // If the reference is small enough that the arrow's padding causes it to
      // to point to nothing for an aligned placement, adjust the offset of the
      // floating element itself. To ensure `shift()` continues to take action,
      // a single reset is performed when this is true.
      const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
      const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;
      return {
        [axis]: coords[axis] + alignmentOffset,
        data: {
          [axis]: offset,
          centerOffset: center - offset - alignmentOffset,
          ...(shouldAddOffset && {
            alignmentOffset
          })
        },
        reset: shouldAddOffset
      };
    }
  });

  function getPlacementList(alignment, autoAlignment, allowedPlacements) {
    const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);
    return allowedPlacementsSortedByAlignment.filter(placement => {
      if (alignment) {
        return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
      }
      return true;
    });
  }
  /**
   * Optimizes the visibility of the floating element by choosing the placement
   * that has the most space available automatically, without needing to specify a
   * preferred placement. Alternative to `flip`.
   * @see https://floating-ui.com/docs/autoPlacement
   */
  const autoPlacement = function (options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: 'autoPlacement',
      options,
      async fn(state) {
        var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
        const {
          rects,
          middlewareData,
          placement,
          platform,
          elements
        } = state;
        const {
          crossAxis = false,
          alignment,
          allowedPlacements = placements,
          autoAlignment = true,
          ...detectOverflowOptions
        } = evaluate(options, state);
        const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
        const currentPlacement = placements$1[currentIndex];
        if (currentPlacement == null) {
          return {};
        }
        const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));

        // Make `computeCoords` start from the right place.
        if (placement !== currentPlacement) {
          return {
            reset: {
              placement: placements$1[0]
            }
          };
        }
        const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
        const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {
          placement: currentPlacement,
          overflows: currentOverflows
        }];
        const nextPlacement = placements$1[currentIndex + 1];

        // There are more placements to check.
        if (nextPlacement) {
          return {
            data: {
              index: currentIndex + 1,
              overflows: allOverflows
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        const placementsSortedByMostSpace = allOverflows.map(d => {
          const alignment = getAlignment(d.placement);
          return [d.placement, alignment && crossAxis ?
          // Check along the mainAxis and main crossAxis side.
          d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :
          // Check only the mainAxis.
          d.overflows[0], d.overflows];
        }).sort((a, b) => a[1] - b[1]);
        const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));
        const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
        if (resetPlacement !== placement) {
          return {
            data: {
              index: currentIndex + 1,
              overflows: allOverflows
            },
            reset: {
              placement: resetPlacement
            }
          };
        }
        return {};
      }
    };
  };

  /**
   * Optimizes the visibility of the floating element by flipping the `placement`
   * in order to keep it in view when the preferred placement(s) will overflow the
   * clipping boundary. Alternative to `autoPlacement`.
   * @see https://floating-ui.com/docs/flip
   */
  const flip = function (options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: 'flip',
      options,
      async fn(state) {
        var _middlewareData$arrow, _middlewareData$flip;
        const {
          placement,
          middlewareData,
          rects,
          initialPlacement,
          platform,
          elements
        } = state;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true,
          fallbackPlacements: specifiedFallbackPlacements,
          fallbackStrategy = 'bestFit',
          fallbackAxisSideDirection = 'none',
          flipAlignment = true,
          ...detectOverflowOptions
        } = evaluate(options, state);

        // If a reset by the arrow was caused due to an alignment offset being
        // added, we should skip any logic now since `flip()` has already done its
        // work.
        // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643
        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        const side = getSide(placement);
        const initialSideAxis = getSideAxis(initialPlacement);
        const isBasePlacement = getSide(initialPlacement) === initialPlacement;
        const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
        const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';
        if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
        }
        const placements = [initialPlacement, ...fallbackPlacements];
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const overflows = [];
        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
        if (checkMainAxis) {
          overflows.push(overflow[side]);
        }
        if (checkCrossAxis) {
          const sides = getAlignmentSides(placement, rects, rtl);
          overflows.push(overflow[sides[0]], overflow[sides[1]]);
        }
        overflowsData = [...overflowsData, {
          placement,
          overflows
        }];

        // One or more sides is overflowing.
        if (!overflows.every(side => side <= 0)) {
          var _middlewareData$flip2, _overflowsData$filter;
          const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
          const nextPlacement = placements[nextIndex];
          if (nextPlacement) {
            // Try next placement and re-run the lifecycle.
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }

          // First, find the candidates that fit on the mainAxis side of overflow,
          // then find the placement that fits the best on the main crossAxis side.
          let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;

          // Otherwise fallback.
          if (!resetPlacement) {
            switch (fallbackStrategy) {
              case 'bestFit':
                {
                  var _overflowsData$filter2;
                  const placement = (_overflowsData$filter2 = overflowsData.filter(d => {
                    if (hasFallbackAxisSideDirection) {
                      const currentSideAxis = getSideAxis(d.placement);
                      return currentSideAxis === initialSideAxis ||
                      // Create a bias to the `y` side axis due to horizontal
                      // reading directions favoring greater width.
                      currentSideAxis === 'y';
                    }
                    return true;
                  }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                  if (placement) {
                    resetPlacement = placement;
                  }
                  break;
                }
              case 'initialPlacement':
                resetPlacement = initialPlacement;
                break;
            }
          }
          if (placement !== resetPlacement) {
            return {
              reset: {
                placement: resetPlacement
              }
            };
          }
        }
        return {};
      }
    };
  };

  function getSideOffsets(overflow, rect) {
    return {
      top: overflow.top - rect.height,
      right: overflow.right - rect.width,
      bottom: overflow.bottom - rect.height,
      left: overflow.left - rect.width
    };
  }
  function isAnySideFullyClipped(overflow) {
    return sides.some(side => overflow[side] >= 0);
  }
  /**
   * Provides data to hide the floating element in applicable situations, such as
   * when it is not in the same clipping context as the reference element.
   * @see https://floating-ui.com/docs/hide
   */
  const hide = function (options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: 'hide',
      options,
      async fn(state) {
        const {
          rects
        } = state;
        const {
          strategy = 'referenceHidden',
          ...detectOverflowOptions
        } = evaluate(options, state);
        switch (strategy) {
          case 'referenceHidden':
            {
              const overflow = await detectOverflow(state, {
                ...detectOverflowOptions,
                elementContext: 'reference'
              });
              const offsets = getSideOffsets(overflow, rects.reference);
              return {
                data: {
                  referenceHiddenOffsets: offsets,
                  referenceHidden: isAnySideFullyClipped(offsets)
                }
              };
            }
          case 'escaped':
            {
              const overflow = await detectOverflow(state, {
                ...detectOverflowOptions,
                altBoundary: true
              });
              const offsets = getSideOffsets(overflow, rects.floating);
              return {
                data: {
                  escapedOffsets: offsets,
                  escaped: isAnySideFullyClipped(offsets)
                }
              };
            }
          default:
            {
              return {};
            }
        }
      }
    };
  };

  function getBoundingRect(rects) {
    const minX = min(...rects.map(rect => rect.left));
    const minY = min(...rects.map(rect => rect.top));
    const maxX = max(...rects.map(rect => rect.right));
    const maxY = max(...rects.map(rect => rect.bottom));
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  function getRectsByLine(rects) {
    const sortedRects = rects.slice().sort((a, b) => a.y - b.y);
    const groups = [];
    let prevRect = null;
    for (let i = 0; i < sortedRects.length; i++) {
      const rect = sortedRects[i];
      if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {
        groups.push([rect]);
      } else {
        groups[groups.length - 1].push(rect);
      }
      prevRect = rect;
    }
    return groups.map(rect => rectToClientRect(getBoundingRect(rect)));
  }
  /**
   * Provides improved positioning for inline reference elements that can span
   * over multiple lines, such as hyperlinks or range selections.
   * @see https://floating-ui.com/docs/inline
   */
  const inline = function (options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: 'inline',
      options,
      async fn(state) {
        const {
          placement,
          elements,
          rects,
          platform,
          strategy
        } = state;
        // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a
        // ClientRect's bounds, despite the event listener being triggered. A
        // padding of 2 seems to handle this issue.
        const {
          padding = 2,
          x,
          y
        } = evaluate(options, state);
        const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);
        const clientRects = getRectsByLine(nativeClientRects);
        const fallback = rectToClientRect(getBoundingRect(nativeClientRects));
        const paddingObject = getPaddingObject(padding);
        function getBoundingClientRect() {
          // There are two rects and they are disjoined.
          if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {
            // Find the first rect in which the point is fully inside.
            return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;
          }

          // There are 2 or more connected rects.
          if (clientRects.length >= 2) {
            if (getSideAxis(placement) === 'y') {
              const firstRect = clientRects[0];
              const lastRect = clientRects[clientRects.length - 1];
              const isTop = getSide(placement) === 'top';
              const top = firstRect.top;
              const bottom = lastRect.bottom;
              const left = isTop ? firstRect.left : lastRect.left;
              const right = isTop ? firstRect.right : lastRect.right;
              const width = right - left;
              const height = bottom - top;
              return {
                top,
                bottom,
                left,
                right,
                width,
                height,
                x: left,
                y: top
              };
            }
            const isLeftSide = getSide(placement) === 'left';
            const maxRight = max(...clientRects.map(rect => rect.right));
            const minLeft = min(...clientRects.map(rect => rect.left));
            const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
            const top = measureRects[0].top;
            const bottom = measureRects[measureRects.length - 1].bottom;
            const left = minLeft;
            const right = maxRight;
            const width = right - left;
            const height = bottom - top;
            return {
              top,
              bottom,
              left,
              right,
              width,
              height,
              x: left,
              y: top
            };
          }
          return fallback;
        }
        const resetRects = await platform.getElementRects({
          reference: {
            getBoundingClientRect
          },
          floating: elements.floating,
          strategy
        });
        if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
          return {
            reset: {
              rects: resetRects
            }
          };
        }
        return {};
      }
    };
  };

  // For type backwards-compatibility, the `OffsetOptions` type was also
  // Derivable.

  async function convertValueToCoords(state, options) {
    const {
      placement,
      platform,
      elements
    } = state;
    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
    const side = getSide(placement);
    const alignment = getAlignment(placement);
    const isVertical = getSideAxis(placement) === 'y';
    const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = evaluate(options, state);

    // eslint-disable-next-line prefer-const
    let {
      mainAxis,
      crossAxis,
      alignmentAxis
    } = typeof rawValue === 'number' ? {
      mainAxis: rawValue,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: 0,
      crossAxis: 0,
      alignmentAxis: null,
      ...rawValue
    };
    if (alignment && typeof alignmentAxis === 'number') {
      crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical ? {
      x: crossAxis * crossAxisMulti,
      y: mainAxis * mainAxisMulti
    } : {
      x: mainAxis * mainAxisMulti,
      y: crossAxis * crossAxisMulti
    };
  }

  /**
   * Modifies the placement by translating the floating element along the
   * specified axes.
   * A number (shorthand for `mainAxis` or distance), or an axes configuration
   * object may be passed.
   * @see https://floating-ui.com/docs/offset
   */
  const offset = function (options) {
    if (options === void 0) {
      options = 0;
    }
    return {
      name: 'offset',
      options,
      async fn(state) {
        var _middlewareData$offse, _middlewareData$arrow;
        const {
          x,
          y,
          placement,
          middlewareData
        } = state;
        const diffCoords = await convertValueToCoords(state, options);

        // If the placement is the same and the arrow caused an alignment offset
        // then we don't need to change the positioning coordinates.
        if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        return {
          x: x + diffCoords.x,
          y: y + diffCoords.y,
          data: {
            ...diffCoords,
            placement
          }
        };
      }
    };
  };

  /**
   * Optimizes the visibility of the floating element by shifting it in order to
   * keep it in view when it will overflow the clipping boundary.
   * @see https://floating-ui.com/docs/shift
   */
  const shift = function (options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: 'shift',
      options,
      async fn(state) {
        const {
          x,
          y,
          placement
        } = state;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = false,
          limiter = {
            fn: _ref => {
              let {
                x,
                y
              } = _ref;
              return {
                x,
                y
              };
            }
          },
          ...detectOverflowOptions
        } = evaluate(options, state);
        const coords = {
          x,
          y
        };
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const crossAxis = getSideAxis(getSide(placement));
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        if (checkMainAxis) {
          const minSide = mainAxis === 'y' ? 'top' : 'left';
          const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
          const min = mainAxisCoord + overflow[minSide];
          const max = mainAxisCoord - overflow[maxSide];
          mainAxisCoord = clamp(min, mainAxisCoord, max);
        }
        if (checkCrossAxis) {
          const minSide = crossAxis === 'y' ? 'top' : 'left';
          const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
          const min = crossAxisCoord + overflow[minSide];
          const max = crossAxisCoord - overflow[maxSide];
          crossAxisCoord = clamp(min, crossAxisCoord, max);
        }
        const limitedCoords = limiter.fn({
          ...state,
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        });
        return {
          ...limitedCoords,
          data: {
            x: limitedCoords.x - x,
            y: limitedCoords.y - y
          }
        };
      }
    };
  };
  /**
   * Built-in `limiter` that will stop `shift()` at a certain point.
   */
  const limitShift = function (options) {
    if (options === void 0) {
      options = {};
    }
    return {
      options,
      fn(state) {
        const {
          x,
          y,
          placement,
          rects,
          middlewareData
        } = state;
        const {
          offset = 0,
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true
        } = evaluate(options, state);
        const coords = {
          x,
          y
        };
        const crossAxis = getSideAxis(placement);
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        const rawOffset = evaluate(offset, state);
        const computedOffset = typeof rawOffset === 'number' ? {
          mainAxis: rawOffset,
          crossAxis: 0
        } : {
          mainAxis: 0,
          crossAxis: 0,
          ...rawOffset
        };
        if (checkMainAxis) {
          const len = mainAxis === 'y' ? 'height' : 'width';
          const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
          const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
          if (mainAxisCoord < limitMin) {
            mainAxisCoord = limitMin;
          } else if (mainAxisCoord > limitMax) {
            mainAxisCoord = limitMax;
          }
        }
        if (checkCrossAxis) {
          var _middlewareData$offse, _middlewareData$offse2;
          const len = mainAxis === 'y' ? 'width' : 'height';
          const isOriginSide = ['top', 'left'].includes(getSide(placement));
          const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
          const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
          if (crossAxisCoord < limitMin) {
            crossAxisCoord = limitMin;
          } else if (crossAxisCoord > limitMax) {
            crossAxisCoord = limitMax;
          }
        }
        return {
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        };
      }
    };
  };

  /**
   * Provides data that allows you to change the size of the floating element —
   * for instance, prevent it from overflowing the clipping boundary or match the
   * width of the reference element.
   * @see https://floating-ui.com/docs/size
   */
  const size = function (options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: 'size',
      options,
      async fn(state) {
        const {
          placement,
          rects,
          platform,
          elements
        } = state;
        const {
          apply = () => {},
          ...detectOverflowOptions
        } = evaluate(options, state);
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const side = getSide(placement);
        const alignment = getAlignment(placement);
        const isYAxis = getSideAxis(placement) === 'y';
        const {
          width,
          height
        } = rects.floating;
        let heightSide;
        let widthSide;
        if (side === 'top' || side === 'bottom') {
          heightSide = side;
          widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';
        } else {
          widthSide = side;
          heightSide = alignment === 'end' ? 'top' : 'bottom';
        }
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        const maximumClippingWidth = width - overflow.left - overflow.right;
        const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
        const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
        const noShift = !state.middlewareData.shift;
        let availableHeight = overflowAvailableHeight;
        let availableWidth = overflowAvailableWidth;
        if (isYAxis) {
          availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
        } else {
          availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
        }
        if (noShift && !alignment) {
          const xMin = max(overflow.left, 0);
          const xMax = max(overflow.right, 0);
          const yMin = max(overflow.top, 0);
          const yMax = max(overflow.bottom, 0);
          if (isYAxis) {
            availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
          } else {
            availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
          }
        }
        await apply({
          ...state,
          availableWidth,
          availableHeight
        });
        const nextDimensions = await platform.getDimensions(elements.floating);
        if (width !== nextDimensions.width || height !== nextDimensions.height) {
          return {
            reset: {
              rects: true
            }
          };
        }
        return {};
      }
    };
  };

  exports.arrow = arrow;
  exports.autoPlacement = autoPlacement;
  exports.computePosition = computePosition;
  exports.detectOverflow = detectOverflow;
  exports.flip = flip;
  exports.hide = hide;
  exports.inline = inline;
  exports.limitShift = limitShift;
  exports.offset = offset;
  exports.rectToClientRect = rectToClientRect;
  exports.shift = shift;
  exports.size = size;

}));


/***/ }),

/***/ "./node_modules/@floating-ui/dom/dist/floating-ui.dom.umd.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@floating-ui/dom/dist/floating-ui.dom.umd.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

(function (global, factory) {
   true ? factory(exports, __webpack_require__(/*! @floating-ui/core */ "./node_modules/@floating-ui/core/dist/floating-ui.core.umd.js")) :
  0;
})(this, (function (exports, core) { 'use strict';

  /**
   * Custom positioning reference element.
   * @see https://floating-ui.com/docs/virtual-elements
   */

  const min = Math.min;
  const max = Math.max;
  const round = Math.round;
  const floor = Math.floor;
  const createCoords = v => ({
    x: v,
    y: v
  });

  function getNodeName(node) {
    if (isNode(node)) {
      return (node.nodeName || '').toLowerCase();
    }
    // Mocked nodes in testing environments may not be instances of Node. By
    // returning `#document` an infinite loop won't occur.
    // https://github.com/floating-ui/floating-ui/issues/2317
    return '#document';
  }
  function getWindow(node) {
    var _node$ownerDocument;
    return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
  }
  function getDocumentElement(node) {
    var _ref;
    return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
  }
  function isNode(value) {
    return value instanceof Node || value instanceof getWindow(value).Node;
  }
  function isElement(value) {
    return value instanceof Element || value instanceof getWindow(value).Element;
  }
  function isHTMLElement(value) {
    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
  }
  function isShadowRoot(value) {
    // Browsers without `ShadowRoot` support.
    if (typeof ShadowRoot === 'undefined') {
      return false;
    }
    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
  }
  function isOverflowElement(element) {
    const {
      overflow,
      overflowX,
      overflowY,
      display
    } = getComputedStyle(element);
    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);
  }
  function isTableElement(element) {
    return ['table', 'td', 'th'].includes(getNodeName(element));
  }
  function isTopLayer(element) {
    return [':popover-open', ':modal'].some(selector => {
      try {
        return element.matches(selector);
      } catch (e) {
        return false;
      }
    });
  }
  function isContainingBlock(elementOrCss) {
    const webkit = isWebKit();
    const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;

    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
    return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));
  }
  function getContainingBlock(element) {
    let currentNode = getParentNode(element);
    while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
      if (isContainingBlock(currentNode)) {
        return currentNode;
      } else if (isTopLayer(currentNode)) {
        return null;
      }
      currentNode = getParentNode(currentNode);
    }
    return null;
  }
  function isWebKit() {
    if (typeof CSS === 'undefined' || !CSS.supports) return false;
    return CSS.supports('-webkit-backdrop-filter', 'none');
  }
  function isLastTraversableNode(node) {
    return ['html', 'body', '#document'].includes(getNodeName(node));
  }
  function getComputedStyle(element) {
    return getWindow(element).getComputedStyle(element);
  }
  function getNodeScroll(element) {
    if (isElement(element)) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    return {
      scrollLeft: element.scrollX,
      scrollTop: element.scrollY
    };
  }
  function getParentNode(node) {
    if (getNodeName(node) === 'html') {
      return node;
    }
    const result =
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot ||
    // DOM Element detected.
    node.parentNode ||
    // ShadowRoot detected.
    isShadowRoot(node) && node.host ||
    // Fallback.
    getDocumentElement(node);
    return isShadowRoot(result) ? result.host : result;
  }
  function getNearestOverflowAncestor(node) {
    const parentNode = getParentNode(node);
    if (isLastTraversableNode(parentNode)) {
      return node.ownerDocument ? node.ownerDocument.body : node.body;
    }
    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
      return parentNode;
    }
    return getNearestOverflowAncestor(parentNode);
  }
  function getOverflowAncestors(node, list, traverseIframes) {
    var _node$ownerDocument2;
    if (list === void 0) {
      list = [];
    }
    if (traverseIframes === void 0) {
      traverseIframes = true;
    }
    const scrollableAncestor = getNearestOverflowAncestor(node);
    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
    const win = getWindow(scrollableAncestor);
    if (isBody) {
      const frameElement = getFrameElement(win);
      return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
    }
    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
  }
  function getFrameElement(win) {
    return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
  }

  function getCssDimensions(element) {
    const css = getComputedStyle(element);
    // In testing environments, the `width` and `height` properties are empty
    // strings for SVG elements, returning NaN. Fallback to `0` in this case.
    let width = parseFloat(css.width) || 0;
    let height = parseFloat(css.height) || 0;
    const hasOffset = isHTMLElement(element);
    const offsetWidth = hasOffset ? element.offsetWidth : width;
    const offsetHeight = hasOffset ? element.offsetHeight : height;
    const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
    if (shouldFallback) {
      width = offsetWidth;
      height = offsetHeight;
    }
    return {
      width,
      height,
      $: shouldFallback
    };
  }

  function unwrapElement(element) {
    return !isElement(element) ? element.contextElement : element;
  }

  function getScale(element) {
    const domElement = unwrapElement(element);
    if (!isHTMLElement(domElement)) {
      return createCoords(1);
    }
    const rect = domElement.getBoundingClientRect();
    const {
      width,
      height,
      $
    } = getCssDimensions(domElement);
    let x = ($ ? round(rect.width) : rect.width) / width;
    let y = ($ ? round(rect.height) : rect.height) / height;

    // 0, NaN, or Infinity should always fallback to 1.

    if (!x || !Number.isFinite(x)) {
      x = 1;
    }
    if (!y || !Number.isFinite(y)) {
      y = 1;
    }
    return {
      x,
      y
    };
  }

  const noOffsets = /*#__PURE__*/createCoords(0);
  function getVisualOffsets(element) {
    const win = getWindow(element);
    if (!isWebKit() || !win.visualViewport) {
      return noOffsets;
    }
    return {
      x: win.visualViewport.offsetLeft,
      y: win.visualViewport.offsetTop
    };
  }
  function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
      return false;
    }
    return isFixed;
  }

  function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    const clientRect = element.getBoundingClientRect();
    const domElement = unwrapElement(element);
    let scale = createCoords(1);
    if (includeScale) {
      if (offsetParent) {
        if (isElement(offsetParent)) {
          scale = getScale(offsetParent);
        }
      } else {
        scale = getScale(element);
      }
    }
    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
    let x = (clientRect.left + visualOffsets.x) / scale.x;
    let y = (clientRect.top + visualOffsets.y) / scale.y;
    let width = clientRect.width / scale.x;
    let height = clientRect.height / scale.y;
    if (domElement) {
      const win = getWindow(domElement);
      const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
      let currentWin = win;
      let currentIFrame = getFrameElement(currentWin);
      while (currentIFrame && offsetParent && offsetWin !== currentWin) {
        const iframeScale = getScale(currentIFrame);
        const iframeRect = currentIFrame.getBoundingClientRect();
        const css = getComputedStyle(currentIFrame);
        const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
        const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
        x *= iframeScale.x;
        y *= iframeScale.y;
        width *= iframeScale.x;
        height *= iframeScale.y;
        x += left;
        y += top;
        currentWin = getWindow(currentIFrame);
        currentIFrame = getFrameElement(currentWin);
      }
    }
    return core.rectToClientRect({
      width,
      height,
      x,
      y
    });
  }

  function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
    let {
      elements,
      rect,
      offsetParent,
      strategy
    } = _ref;
    const isFixed = strategy === 'fixed';
    const documentElement = getDocumentElement(offsetParent);
    const topLayer = elements ? isTopLayer(elements.floating) : false;
    if (offsetParent === documentElement || topLayer && isFixed) {
      return rect;
    }
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    let scale = createCoords(1);
    const offsets = createCoords(0);
    const isOffsetParentAnElement = isHTMLElement(offsetParent);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        const offsetRect = getBoundingClientRect(offsetParent);
        scale = getScale(offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      }
    }
    return {
      width: rect.width * scale.x,
      height: rect.height * scale.y,
      x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
      y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
    };
  }

  function getClientRects(element) {
    return Array.from(element.getClientRects());
  }

  function getWindowScrollBarX(element) {
    // If <html> has a CSS width greater than the viewport, then this will be
    // incorrect for RTL.
    return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
  }

  // Gets the entire size of the scrollable document area, even extending outside
  // of the `<html>` and `<body>` rect bounds if horizontally scrollable.
  function getDocumentRect(element) {
    const html = getDocumentElement(element);
    const scroll = getNodeScroll(element);
    const body = element.ownerDocument.body;
    const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
    const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
    let x = -scroll.scrollLeft + getWindowScrollBarX(element);
    const y = -scroll.scrollTop;
    if (getComputedStyle(body).direction === 'rtl') {
      x += max(html.clientWidth, body.clientWidth) - width;
    }
    return {
      width,
      height,
      x,
      y
    };
  }

  function getViewportRect(element, strategy) {
    const win = getWindow(element);
    const html = getDocumentElement(element);
    const visualViewport = win.visualViewport;
    let width = html.clientWidth;
    let height = html.clientHeight;
    let x = 0;
    let y = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      const visualViewportBased = isWebKit();
      if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x,
      y
    };
  }

  // Returns the inner client rect, subtracting scrollbars if present.
  function getInnerBoundingClientRect(element, strategy) {
    const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
    const top = clientRect.top + element.clientTop;
    const left = clientRect.left + element.clientLeft;
    const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
    const width = element.clientWidth * scale.x;
    const height = element.clientHeight * scale.y;
    const x = left * scale.x;
    const y = top * scale.y;
    return {
      width,
      height,
      x,
      y
    };
  }
  function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
    let rect;
    if (clippingAncestor === 'viewport') {
      rect = getViewportRect(element, strategy);
    } else if (clippingAncestor === 'document') {
      rect = getDocumentRect(getDocumentElement(element));
    } else if (isElement(clippingAncestor)) {
      rect = getInnerBoundingClientRect(clippingAncestor, strategy);
    } else {
      const visualOffsets = getVisualOffsets(element);
      rect = {
        ...clippingAncestor,
        x: clippingAncestor.x - visualOffsets.x,
        y: clippingAncestor.y - visualOffsets.y
      };
    }
    return core.rectToClientRect(rect);
  }
  function hasFixedPositionAncestor(element, stopNode) {
    const parentNode = getParentNode(element);
    if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
      return false;
    }
    return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);
  }

  // A "clipping ancestor" is an `overflow` element with the characteristic of
  // clipping (or hiding) child elements. This returns all clipping ancestors
  // of the given element up the tree.
  function getClippingElementAncestors(element, cache) {
    const cachedResult = cache.get(element);
    if (cachedResult) {
      return cachedResult;
    }
    let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');
    let currentContainingBlockComputedStyle = null;
    const elementIsFixed = getComputedStyle(element).position === 'fixed';
    let currentNode = elementIsFixed ? getParentNode(element) : element;

    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
    while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
      const computedStyle = getComputedStyle(currentNode);
      const currentNodeIsContaining = isContainingBlock(currentNode);
      if (!currentNodeIsContaining && computedStyle.position === 'fixed') {
        currentContainingBlockComputedStyle = null;
      }
      const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
      if (shouldDropCurrentNode) {
        // Drop non-containing blocks.
        result = result.filter(ancestor => ancestor !== currentNode);
      } else {
        // Record last containing block for next iteration.
        currentContainingBlockComputedStyle = computedStyle;
      }
      currentNode = getParentNode(currentNode);
    }
    cache.set(element, result);
    return result;
  }

  // Gets the maximum area that the element is visible in due to any number of
  // clipping ancestors.
  function getClippingRect(_ref) {
    let {
      element,
      boundary,
      rootBoundary,
      strategy
    } = _ref;
    const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
    const clippingAncestors = [...elementClippingAncestors, rootBoundary];
    const firstClippingAncestor = clippingAncestors[0];
    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
      const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
    return {
      width: clippingRect.right - clippingRect.left,
      height: clippingRect.bottom - clippingRect.top,
      x: clippingRect.left,
      y: clippingRect.top
    };
  }

  function getDimensions(element) {
    const {
      width,
      height
    } = getCssDimensions(element);
    return {
      width,
      height
    };
  }

  function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
    const isOffsetParentAnElement = isHTMLElement(offsetParent);
    const documentElement = getDocumentElement(offsetParent);
    const isFixed = strategy === 'fixed';
    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const offsets = createCoords(0);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isOffsetParentAnElement) {
        const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    const x = rect.left + scroll.scrollLeft - offsets.x;
    const y = rect.top + scroll.scrollTop - offsets.y;
    return {
      x,
      y,
      width: rect.width,
      height: rect.height
    };
  }

  function isStaticPositioned(element) {
    return getComputedStyle(element).position === 'static';
  }

  function getTrueOffsetParent(element, polyfill) {
    if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {
      return null;
    }
    if (polyfill) {
      return polyfill(element);
    }
    return element.offsetParent;
  }

  // Gets the closest ancestor positioned element. Handles some edge cases,
  // such as table ancestors and cross browser bugs.
  function getOffsetParent(element, polyfill) {
    const win = getWindow(element);
    if (isTopLayer(element)) {
      return win;
    }
    if (!isHTMLElement(element)) {
      let svgOffsetParent = getParentNode(element);
      while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
        if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
          return svgOffsetParent;
        }
        svgOffsetParent = getParentNode(svgOffsetParent);
      }
      return win;
    }
    let offsetParent = getTrueOffsetParent(element, polyfill);
    while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
      offsetParent = getTrueOffsetParent(offsetParent, polyfill);
    }
    if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
      return win;
    }
    return offsetParent || getContainingBlock(element) || win;
  }

  const getElementRects = async function (data) {
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    const floatingDimensions = await getDimensionsFn(data.floating);
    return {
      reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
      floating: {
        x: 0,
        y: 0,
        width: floatingDimensions.width,
        height: floatingDimensions.height
      }
    };
  };

  function isRTL(element) {
    return getComputedStyle(element).direction === 'rtl';
  }

  const platform = {
    convertOffsetParentRelativeRectToViewportRelativeRect,
    getDocumentElement,
    getClippingRect,
    getOffsetParent,
    getElementRects,
    getClientRects,
    getDimensions,
    getScale,
    isElement,
    isRTL
  };

  // https://samthor.au/2021/observing-dom/
  function observeMove(element, onMove) {
    let io = null;
    let timeoutId;
    const root = getDocumentElement(element);
    function cleanup() {
      var _io;
      clearTimeout(timeoutId);
      (_io = io) == null || _io.disconnect();
      io = null;
    }
    function refresh(skip, threshold) {
      if (skip === void 0) {
        skip = false;
      }
      if (threshold === void 0) {
        threshold = 1;
      }
      cleanup();
      const {
        left,
        top,
        width,
        height
      } = element.getBoundingClientRect();
      if (!skip) {
        onMove();
      }
      if (!width || !height) {
        return;
      }
      const insetTop = floor(top);
      const insetRight = floor(root.clientWidth - (left + width));
      const insetBottom = floor(root.clientHeight - (top + height));
      const insetLeft = floor(left);
      const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
      const options = {
        rootMargin,
        threshold: max(0, min(1, threshold)) || 1
      };
      let isFirstUpdate = true;
      function handleObserve(entries) {
        const ratio = entries[0].intersectionRatio;
        if (ratio !== threshold) {
          if (!isFirstUpdate) {
            return refresh();
          }
          if (!ratio) {
            // If the reference is clipped, the ratio is 0. Throttle the refresh
            // to prevent an infinite loop of updates.
            timeoutId = setTimeout(() => {
              refresh(false, 1e-7);
            }, 1000);
          } else {
            refresh(false, ratio);
          }
        }
        isFirstUpdate = false;
      }

      // Older browsers don't support a `document` as the root and will throw an
      // error.
      try {
        io = new IntersectionObserver(handleObserve, {
          ...options,
          // Handle <iframe>s
          root: root.ownerDocument
        });
      } catch (e) {
        io = new IntersectionObserver(handleObserve, options);
      }
      io.observe(element);
    }
    refresh(true);
    return cleanup;
  }

  /**
   * Automatically updates the position of the floating element when necessary.
   * Should only be called when the floating element is mounted on the DOM or
   * visible on the screen.
   * @returns cleanup function that should be invoked when the floating element is
   * removed from the DOM or hidden from the screen.
   * @see https://floating-ui.com/docs/autoUpdate
   */
  function autoUpdate(reference, floating, update, options) {
    if (options === void 0) {
      options = {};
    }
    const {
      ancestorScroll = true,
      ancestorResize = true,
      elementResize = typeof ResizeObserver === 'function',
      layoutShift = typeof IntersectionObserver === 'function',
      animationFrame = false
    } = options;
    const referenceEl = unwrapElement(reference);
    const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];
    ancestors.forEach(ancestor => {
      ancestorScroll && ancestor.addEventListener('scroll', update, {
        passive: true
      });
      ancestorResize && ancestor.addEventListener('resize', update);
    });
    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
    let reobserveFrame = -1;
    let resizeObserver = null;
    if (elementResize) {
      resizeObserver = new ResizeObserver(_ref => {
        let [firstEntry] = _ref;
        if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
          // Prevent update loops when using the `size` middleware.
          // https://github.com/floating-ui/floating-ui/issues/1740
          resizeObserver.unobserve(floating);
          cancelAnimationFrame(reobserveFrame);
          reobserveFrame = requestAnimationFrame(() => {
            var _resizeObserver;
            (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
          });
        }
        update();
      });
      if (referenceEl && !animationFrame) {
        resizeObserver.observe(referenceEl);
      }
      resizeObserver.observe(floating);
    }
    let frameId;
    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
    if (animationFrame) {
      frameLoop();
    }
    function frameLoop() {
      const nextRefRect = getBoundingClientRect(reference);
      if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
        update();
      }
      prevRefRect = nextRefRect;
      frameId = requestAnimationFrame(frameLoop);
    }
    update();
    return () => {
      var _resizeObserver2;
      ancestors.forEach(ancestor => {
        ancestorScroll && ancestor.removeEventListener('scroll', update);
        ancestorResize && ancestor.removeEventListener('resize', update);
      });
      cleanupIo == null || cleanupIo();
      (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
      resizeObserver = null;
      if (animationFrame) {
        cancelAnimationFrame(frameId);
      }
    };
  }

  /**
   * Resolves with an object of overflow side offsets that determine how much the
   * element is overflowing a given clipping boundary on each side.
   * - positive = overflowing the boundary by that number of pixels
   * - negative = how many pixels left before it will overflow
   * - 0 = lies flush with the boundary
   * @see https://floating-ui.com/docs/detectOverflow
   */
  const detectOverflow = core.detectOverflow;

  /**
   * Modifies the placement by translating the floating element along the
   * specified axes.
   * A number (shorthand for `mainAxis` or distance), or an axes configuration
   * object may be passed.
   * @see https://floating-ui.com/docs/offset
   */
  const offset = core.offset;

  /**
   * Optimizes the visibility of the floating element by choosing the placement
   * that has the most space available automatically, without needing to specify a
   * preferred placement. Alternative to `flip`.
   * @see https://floating-ui.com/docs/autoPlacement
   */
  const autoPlacement = core.autoPlacement;

  /**
   * Optimizes the visibility of the floating element by shifting it in order to
   * keep it in view when it will overflow the clipping boundary.
   * @see https://floating-ui.com/docs/shift
   */
  const shift = core.shift;

  /**
   * Optimizes the visibility of the floating element by flipping the `placement`
   * in order to keep it in view when the preferred placement(s) will overflow the
   * clipping boundary. Alternative to `autoPlacement`.
   * @see https://floating-ui.com/docs/flip
   */
  const flip = core.flip;

  /**
   * Provides data that allows you to change the size of the floating element —
   * for instance, prevent it from overflowing the clipping boundary or match the
   * width of the reference element.
   * @see https://floating-ui.com/docs/size
   */
  const size = core.size;

  /**
   * Provides data to hide the floating element in applicable situations, such as
   * when it is not in the same clipping context as the reference element.
   * @see https://floating-ui.com/docs/hide
   */
  const hide = core.hide;

  /**
   * Provides data to position an inner element of the floating element so that it
   * appears centered to the reference element.
   * @see https://floating-ui.com/docs/arrow
   */
  const arrow = core.arrow;

  /**
   * Provides improved positioning for inline reference elements that can span
   * over multiple lines, such as hyperlinks or range selections.
   * @see https://floating-ui.com/docs/inline
   */
  const inline = core.inline;

  /**
   * Built-in `limiter` that will stop `shift()` at a certain point.
   */
  const limitShift = core.limitShift;

  /**
   * Computes the `x` and `y` coordinates that will place the floating element
   * next to a given reference element.
   */
  const computePosition = (reference, floating, options) => {
    // This caches the expensive `getClippingElementAncestors` function so that
    // multiple lifecycle resets re-use the same result. It only lives for a
    // single call. If other functions become expensive, we can add them as well.
    const cache = new Map();
    const mergedOptions = {
      platform,
      ...options
    };
    const platformWithCache = {
      ...mergedOptions.platform,
      _c: cache
    };
    return core.computePosition(reference, floating, {
      ...mergedOptions,
      platform: platformWithCache
    });
  };

  exports.arrow = arrow;
  exports.autoPlacement = autoPlacement;
  exports.autoUpdate = autoUpdate;
  exports.computePosition = computePosition;
  exports.detectOverflow = detectOverflow;
  exports.flip = flip;
  exports.getOverflowAncestors = getOverflowAncestors;
  exports.hide = hide;
  exports.inline = inline;
  exports.limitShift = limitShift;
  exports.offset = offset;
  exports.platform = platform;
  exports.shift = shift;
  exports.size = size;

}));


/***/ }),

/***/ "./JS/excel.ts":
/*!*********************!*\
  !*** ./JS/excel.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createTable: () => (/* binding */ createTable),
/* harmony export */   deleteTable: () => (/* binding */ deleteTable),
/* harmony export */   getValue: () => (/* binding */ getValue),
/* harmony export */   insertData: () => (/* binding */ insertData),
/* harmony export */   pasteData: () => (/* binding */ pasteData),
/* harmony export */   pasteGrid: () => (/* binding */ pasteGrid),
/* harmony export */   pasteSpecs: () => (/* binding */ pasteSpecs),
/* harmony export */   setFormula: () => (/* binding */ setFormula),
/* harmony export */   setValues: () => (/* binding */ setValues)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var svelte_store__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! svelte/store */ "./node_modules/svelte/store/index.mjs");
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./stores */ "./JS/stores.ts");
/* harmony import */ var _persist__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./persist */ "./JS/persist.ts");
/* harmony import */ var _menus__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./menus */ "./JS/menus.ts");








var SHEET = /^'?([^']*)'?!(.*)/;
var DATETYPE = /^(?:19|20)[0-9][0-9]-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])$/;
var ALIASTRIMVIEW = /\S*_/;
var ALIASTRIMAGGR = /\S*\.|_\S*/;
function getDetails(_x) {
  return _getDetails.apply(this, arguments);
}
function _getDetails() {
  _getDetails = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee(id) {
    var details;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return (0,_persist__WEBPACK_IMPORTED_MODULE_6__.getItem)("cql-".concat(id));
        case 2:
          details = _context.sent;
          if (!(details === null)) {
            _context.next = 5;
            break;
          }
          throw "No data available!";
        case 5:
          return _context.abrupt("return", details);
        case 6:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _getDetails.apply(this, arguments);
}
function setValues(_x2) {
  return _setValues.apply(this, arguments);
}
function _setValues() {
  _setValues = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee3(values) {
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          _context3.prev = 0;
          _context3.next = 3;
          return Excel.run( /*#__PURE__*/function () {
            var _ref = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee2(ctx) {
              var names, _i, _Object$entries, _Object$entries$_i, alias, value, name, ob, ar, range;
              return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee2$(_context2) {
                while (1) switch (_context2.prev = _context2.next) {
                  case 0:
                    names = ctx.workbook.names;
                    _i = 0, _Object$entries = Object.entries(values);
                  case 2:
                    if (!(_i < _Object$entries.length)) {
                      _context2.next = 13;
                      break;
                    }
                    _Object$entries$_i = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default()(_Object$entries[_i], 2), alias = _Object$entries$_i[0], value = _Object$entries$_i[1];
                    name = names.getItemOrNullObject(alias);
                    ob = Object.prototype.toString.call(value) === "[object Object]";
                    ar = Object.prototype.toString.call(value) === "[object Array]";
                    _context2.next = 9;
                    return ctx.sync();
                  case 9:
                    if (!name.isNullObject) {
                      range = name.getRangeOrNullObject();
                      range.values = ar ? value : [[ob ? value === null || value === void 0 ? void 0 : value.value : value]];
                    }
                  case 10:
                    _i++;
                    _context2.next = 2;
                    break;
                  case 13:
                  case "end":
                    return _context2.stop();
                }
              }, _callee2);
            }));
            return function (_x12) {
              return _ref.apply(this, arguments);
            };
          }());
        case 3:
          _context3.next = 8;
          break;
        case 5:
          _context3.prev = 5;
          _context3.t0 = _context3["catch"](0);
          _stores__WEBPACK_IMPORTED_MODULE_5__.stateStore.error("Set Value Failed", _context3.t0.message, null);
        case 8:
        case "end":
          return _context3.stop();
      }
    }, _callee3, null, [[0, 5]]);
  }));
  return _setValues.apply(this, arguments);
}
function setFormula(_x3, _x4) {
  return _setFormula.apply(this, arguments);
}
function _setFormula() {
  _setFormula = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee5(name, formula) {
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          _context5.prev = 0;
          _context5.next = 3;
          return Excel.run( /*#__PURE__*/function () {
            var _ref2 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee4(ctx) {
              var names, cell, range;
              return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee4$(_context4) {
                while (1) switch (_context4.prev = _context4.next) {
                  case 0:
                    names = ctx.workbook.names;
                    cell = names.getItemOrNullObject(name);
                    _context4.next = 4;
                    return ctx.sync();
                  case 4:
                    if (cell.isNullObject) {
                      _context4.next = 10;
                      break;
                    }
                    range = cell.getRange();
                    range.formulas = [["=".concat(formula)]];
                    range.numberFormat = [[""]];
                    _context4.next = 10;
                    return ctx.sync();
                  case 10:
                  case "end":
                    return _context4.stop();
                }
              }, _callee4);
            }));
            return function (_x13) {
              return _ref2.apply(this, arguments);
            };
          }());
        case 3:
          _context5.next = 8;
          break;
        case 5:
          _context5.prev = 5;
          _context5.t0 = _context5["catch"](0);
          _stores__WEBPACK_IMPORTED_MODULE_5__.stateStore.error("Set Formula Failed", _context5.t0.message, null);
        case 8:
        case "end":
          return _context5.stop();
      }
    }, _callee5, null, [[0, 5]]);
  }));
  return _setFormula.apply(this, arguments);
}
function getValue(_x5) {
  return _getValue.apply(this, arguments);
}
function _getValue() {
  _getValue = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee7(name) {
    var value;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee7$(_context7) {
      while (1) switch (_context7.prev = _context7.next) {
        case 0:
          _context7.prev = 0;
          _context7.next = 3;
          return Excel.run( /*#__PURE__*/function () {
            var _ref3 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee6(ctx) {
              var names, cell, range;
              return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee6$(_context6) {
                while (1) switch (_context6.prev = _context6.next) {
                  case 0:
                    names = ctx.workbook.names;
                    cell = names.getItemOrNullObject(name);
                    _context6.next = 4;
                    return ctx.sync();
                  case 4:
                    if (cell.isNullObject) {
                      _context6.next = 12;
                      break;
                    }
                    range = cell.getRange();
                    range.load("values");
                    _context6.next = 9;
                    return ctx.sync();
                  case 9:
                    return _context6.abrupt("return", range.values);
                  case 12:
                    _stores__WEBPACK_IMPORTED_MODULE_5__.stateStore.error("Get Value Failed", "Name '".concat(name, "' not Found!"), null);
                  case 13:
                    return _context6.abrupt("return", null);
                  case 14:
                  case "end":
                    return _context6.stop();
                }
              }, _callee6);
            }));
            return function (_x14) {
              return _ref3.apply(this, arguments);
            };
          }());
        case 3:
          value = _context7.sent;
          return _context7.abrupt("return", value);
        case 7:
          _context7.prev = 7;
          _context7.t0 = _context7["catch"](0);
          _stores__WEBPACK_IMPORTED_MODULE_5__.stateStore.error("Get Value Failed", _context7.t0.message, null);
        case 10:
          return _context7.abrupt("return", null);
        case 11:
        case "end":
          return _context7.stop();
      }
    }, _callee7, null, [[0, 7]]);
  }));
  return _getValue.apply(this, arguments);
}
function deleteTable(_x6) {
  return _deleteTable.apply(this, arguments);
}
function _deleteTable() {
  _deleteTable = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee9(header) {
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee9$(_context9) {
      while (1) switch (_context9.prev = _context9.next) {
        case 0:
          _context9.prev = 0;
          if (header.id) {
            _context9.next = 3;
            break;
          }
          throw "Missing name!";
        case 3:
          _context9.next = 5;
          return Excel.run( /*#__PURE__*/function () {
            var _ref4 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee8(context) {
              var exists;
              return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee8$(_context8) {
                while (1) switch (_context8.prev = _context8.next) {
                  case 0:
                    // Test if table exists
                    exists = context.workbook.tables.getItemOrNullObject(header.id);
                    exists.load();
                    _context8.next = 4;
                    return context.sync();
                  case 4:
                    if (!exists.isNullObject) {
                      _context8.next = 6;
                      break;
                    }
                    throw "Table \"".concat(header.id, "\" does not exists!");
                  case 6:
                    // Delete table
                    exists["delete"]();
                    _context8.next = 9;
                    return context.sync();
                  case 9:
                  case "end":
                    return _context8.stop();
                }
              }, _callee8);
            }));
            return function (_x15) {
              return _ref4.apply(this, arguments);
            };
          }());
        case 5:
          _context9.next = 10;
          break;
        case 7:
          _context9.prev = 7;
          _context9.t0 = _context9["catch"](0);
          _stores__WEBPACK_IMPORTED_MODULE_5__.stateStore.error("Failed to delete Table", _context9.t0, null);
        case 10:
        case "end":
          return _context9.stop();
      }
    }, _callee9, null, [[0, 7]]);
  }));
  return _deleteTable.apply(this, arguments);
}
function createTable(_x7) {
  return _createTable.apply(this, arguments);
}
function _createTable() {
  _createTable = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee11(header) {
    var rows;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee11$(_context11) {
      while (1) switch (_context11.prev = _context11.next) {
        case 0:
          _context11.prev = 0;
          if (header.id) {
            _context11.next = 3;
            break;
          }
          throw "Missing name!";
        case 3:
          _context11.next = 5;
          return getDetails(header.id);
        case 5:
          rows = _context11.sent.results;
          if (!(rows.length == 0)) {
            _context11.next = 8;
            break;
          }
          throw "No data!";
        case 8:
          _context11.next = 10;
          return Excel.run( /*#__PURE__*/function () {
            var _ref5 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee10(context) {
              var exists, sheet, cell, columns, range, fmt, table, cols, _yield$getItem, menus;
              return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee10$(_context10) {
                while (1) switch (_context10.prev = _context10.next) {
                  case 0:
                    // Test if table exists
                    exists = context.workbook.tables.getItemOrNullObject(header.id);
                    exists.load();
                    _context10.next = 4;
                    return context.sync();
                  case 4:
                    if (exists.isNullObject) {
                      _context10.next = 6;
                      break;
                    }
                    throw "Table \"".concat(header.id, "\" exists!");
                  case 6:
                    // Create table
                    sheet = context.workbook.worksheets.getActiveWorksheet();
                    cell = context.workbook.getActiveCell();
                    columns = rows[0].length + (header.withMenu ? 1 : 0);
                    range = cell.getResizedRange(0, columns - 1);
                    fmt = rows[0].map(function (c) {
                      return typeof c === "string" ? c.length === 0 || c[0] === "=" || DATETYPE.test(c) ? null : "@" : null;
                    });
                    range.numberFormat = [header.withMenu ? ["@"].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(fmt)) : fmt];
                    table = sheet.tables.add(range, true);
                    table.name = header.id;
                    cols = Object.entries(header.columns).map(function (c) {
                      return header.aliasHeader ? c[1] === "" ? c[0].replace(ALIASTRIMAGGR, "") : c[0].replace(ALIASTRIMVIEW, "") : c[1] === "" ? c[0] : c[1];
                    });
                    table.getHeaderRowRange().values = [header.withMenu ? ["."].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(cols)) : cols];
                    if (header.withMenu) {
                      table.onChanged.add(_menus__WEBPACK_IMPORTED_MODULE_7__.onMenuChanged);
                    }
                    _context10.next = 19;
                    return context.sync();
                  case 19:
                    if (!header.withMenu) {
                      _context10.next = 34;
                      break;
                    }
                    _context10.next = 22;
                    return (0,_persist__WEBPACK_IMPORTED_MODULE_6__.getItem)(_menus__WEBPACK_IMPORTED_MODULE_7__.MENU_KEY);
                  case 22:
                    _context10.t1 = _yield$getItem = _context10.sent;
                    _context10.t0 = _context10.t1 !== null;
                    if (!_context10.t0) {
                      _context10.next = 26;
                      break;
                    }
                    _context10.t0 = _yield$getItem !== void 0;
                  case 26:
                    if (!_context10.t0) {
                      _context10.next = 30;
                      break;
                    }
                    _context10.t2 = _yield$getItem;
                    _context10.next = 31;
                    break;
                  case 30:
                    _context10.t2 = [];
                  case 31:
                    menus = _context10.t2;
                    _context10.next = 34;
                    return (0,_persist__WEBPACK_IMPORTED_MODULE_6__.setItem)(_menus__WEBPACK_IMPORTED_MODULE_7__.MENU_KEY, [].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(menus), [table.id]));
                  case 34:
                  case "end":
                    return _context10.stop();
                }
              }, _callee10);
            }));
            return function (_x16) {
              return _ref5.apply(this, arguments);
            };
          }());
        case 10:
          _context11.next = 15;
          break;
        case 12:
          _context11.prev = 12;
          _context11.t0 = _context11["catch"](0);
          _stores__WEBPACK_IMPORTED_MODULE_5__.stateStore.error("Failed to create Table", _context11.t0, null);
        case 15:
        case "end":
          return _context11.stop();
      }
    }, _callee11, null, [[0, 12]]);
  }));
  return _createTable.apply(this, arguments);
}
function insertData(_x8) {
  return _insertData.apply(this, arguments);
}
function _insertData() {
  _insertData = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee13(header) {
    var rows;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee13$(_context13) {
      while (1) switch (_context13.prev = _context13.next) {
        case 0:
          _context13.prev = 0;
          if (header.id) {
            _context13.next = 3;
            break;
          }
          throw "Missing name!";
        case 3:
          _context13.next = 5;
          return getDetails(header.id);
        case 5:
          rows = _context13.sent.results;
          _context13.next = 8;
          return Excel.run( /*#__PURE__*/function () {
            var _ref6 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee12(context) {
              var _header$insertOption;
              var table, cols, body, showTotals;
              return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee12$(_context12) {
                while (1) switch (_context12.prev = _context12.next) {
                  case 0:
                    table = context.workbook.tables.getItem(header.id);
                    cols = table.getHeaderRowRange().load("values");
                    table.load("showTotals");
                    _context12.next = 5;
                    return context.sync();
                  case 5:
                    if (rows.length > 0 && rows[0].length < cols.values[0].length) {
                      if (header.withMenu) {
                        rows = rows.map(function (r) {
                          return [null].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(r), _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(Array(cols.values[0].length - rows[0].length - 1).fill(null)));
                        });
                      } else {
                        rows = rows.map(function (r) {
                          return [].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(r), _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(Array(cols.values[0].length - rows[0].length).fill(null)));
                        });
                      }
                    }
                    _context12.t0 = (_header$insertOption = header.insertOption) !== null && _header$insertOption !== void 0 ? _header$insertOption : 0;
                    _context12.next = _context12.t0 === 0 ? 9 : _context12.t0 === 1 ? 11 : _context12.t0 === 2 ? 13 : 20;
                    break;
                  case 9:
                    table.rows.add(0, rows.length > 0 ? rows : null);
                    return _context12.abrupt("break", 20);
                  case 11:
                    table.rows.add(null, rows.length > 0 ? rows : null);
                    return _context12.abrupt("break", 20);
                  case 13:
                    body = table.getDataBodyRange();
                    showTotals = table.showTotals;
                    table.showTotals = false;
                    table.rows.add(null, rows.length > 0 ? rows : null);
                    table.showTotals = showTotals;
                    body["delete"](Excel.DeleteShiftDirection.up);
                    return _context12.abrupt("break", 20);
                  case 20:
                    _context12.next = 22;
                    return context.sync();
                  case 22:
                  case "end":
                    return _context12.stop();
                }
              }, _callee12);
            }));
            return function (_x17) {
              return _ref6.apply(this, arguments);
            };
          }());
        case 8:
          _context13.next = 14;
          break;
        case 10:
          _context13.prev = 10;
          _context13.t0 = _context13["catch"](0);
          if (_context13.t0.code !== "InvalidBinding") {
            _stores__WEBPACK_IMPORTED_MODULE_5__.stateStore.error("Table Insert Error", _context13.t0.message, null);
          }
          console.error(JSON.stringify(_context13.t0));
        case 14:
        case "end":
          return _context13.stop();
      }
    }, _callee13, null, [[0, 10]]);
  }));
  return _insertData.apply(this, arguments);
}
function pasteData(_x9) {
  return _pasteData.apply(this, arguments);
}
function _pasteData() {
  _pasteData = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee15(header) {
    var options, rows;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee15$(_context15) {
      while (1) switch (_context15.prev = _context15.next) {
        case 0:
          options = (0,svelte_store__WEBPACK_IMPORTED_MODULE_4__.get)(_stores__WEBPACK_IMPORTED_MODULE_5__.optionsStore);
          _context15.prev = 1;
          _context15.next = 4;
          return getDetails(header.id);
        case 4:
          rows = _context15.sent.results;
          _context15.next = 7;
          return Excel.run( /*#__PURE__*/function () {
            var _ref7 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee14(context) {
              var startCell, heading, titles, detail;
              return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee14$(_context14) {
                while (1) switch (_context14.prev = _context14.next) {
                  case 0:
                    startCell = context.workbook.getActiveCell();
                    if (options.includeHeader) {
                      heading = startCell.getResizedRange(0, rows[0].length - 1);
                      titles = Object.entries(header.columns).map(function (c) {
                        return c[1] === "" ? c[0] : c[1];
                      });
                      heading.values = [titles];
                      startCell = startCell.getCell(1, 0);
                    }
                    detail = startCell.getResizedRange(rows.length - 1, rows[0].length - 1);
                    detail.numberFormat = rows.map(function (r) {
                      return r.map(function (c) {
                        return typeof c === "string" ? c.length === 0 || c[0] === "=" || DATETYPE.test(c) ? null : "@" : null;
                      });
                    });
                    detail.values = rows;
                    _context14.next = 7;
                    return context.sync();
                  case 7:
                  case "end":
                    return _context14.stop();
                }
              }, _callee14);
            }));
            return function (_x18) {
              return _ref7.apply(this, arguments);
            };
          }());
        case 7:
          _context15.next = 12;
          break;
        case 9:
          _context15.prev = 9;
          _context15.t0 = _context15["catch"](1);
          _stores__WEBPACK_IMPORTED_MODULE_5__.stateStore.error("Paste data error", _context15.t0.message, null);
        case 12:
        case "end":
          return _context15.stop();
      }
    }, _callee15, null, [[1, 9]]);
  }));
  return _pasteData.apply(this, arguments);
}
function pasteGrid(_x10) {
  return _pasteGrid.apply(this, arguments);
}
function _pasteGrid() {
  _pasteGrid = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee17(data) {
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee17$(_context17) {
      while (1) switch (_context17.prev = _context17.next) {
        case 0:
          if (!(data && data.length > 0)) {
            _context17.next = 11;
            break;
          }
          _context17.prev = 1;
          _context17.next = 4;
          return Excel.run( /*#__PURE__*/function () {
            var _ref8 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee16(context) {
              var startCell, range;
              return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee16$(_context16) {
                while (1) switch (_context16.prev = _context16.next) {
                  case 0:
                    startCell = context.workbook.getActiveCell();
                    range = startCell.getResizedRange(data.length - 1, data[0].length - 1);
                    range.numberFormat = data.map(function (r) {
                      return r.map(function (c) {
                        return typeof c === "string" ? DATETYPE.test(c) ? null : "@" : null;
                      });
                    });
                    range.values = data;
                    _context16.next = 6;
                    return context.sync();
                  case 6:
                  case "end":
                    return _context16.stop();
                }
              }, _callee16);
            }));
            return function (_x19) {
              return _ref8.apply(this, arguments);
            };
          }());
        case 4:
          _context17.next = 9;
          break;
        case 6:
          _context17.prev = 6;
          _context17.t0 = _context17["catch"](1);
          _stores__WEBPACK_IMPORTED_MODULE_5__.stateStore.error("Grid paste error", _context17.t0.message, null);
        case 9:
          _context17.next = 12;
          break;
        case 11:
          _stores__WEBPACK_IMPORTED_MODULE_5__.stateStore.error("Grid paste error", "Grid Empty!", null);
        case 12:
        case "end":
          return _context17.stop();
      }
    }, _callee17, null, [[1, 6]]);
  }));
  return _pasteGrid.apply(this, arguments);
}
function pasteSpecs(_x11) {
  return _pasteSpecs.apply(this, arguments);
}
function _pasteSpecs() {
  _pasteSpecs = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee19(data) {
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee19$(_context19) {
      while (1) switch (_context19.prev = _context19.next) {
        case 0:
          _context19.prev = 0;
          _context19.next = 3;
          return Excel.run( /*#__PURE__*/function () {
            var _ref9 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee18(context) {
              var startCell, range;
              return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee18$(_context18) {
                while (1) switch (_context18.prev = _context18.next) {
                  case 0:
                    startCell = context.workbook.getActiveCell();
                    range = startCell.getResizedRange(data.length - 1, data[0].length - 1);
                    range.values = data;
                    _context18.next = 5;
                    return context.sync();
                  case 5:
                  case "end":
                    return _context18.stop();
                }
              }, _callee18);
            }));
            return function (_x20) {
              return _ref9.apply(this, arguments);
            };
          }());
        case 3:
          _context19.next = 8;
          break;
        case 5:
          _context19.prev = 5;
          _context19.t0 = _context19["catch"](0);
          _stores__WEBPACK_IMPORTED_MODULE_5__.stateStore.error("Specs paste error", _context19.t0.message, null);
        case 8:
        case "end":
          return _context19.stop();
      }
    }, _callee19, null, [[0, 5]]);
  }));
  return _pasteSpecs.apply(this, arguments);
}

/***/ }),

/***/ "./JS/functions.ts":
/*!*************************!*\
  !*** ./JS/functions.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var svelte_store__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! svelte/store */ "./node_modules/svelte/store/index.mjs");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./types */ "./JS/types.ts");
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./stores */ "./JS/stores.ts");
/* harmony import */ var _submit__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./submit */ "./JS/submit.ts");
/* harmony import */ var _persist__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./persist */ "./JS/persist.ts");




function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }






/**
 * Call a Function on CQL Update
 * @customfunction
 * @helpUrl https://celin.io/xl-docs/functions/oncql.html
 * @param {string} name
 * @param {string} func
 * @param {any[][][]} parameters
 * @param {CustomFunctions.StreamingInvocation<any[][]>} invocation Function Return
 */
function oncql(name, func, parameters, invocation) {
  try {
    var cmd = (0,svelte_store__WEBPACK_IMPORTED_MODULE_4__.get)(_stores__WEBPACK_IMPORTED_MODULE_6__.cmdStore).find(function (c) {
      return c.id === func;
    });
    if (cmd) {
      if (cmd.type != _types__WEBPACK_IMPORTED_MODULE_5__.CommandType.func) {
        invocation.setResult(new CustomFunctions.Error(CustomFunctions.ErrorCode.invalidValue, "".concat(name, " is not 'func'")));
      } else {
        var unsubscibe = _stores__WEBPACK_IMPORTED_MODULE_6__.cqlStateStore.subscribe(function (data) {
          if (data && (!name || (data === null || data === void 0 ? void 0 : data.id) === name)) {
            invocation.setResult((0,_submit__WEBPACK_IMPORTED_MODULE_7__.runCmd)(cmd, [data, parameters]));
          }
        });
        invocation.onCanceled = function () {
          return unsubscibe();
        };
      }
    } else {
      invocation.setResult(new CustomFunctions.Error(CustomFunctions.ErrorCode.invalidValue, "'".concat(func, "' not found!")));
    }
  } catch (ex) {
    console.error(ex);
    invocation.setResult(new CustomFunctions.Error(CustomFunctions.ErrorCode.invalidValue, ex.message));
  }
}

/**
 * Call a Function on CSL Update
 * @customfunction
 * @helpUrl https://celin.io/xl-docs/functions/oncsl.html
 * @param {string} name
 * @param {string} func
 * @param {any[][][]} parameters
 * @param {CustomFunctions.StreamingInvocation<any[][]>} invocation Function Return
 */
function oncsl(name, func, parameters, invocation) {
  var last = {};
  try {
    var cmd = (0,svelte_store__WEBPACK_IMPORTED_MODULE_4__.get)(_stores__WEBPACK_IMPORTED_MODULE_6__.cmdStore).find(function (c) {
      return c.id === func;
    });
    if (cmd) {
      if (cmd.type != _types__WEBPACK_IMPORTED_MODULE_5__.CommandType.func) {
        invocation.setResult(new CustomFunctions.Error(CustomFunctions.ErrorCode.invalidValue, "".concat(name, " is not 'func'")));
      } else {
        var unsubscibe1 = _stores__WEBPACK_IMPORTED_MODULE_6__.cslStateStore.subscribe(function (data) {
          if (data && (!name || data.id === name)) {
            last = _objectSpread(_objectSpread({}, last), data);
            invocation.setResult((0,_submit__WEBPACK_IMPORTED_MODULE_7__.runCmd)(cmd, [data, parameters]));
          }
        });
        var unsubscibe2 = _stores__WEBPACK_IMPORTED_MODULE_6__.cslResponseStateStore.subscribe(function (data) {
          if (!data || data.id === name) {
            last = _objectSpread(_objectSpread({}, last), data);
            invocation.setResult((0,_submit__WEBPACK_IMPORTED_MODULE_7__.runCmd)(cmd, [data, parameters]));
          }
        });
        invocation.onCanceled = function () {
          unsubscibe1();
          unsubscibe2();
        };
      }
    } else {
      invocation.setResult(new CustomFunctions.Error(CustomFunctions.ErrorCode.invalidValue, "'".concat(func, "' not found!")));
    }
  } catch (ex) {
    console.error(ex);
    invocation.setResult(new CustomFunctions.Error(CustomFunctions.ErrorCode.invalidValue, ex.message));
  }
}

/**
 * Stream a Function
 * @customfunction
 * @helpUrl https://celin.io/xl-docs/functions/callstream.html
 * @param {string} name
 * @param {any[][][]} parameters
 * @param {CustomFunctions.StreamingInvocation<any[][]>} invocation Function Return
 */
function callstream(name, params, invocation) {
  try {
    var fn = (0,svelte_store__WEBPACK_IMPORTED_MODULE_4__.get)(_stores__WEBPACK_IMPORTED_MODULE_6__.cmdStore).find(function (c) {
      return c.id === name;
    });
    if (fn) {
      if (fn.type === _types__WEBPACK_IMPORTED_MODULE_5__.CommandType.func) {
        (0,_submit__WEBPACK_IMPORTED_MODULE_7__.runCmd)(fn, [null, params, invocation]);
      } else {
        invocation.setResult(new CustomFunctions.Error(CustomFunctions.ErrorCode.invalidValue, "".concat(name, " is not 'func'")));
      }
    } else {
      invocation.setResult(new CustomFunctions.Error(CustomFunctions.ErrorCode.notAvailable, "".concat(name, " not found!")));
    }
  } catch (ex) {
    invocation.setResult(new CustomFunctions.Error(CustomFunctions.ErrorCode.invalidValue, ex.message));
  }
}

/**
 * Volatile Call a Function
 * @customfunction
 * @volatile
 * @helpUrl https://celin.io/xl-docs/functions/callvolatile.html
 * @param {string} name
 * @param {any[][][]} parameters
 * @returns {any[][]}
 */
function callvolatile(name, params) {
  try {
    var fn = (0,svelte_store__WEBPACK_IMPORTED_MODULE_4__.get)(_stores__WEBPACK_IMPORTED_MODULE_6__.cmdStore).find(function (c) {
      return c.id === name;
    });
    if (fn) {
      if (fn.type === _types__WEBPACK_IMPORTED_MODULE_5__.CommandType.func) {
        return (0,_submit__WEBPACK_IMPORTED_MODULE_7__.runCmd)(fn, [null, params]);
      } else {
        return new CustomFunctions.Error(CustomFunctions.ErrorCode.invalidValue, "".concat(name, " is not 'func'"));
      }
    } else {
      return new CustomFunctions.Error(CustomFunctions.ErrorCode.invalidValue, "".concat(name, " not found!"));
    }
  } catch (ex) {
    console.error(ex);
    return new CustomFunctions.Error(CustomFunctions.ErrorCode.invalidValue, ex.message);
  }
}

/**
 * Call a Function
 * @customfunction
 * @helpUrl https://celin.io/xl-docs/functions/call.html
 * @param {string} name
 * @param {any[][][]} parameters
 * @returns {any[][]}
 */
function call(name, params) {
  try {
    var fn = (0,svelte_store__WEBPACK_IMPORTED_MODULE_4__.get)(_stores__WEBPACK_IMPORTED_MODULE_6__.cmdStore).find(function (c) {
      return c.id === name;
    });
    if (fn) {
      if (fn.type === _types__WEBPACK_IMPORTED_MODULE_5__.CommandType.func) {
        return (0,_submit__WEBPACK_IMPORTED_MODULE_7__.runCmd)(fn, [null, params]);
      } else {
        return new CustomFunctions.Error(CustomFunctions.ErrorCode.invalidValue, "".concat(name, " is not 'func'"));
      }
    } else {
      return new CustomFunctions.Error(CustomFunctions.ErrorCode.invalidValue, "".concat(name, " not found!"));
    }
  } catch (ex) {
    console.error(ex);
    return new CustomFunctions.Error(CustomFunctions.ErrorCode.invalidValue, ex.message);
  }
}

/**
 * Menu event
 * @customfunction
 * @helpUrl https://celin.io/xl-docs/functions/onmenu.html
 * @param {string} menu Menu name
 * @param {any} option Menu option
 * @param {number[]} columns Columns to display
 * @param {CustomFunctions.StreamingInvocation<any[][]>} invocation Attribute value
 */
function onmenu(menu, option, columns, invocation) {
  invocation.setResult(new CustomFunctions.Error(CustomFunctions.ErrorCode.notAvailable));
  var unsubscibe = _stores__WEBPACK_IMPORTED_MODULE_6__.tableMenuStore.subscribe( /*#__PURE__*/function () {
    var _ref = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee2(mnu) {
      return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            if (!(mnu && mnu.id === menu && (!option || option === mnu.option))) {
              _context2.next = 4;
              break;
            }
            _context2.next = 4;
            return Excel.run( /*#__PURE__*/function () {
              var _ref2 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee(ctx) {
                var table, range, row, values;
                return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee$(_context) {
                  while (1) switch (_context.prev = _context.next) {
                    case 0:
                      table = ctx.workbook.tables.getItem(mnu.id);
                      range = table.rows.getItemAt(mnu.index);
                      range.load();
                      _context.next = 5;
                      return ctx.sync();
                    case 5:
                      if (range.values.length > 0) {
                        row = range.values[0];
                        values = columns.map(function (c) {
                          return row[Math.max(0, Math.min(row.length, c))];
                        });
                        invocation.setResult([values.length > 0 ? values : [""]]);
                      }
                    case 6:
                    case "end":
                      return _context.stop();
                  }
                }, _callee);
              }));
              return function (_x2) {
                return _ref2.apply(this, arguments);
              };
            }());
          case 4:
            _context2.next = 10;
            break;
          case 6:
            _context2.prev = 6;
            _context2.t0 = _context2["catch"](0);
            console.error(_context2.t0);
            invocation.setResult(new CustomFunctions.Error(CustomFunctions.ErrorCode.invalidValue, _context2.t0.message));
          case 10:
          case "end":
            return _context2.stop();
        }
      }, _callee2, null, [[0, 6]]);
    }));
    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }());
  invocation.onCanceled = function () {
    unsubscibe();
  };
}

/**
 * Regular Expression function
 * @customfunction
 * @helpUrl https://celin.io/xl-docs/functions/regex.html
 * @param {string} match
 * @param {string} pattern
 * @returns pattern match.
 */
function regex(match, pattern) {
  var rgx = new RegExp(pattern);
  var m = rgx.exec(match);
  if (m && m.length > 1) {
    return m[1];
  }
  return "";
}

/**
. * Run a named Script
 * @customfunction
 * @helpUrl https://celin.io/xl-docs/functions/csl.html
 * @param {string} name Name
 * @param {any[][][]} trigger Trigger
 * @param {CustomFunctions.StreamingInvocation<string>} invocation Results
 */
function csl(_x3, _x4, _x5) {
  return _csl.apply(this, arguments);
}
/**
 * Run a named Query
 * @customfunction
 * @helpUrl https://celin.io/xl-docs/functions/cql.html
 * @param {string} name CQL Name
 * @param {any[][][]} trigger Trigger
 * @param {CustomFunctions.StreamingInvocation<string>} invocation Results
 */
function _csl() {
  _csl = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee4(name, _, invocation) {
    var dt, _csl2, timer;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          try {
            dt = (0,svelte_store__WEBPACK_IMPORTED_MODULE_4__.get)(_stores__WEBPACK_IMPORTED_MODULE_6__.cslStore);
            _csl2 = dt.find(function (d) {
              return (d === null || d === void 0 ? void 0 : d.id) === name;
            });
            if (_csl2) {
              clearTimeout(timer);
              timer = setTimeout( /*#__PURE__*/_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee3() {
                var _csl2$template;
                return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee3$(_context3) {
                  while (1) switch (_context3.prev = _context3.next) {
                    case 0:
                      if (_csl2.busy) {
                        invocation.setResult("");
                      }
                      _context3.next = 3;
                      return (0,_submit__WEBPACK_IMPORTED_MODULE_7__.submitScript)((_csl2$template = _csl2.template) !== null && _csl2$template !== void 0 ? _csl2$template : _csl2.source);
                    case 3:
                    case "end":
                      return _context3.stop();
                  }
                }, _callee3);
              })), 600);
            } else {
              invocation.setResult(new CustomFunctions.Error(CustomFunctions.ErrorCode.invalidValue, "\"".concat(name, "\" not found!")));
            }
          } catch (ex) {
            console.error(ex);
            invocation.setResult(new CustomFunctions.Error(CustomFunctions.ErrorCode.invalidValue, ex.message));
          }
        case 1:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return _csl.apply(this, arguments);
}
function cql(_x6, _x7, _x8) {
  return _cql.apply(this, arguments);
}
/**
 * Get CQL State
 * @customfunction
 * @helpUrl https://celin.io/xl-docs/functions/cqlstate.html
 * @param {string} name CQL Name
 * @param {string} attribute Attribute
 * @param {any} default Default Attribute Value
 * @param {CustomFunctions.StreamingInvocation<any>} invocation Attribute value
 * @returns The request attribute
 */
function _cql() {
  _cql = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee6(name, _, invocation) {
    var dt, _data2;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee6$(_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          try {
            dt = (0,svelte_store__WEBPACK_IMPORTED_MODULE_4__.get)(_stores__WEBPACK_IMPORTED_MODULE_6__.cqlStore);
            _data2 = dt.find(function (d) {
              return (d === null || d === void 0 ? void 0 : d.id) === name;
            });
            if (_data2) {
              clearTimeout(_data2.timer);
              _data2.timer = setTimeout( /*#__PURE__*/_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee5() {
                var _data2$template;
                return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee5$(_context5) {
                  while (1) switch (_context5.prev = _context5.next) {
                    case 0:
                      invocation.setResult("");
                      _context5.next = 3;
                      return (0,_submit__WEBPACK_IMPORTED_MODULE_7__.submitQuery)((_data2$template = _data2.template) !== null && _data2$template !== void 0 ? _data2$template : _data2.query);
                    case 3:
                    case "end":
                      return _context5.stop();
                  }
                }, _callee5);
              })), 1000);
            } else {
              invocation.setResult(new CustomFunctions.Error(CustomFunctions.ErrorCode.invalidValue, "\"".concat(name, "\" not found!")));
            }
          } catch (ex) {
            console.error(ex);
            invocation.setResult(new CustomFunctions.Error(CustomFunctions.ErrorCode.invalidValue, ex.message));
          }
        case 1:
        case "end":
          return _context6.stop();
      }
    }, _callee6);
  }));
  return _cql.apply(this, arguments);
}
function cqlstate(_x9, _x10, _x11, _x12) {
  return _cqlstate.apply(this, arguments);
}
/**
 * Get CSL State
 * @customfunction
 * @helpUrl https://celin.io/xl-docs/functions/cslstate.html
 * @param {string} name CSL Name
 * @param {string} attribute Attribute
 * @param {any} default Default Attribute Value
 * @param {CustomFunctions.StreamingInvocation<any>} invocation Attribute value
 * @returns The request attribute
 */
function _cqlstate() {
  _cqlstate = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee7(name, attribute, _default, invocation) {
    var unsubscibe;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee7$(_context7) {
      while (1) switch (_context7.prev = _context7.next) {
        case 0:
          invocation.setResult(_default);
          unsubscibe = _stores__WEBPACK_IMPORTED_MODULE_6__.cqlStateStore.subscribe(function (data) {
            if (data && (!name || data.id === name)) {
              try {
                var _fn3;
                var fn = Function("try{const state=arguments[0];return ".concat(attribute, ";}catch(ex){return ex.message;}"));
                var state = (_fn3 = fn(data)) !== null && _fn3 !== void 0 ? _fn3 : _default;
                invocation.setResult(state);
              } catch (ex) {
                console.error(ex);
                invocation.setResult(new CustomFunctions.Error(CustomFunctions.ErrorCode.invalidValue, ex.message));
              }
            }
          });
          invocation.onCanceled = function () {
            unsubscibe();
          };
        case 3:
        case "end":
          return _context7.stop();
      }
    }, _callee7);
  }));
  return _cqlstate.apply(this, arguments);
}
function cslstate(name, attribute, _default, invocation) {
  invocation.setResult(_default);
  var last = {};
  try {
    var fn = Function("try{const state=arguments[0];return ".concat(attribute, ";}catch(ex){return ex.message;}"));
    var unsubscibe1 = _stores__WEBPACK_IMPORTED_MODULE_6__.cslStateStore.subscribe(function (data) {
      if (data && (!name || data.id === name)) {
        var _fn;
        last = _objectSpread(_objectSpread({}, last), data);
        var state = (_fn = fn(last)) !== null && _fn !== void 0 ? _fn : _default;
        invocation.setResult(state);
      }
    });
    var unsubscibe2 = _stores__WEBPACK_IMPORTED_MODULE_6__.cslResponseStateStore.subscribe(function (data) {
      if (data && (!name || data.id === name)) {
        var _fn2;
        last = _objectSpread(_objectSpread({}, last), data);
        var state = (_fn2 = fn(last)) !== null && _fn2 !== void 0 ? _fn2 : _default;
        invocation.setResult(state);
      }
    });
    invocation.onCanceled = function () {
      unsubscibe1();
      unsubscibe2();
    };
  } catch (ex) {
    console.error(ex);
    invocation.setResult(new CustomFunctions.Error(CustomFunctions.ErrorCode.invalidValue, ex.message));
  }
}
var FMT = /{(\d+)}/g;
var lastUpdate = new Map();

/**
 * Get named data results
 * @customfunction
 * @helpUrl https://celin.io/xl-docs/functions/data.html
 * @param {string} name Data Name
 * @param {number} from From Row
 * @param {number} to To Row
 * @param {any[]} [format] Format
 * @param {CustomFunctions.StreamingInvocation<any[][]>} invocation Custom function invocation
 */
function data(name, from, to, format, invocation) {
  var unsubscibe = _stores__WEBPACK_IMPORTED_MODULE_6__.cqlStore.subscribe(function (current) {
    try {
      var _data = current.find(function (d) {
        return (d === null || d === void 0 ? void 0 : d.id) === name;
      });
      if (_data) {
        if (_data.busy) {
          lastUpdate.set(name, 0);
          invocation.setResult([["#BUSY"]]);
        } else {
          var submitted = new Date(_data.submitted);
          var last = lastUpdate.get(name);
          if (submitted.getTime() < last) {
            return;
          }
          lastUpdate.set(name, Date.now());
          (0,_persist__WEBPACK_IMPORTED_MODULE_8__.getItem)(_data.id).then(function (allrows) {
            var _allrows$transposed;
            var rows = from < 0 ? allrows.results : allrows.results.slice(from, Math.min(Math.max(to, -1), ((_allrows$transposed = allrows.transposed) !== null && _allrows$transposed !== void 0 ? _allrows$transposed : allrows.results).length));
            if (rows.length > 0) {
              if (format.length > 0) {
                var frows = rows.map(function (r) {
                  return format.map(function (c) {
                    if (typeof c === "string") {
                      var fmts = c.matchAll(FMT);
                      if (fmts) {
                        var fs = _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(fmts).reduce(function (f, fmt) {
                          return f.replace(fmt[0], r[fmt[1]]);
                        }, c);
                        return fs;
                      }
                      return c;
                    }
                    return r[c];
                  });
                });
                invocation.setResult(frows);
              } else {
                invocation.setResult(rows);
              }
            } else {
              invocation.setResult(new CustomFunctions.Error(CustomFunctions.ErrorCode.notAvailable));
            }
          });
        }
      } else {
        invocation.setResult(new CustomFunctions.Error(CustomFunctions.ErrorCode.invalidValue, "\"".concat(name, "\" not found!")));
      }
    } catch (ex) {
      console.error(ex);
    }
  });
  invocation.onCanceled = function () {
    unsubscibe();
    lastUpdate["delete"](name);
  };
}

/**
 * Incremental ticker function
 * @customfunction
 * @helpUrl https://celin.io/xl-docs/functions/ticker.html
 * @param {number} delay Delay seconds
 * @param {CustomFunctions.StreamingInvocation<number>} invocation
 */
function ticker(delay, invocation) {
  var counter = 0;
  var timer = setInterval(function () {
    invocation.setResult(++counter);
  }, delay * 1000);
  invocation.onCanceled = function () {
    clearTimeout(timer);
  };
}
CustomFunctions.associate("ONCQL", oncql);
CustomFunctions.associate("ONCSL", oncsl);
CustomFunctions.associate("CALLSTREAM", callstream);
CustomFunctions.associate("CALLVOLATILE", callvolatile);
CustomFunctions.associate("CALL", call);
CustomFunctions.associate("ONMENU", onmenu);
CustomFunctions.associate("REGEX", regex);
CustomFunctions.associate("CSL", csl);
CustomFunctions.associate("CQL", cql);
CustomFunctions.associate("CQLSTATE", cqlstate);
CustomFunctions.associate("CSLSTATE", cslstate);
CustomFunctions.associate("DATA", data);
CustomFunctions.associate("TICKER", ticker);

/***/ }),

/***/ "./JS/loadSubjectDemo.ts":
/*!*******************************!*\
  !*** ./JS/loadSubjectDemo.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stores */ "./JS/stores.ts");

var loadSubjectDemo = function loadSubjectDemo(subject) {
  return new Promise(function (resolve) {
    // subjectDemoStore.set(null);
    var unsubscribe = _stores__WEBPACK_IMPORTED_MODULE_0__.subjectDemoStore.subscribe(function (value) {
      if (value) {
        resolve(value);
        unsubscribe();
      }
    });
    __webpack_require__.g.blazorLib.invokeMethodAsync('SubjectDemoLookupRequest', subject);
  });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (loadSubjectDemo);

/***/ }),

/***/ "./JS/loadSubjects.ts":
/*!****************************!*\
  !*** ./JS/loadSubjects.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stores */ "./JS/stores.ts");



var loadSubjects = function loadSubjects(filter) {
  return new Promise( /*#__PURE__*/function () {
    var _ref = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee(resolve) {
      var unsubscribe;
      return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (!((filter === null || filter === void 0 ? void 0 : filter.trim().length) > 0)) {
              _context.next = 7;
              break;
            }
            _stores__WEBPACK_IMPORTED_MODULE_2__.subjectStore.set(null);
            unsubscribe = _stores__WEBPACK_IMPORTED_MODULE_2__.subjectStore.subscribe(function (value) {
              if (value) {
                resolve(value);
                unsubscribe();
              }
            });
            _context.next = 5;
            return __webpack_require__.g.blazorLib.invokeMethodAsync('SubjectLookupRequest', filter);
          case 5:
            _context.next = 8;
            break;
          case 7:
            resolve([]);
          case 8:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }());
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (loadSubjects);

/***/ }),

/***/ "./JS/menus.ts":
/*!*********************!*\
  !*** ./JS/menus.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MENU_KEY: () => (/* binding */ MENU_KEY),
/* harmony export */   createMenu: () => (/* binding */ createMenu),
/* harmony export */   initMenus: () => (/* binding */ initMenus),
/* harmony export */   onMenuChanged: () => (/* binding */ onMenuChanged)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _persist__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./persist */ "./JS/persist.ts");
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stores */ "./JS/stores.ts");





var MENU_KEY = "menus";
function onMenuChanged(_x) {
  return _onMenuChanged.apply(this, arguments);
}
function _onMenuChanged() {
  _onMenuChanged = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default().mark(function _callee2(eventArgs) {
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          if (!(!eventArgs || eventArgs.details.valueTypeAfter === "Empty")) {
            _context2.next = 2;
            break;
          }
          return _context2.abrupt("return");
        case 2:
          _context2.next = 4;
          return Excel.run( /*#__PURE__*/function () {
            var _ref = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default().mark(function _callee(context) {
              var table, body, range, index, col, row, ev;
              return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default().wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    table = context.workbook.tables.getItem(eventArgs.tableId);
                    table.load(["name"]);
                    body = table.getDataBodyRange();
                    body.load(["rowIndex", "columnIndex", "columnCount"]);
                    range = eventArgs.getRange(context);
                    range.load();
                    _context.next = 8;
                    return context.sync();
                  case 8:
                    index = range.rowIndex - body.rowIndex;
                    col = range.columnIndex - body.columnIndex;
                    if (!(col === 0 && index !== -1)) {
                      _context.next = 18;
                      break;
                    }
                    range.clear("Contents");
                    row = range.getResizedRange(0, body.columnCount - 1);
                    row.load("values");
                    _context.next = 16;
                    return context.sync();
                  case 16:
                    ev = {
                      id: table.name,
                      index: index,
                      option: eventArgs.details.valueAfter,
                      row: row.values[0]
                    };
                    _stores__WEBPACK_IMPORTED_MODULE_4__.tableMenuStore.set(ev);
                  case 18:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }));
            return function (_x2) {
              return _ref.apply(this, arguments);
            };
          }());
        case 4:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _onMenuChanged.apply(this, arguments);
}
function initMenus() {
  return _initMenus.apply(this, arguments);
}
function _initMenus() {
  _initMenus = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default().mark(function _callee4() {
    var _yield$getItem;
    var menus, valid, _loop, i;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default().wrap(function _callee4$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          onMenuChanged(null);
          _context5.next = 3;
          return (0,_persist__WEBPACK_IMPORTED_MODULE_3__.getItem)(MENU_KEY);
        case 3:
          _context5.t1 = _yield$getItem = _context5.sent;
          _context5.t0 = _context5.t1 !== null;
          if (!_context5.t0) {
            _context5.next = 7;
            break;
          }
          _context5.t0 = _yield$getItem !== void 0;
        case 7:
          if (!_context5.t0) {
            _context5.next = 11;
            break;
          }
          _context5.t2 = _yield$getItem;
          _context5.next = 12;
          break;
        case 11:
          _context5.t2 = [];
        case 12:
          menus = _context5.t2;
          valid = [];
          _loop = /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default().mark(function _loop(i) {
            var exist;
            return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default().wrap(function _loop$(_context4) {
              while (1) switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return Excel.run( /*#__PURE__*/function () {
                    var _ref2 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default().mark(function _callee3(context) {
                      var wb, table;
                      return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default().wrap(function _callee3$(_context3) {
                        while (1) switch (_context3.prev = _context3.next) {
                          case 0:
                            wb = context.workbook;
                            table = wb.tables.getItemOrNullObject(menus[i]);
                            _context3.next = 4;
                            return context.sync();
                          case 4:
                            if (table.isNullObject) {
                              _context3.next = 9;
                              break;
                            }
                            table.onChanged.add(onMenuChanged);
                            _context3.next = 8;
                            return context.sync();
                          case 8:
                            return _context3.abrupt("return", true);
                          case 9:
                            return _context3.abrupt("return", false);
                          case 10:
                          case "end":
                            return _context3.stop();
                        }
                      }, _callee3);
                    }));
                    return function (_x3) {
                      return _ref2.apply(this, arguments);
                    };
                  }());
                case 2:
                  exist = _context4.sent;
                  if (exist) valid = [].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(valid), [menus[i]]);
                case 4:
                case "end":
                  return _context4.stop();
              }
            }, _loop);
          });
          i = 0;
        case 16:
          if (!(i < menus.length)) {
            _context5.next = 21;
            break;
          }
          return _context5.delegateYield(_loop(i), "t3", 18);
        case 18:
          i++;
          _context5.next = 16;
          break;
        case 21:
          _context5.next = 23;
          return (0,_persist__WEBPACK_IMPORTED_MODULE_3__.setItem)(MENU_KEY, valid);
        case 23:
        case "end":
          return _context5.stop();
      }
    }, _callee4);
  }));
  return _initMenus.apply(this, arguments);
}
function createMenu() {
  return _createMenu.apply(this, arguments);
}
function _createMenu() {
  _createMenu = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default().mark(function _callee6() {
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default().wrap(function _callee6$(_context7) {
      while (1) switch (_context7.prev = _context7.next) {
        case 0:
          _context7.prev = 0;
          _context7.next = 3;
          return Excel.run( /*#__PURE__*/function () {
            var _ref3 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default().mark(function _callee5(context) {
              var _yield$getItem2;
              var sheet, cell, range, table, header, fmt, menus;
              return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default().wrap(function _callee5$(_context6) {
                while (1) switch (_context6.prev = _context6.next) {
                  case 0:
                    // Create table
                    sheet = context.workbook.worksheets.getActiveWorksheet();
                    cell = context.workbook.getActiveCell();
                    range = cell.getResizedRange(0, 1);
                    table = sheet.tables.add(range, false);
                    header = table.getHeaderRowRange();
                    header.values = [["-", "Menu"]];
                    table.showBandedColumns = false;
                    table.showBandedRows = false;
                    table.showFilterButton = false;
                    // table.showHeaders = false;
                    table.showTotals = false;
                    table.style = "TableStyleDark6";
                    fmt = table.columns.getItemAt(0).getDataBodyRange().format;
                    fmt.horizontalAlignment = "Center";
                    table.onChanged.add(onMenuChanged);
                    _context6.next = 16;
                    return context.sync();
                  case 16:
                    _context6.next = 18;
                    return (0,_persist__WEBPACK_IMPORTED_MODULE_3__.getItem)(MENU_KEY);
                  case 18:
                    _context6.t1 = _yield$getItem2 = _context6.sent;
                    _context6.t0 = _context6.t1 !== null;
                    if (!_context6.t0) {
                      _context6.next = 22;
                      break;
                    }
                    _context6.t0 = _yield$getItem2 !== void 0;
                  case 22:
                    if (!_context6.t0) {
                      _context6.next = 26;
                      break;
                    }
                    _context6.t2 = _yield$getItem2;
                    _context6.next = 27;
                    break;
                  case 26:
                    _context6.t2 = [];
                  case 27:
                    menus = _context6.t2;
                    _context6.next = 30;
                    return (0,_persist__WEBPACK_IMPORTED_MODULE_3__.setItem)(MENU_KEY, [].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(menus), [table.id]));
                  case 30:
                  case "end":
                    return _context6.stop();
                }
              }, _callee5);
            }));
            return function (_x4) {
              return _ref3.apply(this, arguments);
            };
          }());
        case 3:
          _context7.next = 8;
          break;
        case 5:
          _context7.prev = 5;
          _context7.t0 = _context7["catch"](0);
          _stores__WEBPACK_IMPORTED_MODULE_4__.stateStore.error("Failed to create Menu", _context7.t0, null);
        case 8:
        case "end":
          return _context7.stop();
      }
    }, _callee6, null, [[0, 5]]);
  }));
  return _createMenu.apply(this, arguments);
}

/***/ }),

/***/ "./JS/persist.ts":
/*!***********************!*\
  !*** ./JS/persist.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getItem: () => (/* binding */ getItem),
/* harmony export */   isExcel: () => (/* binding */ isExcel),
/* harmony export */   listSettings: () => (/* binding */ listSettings),
/* harmony export */   removeItem: () => (/* binding */ removeItem),
/* harmony export */   setItem: () => (/* binding */ setItem)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var localforage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! localforage */ "./node_modules/localforage/dist/localforage.js");
/* harmony import */ var localforage__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(localforage__WEBPACK_IMPORTED_MODULE_2__);




/* global */

__webpack_require__.g.blazorLib = undefined;
var isExcel = new Promise( /*#__PURE__*/function () {
  var _ref = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee(resolve) {
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return Office.onReady(function (info) {
            var xl = info.host === Office.HostType.Excel;
            resolve(xl);
            /*
            if (xl) {
              listSettings();
              await initMenus();
            }*/
          });
        case 2:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function (_x) {
    return _ref.apply(this, arguments);
  };
}());
function listSettings() {
  return Excel.run( /*#__PURE__*/function () {
    var _ref2 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee2(context) {
      var settings;
      return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            settings = context.workbook.settings;
            settings.load();
            _context2.next = 4;
            return context.sync();
          case 4:
            console.log(settings.items);
          case 5:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function (_x2) {
      return _ref2.apply(this, arguments);
    };
  }());
}
function getItem(_x3) {
  return _getItem.apply(this, arguments);
}
function _getItem() {
  _getItem = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee4(key) {
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return isExcel;
        case 2:
          if (!_context4.sent) {
            _context4.next = 6;
            break;
          }
          _context4.t0 = Excel.run( /*#__PURE__*/function () {
            var _ref3 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee3(context) {
              var item;
              return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee3$(_context3) {
                while (1) switch (_context3.prev = _context3.next) {
                  case 0:
                    item = context.workbook.settings.getItem(key);
                    _context3.prev = 1;
                    item.load("value");
                    _context3.next = 5;
                    return context.sync();
                  case 5:
                    _context3.next = 10;
                    break;
                  case 7:
                    _context3.prev = 7;
                    _context3.t0 = _context3["catch"](1);
                    return _context3.abrupt("return", null);
                  case 10:
                    return _context3.abrupt("return", item.value);
                  case 11:
                  case "end":
                    return _context3.stop();
                }
              }, _callee3, null, [[1, 7]]);
            }));
            return function (_x7) {
              return _ref3.apply(this, arguments);
            };
          }());
          _context4.next = 7;
          break;
        case 6:
          _context4.t0 = localforage__WEBPACK_IMPORTED_MODULE_2__.getItem(key);
        case 7:
          return _context4.abrupt("return", _context4.t0);
        case 8:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return _getItem.apply(this, arguments);
}
function setItem(_x4, _x5) {
  return _setItem.apply(this, arguments);
}
function _setItem() {
  _setItem = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee6(key, value) {
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee6$(_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          _context6.next = 2;
          return isExcel;
        case 2:
          if (!_context6.sent) {
            _context6.next = 6;
            break;
          }
          _context6.t0 = Excel.run( /*#__PURE__*/function () {
            var _ref4 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee5(context) {
              return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee5$(_context5) {
                while (1) switch (_context5.prev = _context5.next) {
                  case 0:
                    context.workbook.settings.add(key, value);
                    _context5.next = 3;
                    return context.sync();
                  case 3:
                  case "end":
                    return _context5.stop();
                }
              }, _callee5);
            }));
            return function (_x8) {
              return _ref4.apply(this, arguments);
            };
          }());
          _context6.next = 7;
          break;
        case 6:
          _context6.t0 = localforage__WEBPACK_IMPORTED_MODULE_2__.setItem(key, value);
        case 7:
          return _context6.abrupt("return", _context6.t0);
        case 8:
        case "end":
          return _context6.stop();
      }
    }, _callee6);
  }));
  return _setItem.apply(this, arguments);
}
function removeItem(_x6) {
  return _removeItem.apply(this, arguments);
}
function _removeItem() {
  _removeItem = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee8(key) {
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee8$(_context8) {
      while (1) switch (_context8.prev = _context8.next) {
        case 0:
          _context8.next = 2;
          return isExcel;
        case 2:
          if (!_context8.sent) {
            _context8.next = 6;
            break;
          }
          _context8.t0 = Excel.run( /*#__PURE__*/function () {
            var _ref5 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee7(context) {
              var item;
              return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee7$(_context7) {
                while (1) switch (_context7.prev = _context7.next) {
                  case 0:
                    item = context.workbook.settings.getItem(key);
                    item["delete"]();
                    _context7.next = 4;
                    return context.sync();
                  case 4:
                  case "end":
                    return _context7.stop();
                }
              }, _callee7);
            }));
            return function (_x9) {
              return _ref5.apply(this, arguments);
            };
          }());
          _context8.next = 7;
          break;
        case 6:
          _context8.t0 = localforage__WEBPACK_IMPORTED_MODULE_2__.removeItem(key);
        case 7:
          return _context8.abrupt("return", _context8.t0);
        case 8:
        case "end":
          return _context8.stop();
      }
    }, _callee8);
  }));
  return _removeItem.apply(this, arguments);
}

/***/ }),

/***/ "./JS/selected.ts":
/*!************************!*\
  !*** ./JS/selected.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   selectedCode: () => (/* binding */ selectedCode)
/* harmony export */ });
var selectedCode = function selectedCode(code, start, end) {
  if (!code || code.length === 0) return {
    before: "",
    snippet: ""
  };
  var left = code.slice(0, start);
  var right = code.slice(start);
  var ndx = left.lastIndexOf("\n\n");
  var from = start === end ? ndx === -1 ? 0 : ndx + 2 : start;
  var to = start === end ? right.search(/^\n/m) : end - start;
  var snippet = (left.slice(from) + right.slice(0, to)).trimEnd();
  var before = left.slice(0, from).replace(/./g, " ");
  return {
    before: before,
    snippet: snippet
  };
};

/***/ }),

/***/ "./JS/stores.ts":
/*!**********************!*\
  !*** ./JS/stores.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cmdEditStore: () => (/* binding */ cmdEditStore),
/* harmony export */   cmdStateStore: () => (/* binding */ cmdStateStore),
/* harmony export */   cmdStore: () => (/* binding */ cmdStore),
/* harmony export */   cqlStateStore: () => (/* binding */ cqlStateStore),
/* harmony export */   cqlStore: () => (/* binding */ cqlStore),
/* harmony export */   cslProgressStore: () => (/* binding */ cslProgressStore),
/* harmony export */   cslResponseStateStore: () => (/* binding */ cslResponseStateStore),
/* harmony export */   cslResponseStore: () => (/* binding */ cslResponseStore),
/* harmony export */   cslStateStore: () => (/* binding */ cslStateStore),
/* harmony export */   cslStore: () => (/* binding */ cslStore),
/* harmony export */   optionsStore: () => (/* binding */ optionsStore),
/* harmony export */   queryStore: () => (/* binding */ queryStore),
/* harmony export */   scriptStore: () => (/* binding */ scriptStore),
/* harmony export */   serversStore: () => (/* binding */ serversStore),
/* harmony export */   stateStore: () => (/* binding */ stateStore),
/* harmony export */   subjectDemoStore: () => (/* binding */ subjectDemoStore),
/* harmony export */   subjectStore: () => (/* binding */ subjectStore),
/* harmony export */   tableMenuStore: () => (/* binding */ tableMenuStore)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var svelte_store__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! svelte/store */ "./node_modules/svelte/store/index.mjs");
/* harmony import */ var _persist__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./persist */ "./JS/persist.ts");
/* harmony import */ var _submit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./submit */ "./JS/submit.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./types */ "./JS/types.ts");


function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
//





//#region options
var initOptions = {
  includeHeader: true
};
var options = function options() {
  var _writable = (0,svelte_store__WEBPACK_IMPORTED_MODULE_2__.writable)(initOptions),
    update = _writable.update,
    subscribe = _writable.subscribe;
  return {
    update: update,
    subscribe: subscribe
  };
};
var optionsStore = options();
//#endregion

//#region state
var initFlags = {
  busy: false,
  login: false,
  server: false,
  active: false,
  notify: null,
  action: false
};
var resetState = {
  table: null,
  info: null,
  contextId: 0
};
var initState = _objectSpread(_objectSpread(_objectSpread({}, initFlags), resetState), {}, {
  selected: null
});
var lastState = initState;
var state = function state() {
  var _writable2 = (0,svelte_store__WEBPACK_IMPORTED_MODULE_2__.writable)(initState),
    set = _writable2.set,
    subscribe = _writable2.subscribe,
    update = _writable2.update;
  return {
    busy: function busy(_busy) {
      return update(function (s) {
        return _objectSpread(_objectSpread({}, s), {}, {
          busy: _busy
        });
      });
    },
    action: function action(_action) {
      return update(function (s) {
        return _objectSpread(_objectSpread({}, s), {}, {
          action: _action
        });
      });
    },
    subPrompt: function subPrompt(_subPrompt) {
      return update(function (s) {
        return _objectSpread(_objectSpread(_objectSpread({}, s), initFlags), {}, {
          subPrompt: _subPrompt,
          active: _subPrompt
        });
      });
    },
    alPrompt: function alPrompt(_alPrompt) {
      return update(function (s) {
        return _objectSpread(_objectSpread(_objectSpread({}, s), initFlags), {}, {
          alPrompt: _alPrompt,
          active: _alPrompt
        });
      });
    },
    opPrompt: function opPrompt(_opPrompt) {
      return update(function (s) {
        return _objectSpread(_objectSpread(_objectSpread({}, s), initFlags), {}, {
          opPrompt: _opPrompt,
          active: _opPrompt
        });
      });
    },
    login: function login(_login) {
      return update(function (s) {
        lastState = s;
        return _objectSpread(_objectSpread(_objectSpread({}, s), initFlags), {}, {
          login: _login,
          active: _login
        });
      });
    },
    loginMsg: function loginMsg(_loginMsg) {
      return update(function (s) {
        return _objectSpread(_objectSpread({}, s), {}, {
          loginMsg: _loginMsg
        });
      });
    },
    server: function server(_server) {
      return update(function (s) {
        return _objectSpread(_objectSpread(_objectSpread({}, s), initFlags), {}, {
          server: _server,
          active: _server
        });
      });
    },
    context: function context(contextId) {
      return update(function (s) {
        return _objectSpread(_objectSpread({}, s), {}, {
          contextId: contextId
        });
      });
    },
    selected: function selected(data) {
      return update(function (s) {
        var selected = s.selected === data ? null : data;
        var info = s.info === null ? null : selected;
        var table = s.table == null ? null : selected;
        return _objectSpread(_objectSpread({}, s), {}, {
          selected: selected,
          info: info,
          table: table
        });
      });
    },
    info: function info() {
      return update(function (s) {
        return _objectSpread(_objectSpread(_objectSpread({}, s), resetState), {}, {
          info: s.info === null ? s.selected : null
        });
      });
    },
    table: function table() {
      return update(function (s) {
        return _objectSpread(_objectSpread(_objectSpread({}, s), resetState), {}, {
          table: s.table === null ? s.selected : null
        });
      });
    },
    last: function last() {
      return set(lastState);
    },
    error: function error(title, details, timeout) {
      return update(function (s) {
        return _objectSpread(_objectSpread({}, s), {}, {
          busy: false,
          notify: {
            title: title,
            details: details,
            type: "e",
            timeout: timeout
          }
        });
      });
    },
    clear: function clear() {
      return update(function (s) {
        return _objectSpread(_objectSpread({}, s), {}, {
          notify: null
        });
      });
    },
    subscribe: subscribe
  };
};
var stateStore = state();
//#endregion

//#region servers
var SERVER_KEY = "servers";
var servers = function servers() {
  var _writable3 = (0,svelte_store__WEBPACK_IMPORTED_MODULE_2__.writable)(null),
    _set = _writable3.set,
    subscribe = _writable3.subscribe,
    _update = _writable3.update;
  return {
    init: function init() {
      (0,_persist__WEBPACK_IMPORTED_MODULE_3__.getItem)(SERVER_KEY).then(function (s) {
        var servers = s !== null && s !== void 0 ? s : [];
        _set(servers);
        stateStore.server(servers.length === 0);
        if (servers.length > 0) {
          __webpack_require__.g.blazorLib.invokeMethodAsync("SelectContext", 0);
        }
      });
    },
    set: function set(servers) {
      (0,_persist__WEBPACK_IMPORTED_MODULE_3__.setItem)(SERVER_KEY, servers);
      _set(servers);
      stateStore.server(servers.length === 0);
      if (servers.length > 0) {
        __webpack_require__.g.blazorLib.invokeMethodAsync("SelectContext", 0);
      }
    },
    update: function update(server) {
      return _update(function (s) {
        var ndx = s.findIndex(function (e) {
          return e.id === server.id;
        });
        if (ndx !== -1) {
          s = [].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(s.slice(0, ndx)), [server], _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(s.slice(ndx + 1)));
          (0,_persist__WEBPACK_IMPORTED_MODULE_3__.setItem)(SERVER_KEY, s);
        }
        return s;
      });
    },
    subscribe: subscribe
  };
};
var serversStore = servers();
//#endregion

//#region query
var QUERY_KEY = "query";
var query = function query() {
  var _writable4 = (0,svelte_store__WEBPACK_IMPORTED_MODULE_2__.writable)(""),
    set = _writable4.set,
    subscribe = _writable4.subscribe,
    update = _writable4.update;
  (0,_persist__WEBPACK_IMPORTED_MODULE_3__.getItem)(QUERY_KEY).then(function (q) {
    set(q !== null && q !== void 0 ? q : "");
    subscribe(function (current) {
      (0,_persist__WEBPACK_IMPORTED_MODULE_3__.setItem)(QUERY_KEY, current);
    });
  });
  return {
    set: set,
    subscribe: subscribe,
    replace: function replace(text, from, to) {
      return update(function (q) {
        return "".concat(q.slice(0, from)).concat(text).concat(q.slice(to));
      });
    },
    append: function append(text) {
      return update(function (q) {
        return q = "".concat(q, "\n").concat(text);
      });
    }
  };
};
var queryStore = query();
//#endregion

//#region cqlState
var cqlState = function cqlState() {
  var _writable5 = (0,svelte_store__WEBPACK_IMPORTED_MODULE_2__.writable)(),
    set = _writable5.set,
    subscribe = _writable5.subscribe;
  return {
    set: set,
    subscribe: subscribe
  };
};
var cqlStateStore = cqlState();
//#endregion

//#region cql
var DATA_KEY = "data";
var cql = function cql() {
  var _writable6 = (0,svelte_store__WEBPACK_IMPORTED_MODULE_2__.writable)([]),
    set = _writable6.set,
    subscribe = _writable6.subscribe,
    update = _writable6.update;
  (0,_persist__WEBPACK_IMPORTED_MODULE_3__.getItem)(DATA_KEY).then(function (d) {
    set(d !== null && d !== void 0 ? d : []);
    subscribe(function (current) {
      return (0,_persist__WEBPACK_IMPORTED_MODULE_3__.setItem)(DATA_KEY, current.map(function (c) {
        return _objectSpread(_objectSpread({}, c), {}, {
          busy: false
        });
      }));
    });
  });
  return {
    edit: function edit(data) {
      return update(function (d) {
        Object.keys(data).forEach(function (k) {
          if (data[k] === null) delete data[k];
        });
        var ndx = d.findIndex(function (e) {
          return e.id === data.id;
        });
        if (ndx !== -1) {
          var e = _objectSpread(_objectSpread({}, d[ndx]), {}, {
            error: null
          }, data);
          var a = [].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(d.slice(0, ndx)), [e], _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(d.slice(ndx + 1)));
          return a;
        }
        return [data].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(d));
      });
    },
    update: function update(data) {
      Object.keys(data).forEach(function (k) {
        if (data[k] === null) delete data[k];
      });
      cqlStateStore.set(data);
    },
    "delete": function _delete(id) {
      update(function (d) {
        var ndx = d.findIndex(function (d) {
          return d.id === id;
        });
        if (ndx !== -1) return [].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(d.slice(0, ndx)), _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(d.slice(ndx + 1)));
        return d;
      });
      (0,_persist__WEBPACK_IMPORTED_MODULE_3__.removeItem)("cql-".concat(id));
    },
    get: function get(id) {
      var result;
      var unsubscibe = subscribe(function (current) {
        return result = current.find(function (e) {
          return e.id === id;
        });
      });
      unsubscibe();
      return result;
    },
    subscribe: subscribe
  };
};
var cqlStore = cql();
//#endregion

//#region cslState
var cslState = function cslState() {
  var _writable7 = (0,svelte_store__WEBPACK_IMPORTED_MODULE_2__.writable)(),
    set = _writable7.set,
    subscribe = _writable7.subscribe;
  return {
    set: set,
    subscribe: subscribe
  };
};
var cslStateStore = cslState();
//#endregion

//#region csl
var CSL_KEY = "csl";
var csl = function csl() {
  var _writable8 = (0,svelte_store__WEBPACK_IMPORTED_MODULE_2__.writable)([]),
    set = _writable8.set,
    subscribe = _writable8.subscribe,
    update = _writable8.update;
  (0,_persist__WEBPACK_IMPORTED_MODULE_3__.getItem)(CSL_KEY).then(function (d) {
    set(d !== null && d !== void 0 ? d : []);
    subscribe(function (current) {
      return (0,_persist__WEBPACK_IMPORTED_MODULE_3__.setItem)(CSL_KEY, current.map(function (c) {
        return _objectSpread(_objectSpread({}, c), {}, {
          busy: false
        });
      }));
    });
  });
  return {
    edit: function edit(data) {
      return update(function (d) {
        Object.keys(data).forEach(function (k) {
          if (data[k] === null) delete data[k];
        });
        var ndx = d.findIndex(function (e) {
          return e.id === data.id;
        });
        if (ndx !== -1) {
          var e = _objectSpread(_objectSpread({}, d[ndx]), {}, {
            error: null
          }, data);
          var a = [].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(d.slice(0, ndx)), [e], _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(d.slice(ndx + 1)));
          return a;
        }
        return [data].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(d));
      });
    },
    "delete": function _delete(id) {
      update(function (d) {
        var ndx = d.findIndex(function (d) {
          return d.id === id;
        });
        if (ndx !== -1) return [].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(d.slice(0, ndx)), _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(d.slice(ndx + 1)));
        return d;
      });
    },
    subscribe: subscribe
  };
};
var cslStore = csl();
//#endregion csl

//#region cslResponseState
var cslResponseState = function cslResponseState() {
  var _writable9 = (0,svelte_store__WEBPACK_IMPORTED_MODULE_2__.writable)(),
    set = _writable9.set,
    subscribe = _writable9.subscribe;
  return {
    set: set,
    subscribe: subscribe
  };
};
var cslResponseStateStore = cslResponseState();
//#endregion

//#region cslResponse
var cslResponse = function cslResponse() {
  var _writable10 = (0,svelte_store__WEBPACK_IMPORTED_MODULE_2__.writable)([]),
    subscribe = _writable10.subscribe,
    update = _writable10.update;
  return {
    add: function add(response) {
      return update(function (d) {
        return [response].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(d));
      });
    },
    clear: function clear(id) {
      return update(function (d) {
        return _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(d.filter(function (e) {
          return e.id !== id;
        }));
      });
    },
    subscribe: subscribe
  };
};
var cslResponseStore = cslResponse();
//#endregion

//#region cslProgress
var cslProgress = function cslProgress() {
  var _writable11 = (0,svelte_store__WEBPACK_IMPORTED_MODULE_2__.writable)([]),
    _update2 = _writable11.update,
    subscribe = _writable11.subscribe;
  return {
    clear: function clear(id) {
      _update2(function (p) {
        var ndx = p.findIndex(function (e) {
          return e.id === id;
        });
        if (ndx === -1) return p;
        var e = _objectSpread(_objectSpread({}, p[ndx]), {}, {
          row: 0,
          of: 0,
          errors: 0,
          msgs: []
        });
        return [].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(p.slice(0, ndx)), [e], _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(p.slice(ndx + 1)));
      });
    },
    update: function update(progress) {
      return _update2(function (p) {
        var ndx = p.findIndex(function (e) {
          return e.id === progress.id;
        });
        if (ndx !== -1) {
          var e = _objectSpread(_objectSpread(_objectSpread({}, p[ndx]), progress), {}, {
            msgs: [progress.msg].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(p[ndx].msgs.slice(0, Math.min(p[ndx].msgs.length, 10))))
          });
          return [].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(p.slice(0, ndx)), [e], _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(p.slice(ndx + 1)));
        }
        return [].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(p), [_objectSpread(_objectSpread({}, progress), {}, {
          msgs: [progress.msg]
        })]);
      });
    },
    subscribe: subscribe
  };
};
var cslProgressStore = cslProgress();
//#endregion

//#region subject
var subject = function subject() {
  var _writable12 = (0,svelte_store__WEBPACK_IMPORTED_MODULE_2__.writable)([]),
    set = _writable12.set,
    subscribe = _writable12.subscribe;
  return {
    set: set,
    subscribe: subscribe
  };
};
var subjectStore = subject();
//#endregion

//#region subjectDemo
var subjectDemo = function subjectDemo() {
  var _writable13 = (0,svelte_store__WEBPACK_IMPORTED_MODULE_2__.writable)(null),
    update = _writable13.update,
    subscribe = _writable13.subscribe;
  return {
    subject: function subject(_subject) {
      return update(function (s) {
        return _objectSpread(_objectSpread({}, s), {}, {
          subject: _subject
        });
      });
    },
    results: function results(rs) {
      return update(function (s) {
        return _objectSpread(_objectSpread({}, s), rs);
      });
    },
    subscribe: subscribe
  };
};
var subjectDemoStore = subjectDemo();
//#endregion

//#region script
var SCRIPT_KEY = "script";
var script = function script() {
  var _writable14 = (0,svelte_store__WEBPACK_IMPORTED_MODULE_2__.writable)(""),
    set = _writable14.set,
    subscribe = _writable14.subscribe,
    update = _writable14.update;
  (0,_persist__WEBPACK_IMPORTED_MODULE_3__.getItem)(SCRIPT_KEY).then(function (t) {
    set(t !== null && t !== void 0 ? t : "");
    subscribe(function (current) {
      return (0,_persist__WEBPACK_IMPORTED_MODULE_3__.setItem)(SCRIPT_KEY, current);
    });
  });
  return {
    set: set,
    subscribe: subscribe,
    append: function append(text) {
      return update(function (q) {
        return q = "".concat(q, "\n").concat(text);
      });
    }
  };
};
var scriptStore = script();
//#endregion

//#region cmdEdit
var CMD_EDIT_KEY = "cmd-edit";
var cmdEdit = function cmdEdit() {
  var _writable15 = (0,svelte_store__WEBPACK_IMPORTED_MODULE_2__.writable)(""),
    set = _writable15.set,
    subscribe = _writable15.subscribe,
    update = _writable15.update;
  (0,_persist__WEBPACK_IMPORTED_MODULE_3__.getItem)(CMD_EDIT_KEY).then(function (t) {
    set(t !== null && t !== void 0 ? t : "");
    subscribe(function (current) {
      return (0,_persist__WEBPACK_IMPORTED_MODULE_3__.setItem)(CMD_EDIT_KEY, current);
    });
  });
  return {
    set: set,
    subscribe: subscribe,
    append: function append(text) {
      return update(function (c) {
        return c = "".concat(c, "\n").concat(text);
      });
    }
  };
};
var cmdEditStore = cmdEdit();
//#endregion

//#region cmdState
var cmdState = function cmdState() {
  var _writable16 = (0,svelte_store__WEBPACK_IMPORTED_MODULE_2__.writable)(),
    set = _writable16.set,
    subscribe = _writable16.subscribe;
  return {
    set: set,
    subscribe: subscribe
  };
};
var cmdStateStore = cmdState();
//#endregion

//#region  cmd
var CMD_KEY = "cmd";
var cmd = function cmd() {
  var _writable17 = (0,svelte_store__WEBPACK_IMPORTED_MODULE_2__.writable)([]),
    set = _writable17.set,
    subscribe = _writable17.subscribe,
    update = _writable17.update;
  (0,_persist__WEBPACK_IMPORTED_MODULE_3__.getItem)(CMD_KEY).then(function (items) {
    var cmds = (items !== null && items !== void 0 ? items : []).map(function (c) {
      try {
        var fn = (0,_submit__WEBPACK_IMPORTED_MODULE_4__.buildCmd)(c);
        var _cmd = _objectSpread(_objectSpread({}, c), {}, {
          fn: fn
        });
        var unsub = c.unsub ? (0,_submit__WEBPACK_IMPORTED_MODULE_4__.runCmd)(_cmd, null) : null;
        return _objectSpread(_objectSpread({}, _cmd), {}, {
          unsub: unsub
        });
      } catch (ex) {
        return _objectSpread(_objectSpread({}, c), {}, {
          error: ex.toString()
        });
      }
    });
    set(cmds);
    subscribe(function (current) {
      (0,_persist__WEBPACK_IMPORTED_MODULE_3__.setItem)(CMD_KEY, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(current === null || current === void 0 ? void 0 : current.map(function (e) {
        return _objectSpread(_objectSpread({}, e), {}, {
          fn: null,
          unsub: e.type == _types__WEBPACK_IMPORTED_MODULE_5__.CommandType.func ? false : e.unsub == null ? false : true,
          error: null
        });
      })));
    });
  });
  return {
    set: set,
    subscribe: subscribe,
    edit: function edit(cmd) {
      update(function (c) {
        var ndx = c.findIndex(function (e) {
          return e.id === cmd.id;
        });
        if (ndx !== -1) {
          try {
            var _c$ndx;
            (_c$ndx = c[ndx]) === null || _c$ndx === void 0 || _c$ndx.unsub();
          } catch (_unused) {}
          var a = [].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(c.slice(0, ndx)), [cmd], _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(c.slice(ndx + 1)));
          return a;
        }
        return [].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(c), [cmd]);
      });
      cmdStateStore.set(cmd);
    },
    "delete": function _delete(id) {
      update(function (d) {
        var ndx = d.findIndex(function (d) {
          return d.id === id;
        });
        if (ndx !== -1) return [].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(d.slice(0, ndx)), _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(d.slice(ndx + 1)));
        return d;
      });
    }
  };
};
var cmdStore = cmd();
//#endregion

//#region tableMenu
var tableMenu = function tableMenu() {
  var _writable18 = (0,svelte_store__WEBPACK_IMPORTED_MODULE_2__.writable)(),
    subscribe = _writable18.subscribe,
    set = _writable18.set;
  return {
    set: set,
    subscribe: subscribe
  };
};
var tableMenuStore = tableMenu();
//#endregion

/***/ }),

/***/ "./JS/submit.ts":
/*!**********************!*\
  !*** ./JS/submit.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildCmd: () => (/* binding */ buildCmd),
/* harmony export */   parseCmd: () => (/* binding */ parseCmd),
/* harmony export */   runCmd: () => (/* binding */ runCmd),
/* harmony export */   submitQuery: () => (/* binding */ submitQuery),
/* harmony export */   submitScript: () => (/* binding */ submitScript),
/* harmony export */   toggleCmd: () => (/* binding */ toggleCmd)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var svelte_store__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! svelte/store */ "./node_modules/svelte/store/index.mjs");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./types */ "./JS/types.ts");
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./stores */ "./JS/stores.ts");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./helper */ "./JS/helper.js");
/* harmony import */ var _excel__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./excel */ "./JS/excel.ts");
/* harmony import */ var _persist__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./persist */ "./JS/persist.ts");



function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }








// const VARS = /"[^"]*"|\W@(\w+)/g;
var VARS = /"[^"]*"|(\W+|\w+)\s*@(\w+)/g;
var CMD = /^(onMenu|onCql|onCsl|func|onTable)\s+(async\s+)?(\w+)((.|\n)*?)(?=^\n)/gm;
var lib = {
  cql: function cql(id) {
    var data = (0,svelte_store__WEBPACK_IMPORTED_MODULE_4__.get)(_stores__WEBPACK_IMPORTED_MODULE_6__.cqlStore).find(function (d) {
      return (d === null || d === void 0 ? void 0 : d.id) === id;
    });
    if (data) {
      var _data$template;
      submitQuery((_data$template = data.template) !== null && _data$template !== void 0 ? _data$template : data.query);
      return true;
    }
    return false;
  },
  csl: function csl(id) {
    var csl = (0,svelte_store__WEBPACK_IMPORTED_MODULE_4__.get)(_stores__WEBPACK_IMPORTED_MODULE_6__.cslStore).find(function (d) {
      return (d === null || d === void 0 ? void 0 : d.id) === id;
    });
    if (csl) {
      var _csl$template;
      submitScript((_csl$template = csl.template) !== null && _csl$template !== void 0 ? _csl$template : csl.source, false);
    }
    return false;
  },
  set: function () {
    var _set = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee(values) {
      return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return (0,_excel__WEBPACK_IMPORTED_MODULE_8__.setValues)(values);
          case 2:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    function set(_x) {
      return _set.apply(this, arguments);
    }
    return set;
  }(),
  get: function () {
    var _get = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee2(name) {
      return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return (0,_excel__WEBPACK_IMPORTED_MODULE_8__.getValue)(name);
          case 2:
            return _context2.abrupt("return", _context2.sent);
          case 3:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    function get(_x2) {
      return _get.apply(this, arguments);
    }
    return get;
  }(),
  formula: function () {
    var _formula2 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee3(name, _formula) {
      return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return (0,_excel__WEBPACK_IMPORTED_MODULE_8__.setFormula)(name, _formula);
          case 2:
            return _context3.abrupt("return", _context3.sent);
          case 3:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    function formula(_x3, _x4) {
      return _formula2.apply(this, arguments);
    }
    return formula;
  }(),
  data: function () {
    var _data = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee4(name) {
      var d;
      return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return (0,_persist__WEBPACK_IMPORTED_MODULE_9__.getItem)("cql-".concat(name));
          case 2:
            d = _context4.sent;
            return _context4.abrupt("return", d.results);
          case 4:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    function data(_x5) {
      return _data.apply(this, arguments);
    }
    return data;
  }(),
  table: function () {
    var _table = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee14(name) {
      var id;
      return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee14$(_context14) {
        while (1) switch (_context14.prev = _context14.next) {
          case 0:
            _context14.next = 2;
            return Excel.run( /*#__PURE__*/function () {
              var _ref = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee5(ctx) {
                var table;
                return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee5$(_context5) {
                  while (1) switch (_context5.prev = _context5.next) {
                    case 0:
                      table = ctx.workbook.tables.getItem(name);
                      _context5.next = 3;
                      return ctx.sync();
                    case 3:
                      return _context5.abrupt("return", table.id);
                    case 4:
                    case "end":
                      return _context5.stop();
                  }
                }, _callee5);
              }));
              return function (_x7) {
                return _ref.apply(this, arguments);
              };
            }());
          case 2:
            id = _context14.sent;
            return _context14.abrupt("return", {
              id: id,
              col: function () {
                var _col = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee9(column) {
                  var columnValues, colObj;
                  return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee9$(_context9) {
                    while (1) switch (_context9.prev = _context9.next) {
                      case 0:
                        _context9.next = 2;
                        return Excel.run( /*#__PURE__*/function () {
                          var _ref2 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee6(ctx) {
                            var c;
                            return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee6$(_context6) {
                              while (1) switch (_context6.prev = _context6.next) {
                                case 0:
                                  c = ctx.workbook.tables.getItem(id).getDataBodyRange().getColumn(column).load("values");
                                  _context6.next = 3;
                                  return ctx.sync();
                                case 3:
                                  return _context6.abrupt("return", c.values);
                                case 4:
                                case "end":
                                  return _context6.stop();
                              }
                            }, _callee6);
                          }));
                          return function (_x9) {
                            return _ref2.apply(this, arguments);
                          };
                        }());
                      case 2:
                        columnValues = _context9.sent;
                        colObj = {
                          id: id,
                          column: column,
                          columnValues: columnValues,
                          set: function () {
                            var _set2 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee8(values, start) {
                              var updated;
                              return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee8$(_context8) {
                                while (1) switch (_context8.prev = _context8.next) {
                                  case 0:
                                    _context8.next = 2;
                                    return Excel.run( /*#__PURE__*/function () {
                                      var _ref3 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee7(ctx) {
                                        var c, v;
                                        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee7$(_context7) {
                                          while (1) switch (_context7.prev = _context7.next) {
                                            case 0:
                                              c = ctx.workbook.tables.getItem(id).getDataBodyRange().getColumn(column).load("values");
                                              _context7.next = 3;
                                              return ctx.sync();
                                            case 3:
                                              v = c.values.map(function (e, i) {
                                                return start ? i < start ? e : i - start > values.length - 1 ? e : [values[i - start]] : i > values.length - 1 ? e : [values[i]];
                                              });
                                              c.values = v;
                                              return _context7.abrupt("return", v.flat());
                                            case 6:
                                            case "end":
                                              return _context7.stop();
                                          }
                                        }, _callee7);
                                      }));
                                      return function (_x12) {
                                        return _ref3.apply(this, arguments);
                                      };
                                    }());
                                  case 2:
                                    updated = _context8.sent;
                                    return _context8.abrupt("return", _objectSpread(_objectSpread({}, colObj), {}, {
                                      columnValues: updated
                                    }));
                                  case 4:
                                  case "end":
                                    return _context8.stop();
                                }
                              }, _callee8);
                            }));
                            function set(_x10, _x11) {
                              return _set2.apply(this, arguments);
                            }
                            return set;
                          }()
                        };
                        return _context9.abrupt("return", colObj);
                      case 5:
                      case "end":
                        return _context9.stop();
                    }
                  }, _callee9);
                }));
                function col(_x8) {
                  return _col.apply(this, arguments);
                }
                return col;
              }(),
              row: function () {
                var _row = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee13(rownum) {
                  var rowValues, rowObj;
                  return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee13$(_context13) {
                    while (1) switch (_context13.prev = _context13.next) {
                      case 0:
                        _context13.next = 2;
                        return Excel.run( /*#__PURE__*/function () {
                          var _ref4 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee10(ctx) {
                            var r;
                            return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee10$(_context10) {
                              while (1) switch (_context10.prev = _context10.next) {
                                case 0:
                                  r = ctx.workbook.tables.getItem(id).getDataBodyRange().getRow(rownum).load("values");
                                  _context10.next = 3;
                                  return ctx.sync();
                                case 3:
                                  return _context10.abrupt("return", r.values);
                                case 4:
                                case "end":
                                  return _context10.stop();
                              }
                            }, _callee10);
                          }));
                          return function (_x14) {
                            return _ref4.apply(this, arguments);
                          };
                        }());
                      case 2:
                        rowValues = _context13.sent;
                        rowObj = {
                          id: id,
                          rownum: rownum,
                          rowValues: rowValues,
                          set: function () {
                            var _set3 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee12(values, start) {
                              var updated;
                              return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee12$(_context12) {
                                while (1) switch (_context12.prev = _context12.next) {
                                  case 0:
                                    _context12.next = 2;
                                    return Excel.run( /*#__PURE__*/function () {
                                      var _ref5 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee11(ctx) {
                                        var r, v;
                                        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee11$(_context11) {
                                          while (1) switch (_context11.prev = _context11.next) {
                                            case 0:
                                              r = ctx.workbook.tables.getItem(id).getDataBodyRange().getRow(rownum).load("values");
                                              _context11.next = 3;
                                              return ctx.sync();
                                            case 3:
                                              v = r.values[0].map(function (e, i) {
                                                return start ? i < start ? e : i - start > values.length - 1 ? e : values[i - start] : i > values.length - 1 ? e : values[i];
                                              });
                                              r.values = [v];
                                              return _context11.abrupt("return", v);
                                            case 6:
                                            case "end":
                                              return _context11.stop();
                                          }
                                        }, _callee11);
                                      }));
                                      return function (_x17) {
                                        return _ref5.apply(this, arguments);
                                      };
                                    }());
                                  case 2:
                                    updated = _context12.sent;
                                    return _context12.abrupt("return", _objectSpread(_objectSpread({}, rowObj), {}, {
                                      rowValues: updated
                                    }));
                                  case 4:
                                  case "end":
                                    return _context12.stop();
                                }
                              }, _callee12);
                            }));
                            function set(_x15, _x16) {
                              return _set3.apply(this, arguments);
                            }
                            return set;
                          }()
                        };
                        return _context13.abrupt("return", rowObj);
                      case 5:
                      case "end":
                        return _context13.stop();
                    }
                  }, _callee13);
                }));
                function row(_x13) {
                  return _row.apply(this, arguments);
                }
                return row;
              }()
            });
          case 4:
          case "end":
            return _context14.stop();
        }
      }, _callee14);
    }));
    function table(_x6) {
      return _table.apply(this, arguments);
    }
    return table;
  }(),
  error: function error(id, _error) {
    var cmd = (0,svelte_store__WEBPACK_IMPORTED_MODULE_4__.get)(_stores__WEBPACK_IMPORTED_MODULE_6__.cmdStore).find(function (c) {
      return c.id === id;
    });
    if (cmd) {
      _stores__WEBPACK_IMPORTED_MODULE_6__.cmdStore.edit(_objectSpread(_objectSpread({}, cmd), {}, {
        error: _error
      }));
    }
  }
};
var runCmd = function runCmd(cmd, param) {
  switch (cmd.type) {
    case _types__WEBPACK_IMPORTED_MODULE_5__.CommandType.onMenu:
      return cmd.fn(lib, _stores__WEBPACK_IMPORTED_MODULE_6__.tableMenuStore);
    case _types__WEBPACK_IMPORTED_MODULE_5__.CommandType.onCql:
      return cmd.fn(lib, _stores__WEBPACK_IMPORTED_MODULE_6__.cqlStateStore);
    case _types__WEBPACK_IMPORTED_MODULE_5__.CommandType.onCsl:
      return cmd.fn(lib, _stores__WEBPACK_IMPORTED_MODULE_6__.cslResponseStateStore);
    case _types__WEBPACK_IMPORTED_MODULE_5__.CommandType.func:
      return cmd.fn.apply(cmd, [lib].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(param !== null && param !== void 0 ? param : [])));
  }
};
var toggleCmd = /*#__PURE__*/function () {
  var _ref6 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee16(cmd) {
    var unsub, _unsub;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee16$(_context16) {
      while (1) switch (_context16.prev = _context16.next) {
        case 0:
          _context16.prev = 0;
          _context16.t0 = cmd.type;
          _context16.next = _context16.t0 === _types__WEBPACK_IMPORTED_MODULE_5__.CommandType.onTable ? 4 : 16;
          break;
        case 4:
          if (!cmd.unsub) {
            _context16.next = 10;
            break;
          }
          console.log(cmd.unsub);
          cmd.unsub.remove();
          _stores__WEBPACK_IMPORTED_MODULE_6__.cmdStore.edit(_objectSpread(_objectSpread({}, cmd), {}, {
            unsub: null,
            error: null
          }));
          _context16.next = 15;
          break;
        case 10:
          _context16.next = 12;
          return Excel.run( /*#__PURE__*/function () {
            var _ref7 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee15(ctx) {
              var tb, h;
              return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee15$(_context15) {
                while (1) switch (_context15.prev = _context15.next) {
                  case 0:
                    tb = ctx.workbook.tables.getItemOrNullObject(cmd.id);
                    _context15.next = 3;
                    return ctx.sync();
                  case 3:
                    if (tb.isNullObject) {
                      _context15.next = 6;
                      break;
                    }
                    h = tb.onChanged.add(cmd.fn);
                    return _context15.abrupt("return", h);
                  case 6:
                    return _context15.abrupt("return", null);
                  case 7:
                  case "end":
                    return _context15.stop();
                }
              }, _callee15);
            }));
            return function (_x19) {
              return _ref7.apply(this, arguments);
            };
          }());
        case 12:
          unsub = _context16.sent;
          unsub.remove();
          _stores__WEBPACK_IMPORTED_MODULE_6__.cmdStore.edit(_objectSpread(_objectSpread({}, cmd), {}, {
            unsub: unsub,
            error: null
          }));
        case 15:
          return _context16.abrupt("break", 17);
        case 16:
          if (cmd.unsub) {
            cmd.unsub();
            _stores__WEBPACK_IMPORTED_MODULE_6__.cmdStore.edit(_objectSpread(_objectSpread({}, cmd), {}, {
              unsub: null,
              error: null
            }));
          } else {
            _unsub = runCmd(cmd, null);
            _stores__WEBPACK_IMPORTED_MODULE_6__.cmdStore.edit(_objectSpread(_objectSpread({}, cmd), {}, {
              unsub: _unsub,
              error: null
            }));
          }
        case 17:
          _context16.next = 22;
          break;
        case 19:
          _context16.prev = 19;
          _context16.t1 = _context16["catch"](0);
          _stores__WEBPACK_IMPORTED_MODULE_6__.cmdStore.edit(_objectSpread(_objectSpread({}, cmd), {}, {
            error: _context16.t1.toString()
          }));
        case 22:
        case "end":
          return _context16.stop();
      }
    }, _callee16, null, [[0, 19]]);
  }));
  return function toggleCmd(_x18) {
    return _ref6.apply(this, arguments);
  };
}();
var buildCmd = function buildCmd(cmd) {
  var strict = "'use strict';";
  var isAsync = cmd.isAsync ? "async " : "";
  var slib = "const lib=arguments[0];";
  var subs = "return arguments[1].subscribe";
  var err = "catch(ex){console.error(ex);lib.error(\"".concat(cmd.id, "\",ex);return ex.message;}");
  var msg = "(msg)=>{if (msg?.id==='".concat(cmd.id, "')try{").concat(cmd.source, "}").concat(err, "}");
  var fmsg = "const msg=arguments[1];";
  var range = "const params=arguments[2];";
  var invocation = "const invocation=arguments.length>3?arguments[3]:null;";
  switch (cmd.type) {
    case _types__WEBPACK_IMPORTED_MODULE_5__.CommandType.onTable:
      return Function("".concat(strict).concat(cmd.source));
    case _types__WEBPACK_IMPORTED_MODULE_5__.CommandType.onMenu:
      return Function("".concat(strict).concat(slib).concat(subs, "(").concat(isAsync).concat(msg, ")"));
    case _types__WEBPACK_IMPORTED_MODULE_5__.CommandType.onCql:
      return Function("".concat(strict).concat(slib).concat(subs, "(").concat(isAsync).concat(msg, ")"));
    case _types__WEBPACK_IMPORTED_MODULE_5__.CommandType.onCsl:
      return Function("".concat(strict).concat(slib).concat(subs, "(").concat(isAsync).concat(msg, ")"));
    case _types__WEBPACK_IMPORTED_MODULE_5__.CommandType.func:
      return isAsync ? (0,_helper__WEBPACK_IMPORTED_MODULE_7__.AsyncFunction)("".concat(strict).concat(slib).concat(fmsg).concat(range).concat(invocation, "try{").concat(cmd.source, "}").concat(err)) : Function("".concat(strict).concat(slib).concat(fmsg).concat(range).concat(invocation, "try{").concat(cmd.source, "}").concat(err));
  }
};
var parseCmd = function parseCmd(cmd) {
  if (!cmd && !cmd.trim()) return;
  var c = null;
  try {
    var f = _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()((cmd + "\n\n").matchAll(CMD));
    if (f.length > 0) {
      c = {
        id: f[0][3],
        title: "",
        type: _types__WEBPACK_IMPORTED_MODULE_5__.CommandType[f[0][1]],
        source: f[0][4].trim(),
        isAsync: f[0][2] > "",
        fn: null,
        unsub: false,
        busy: false,
        error: null
      };
      var fn = buildCmd(c);
      c = _objectSpread(_objectSpread({}, c), {}, {
        fn: fn
      });
      // const unsub = runCmd(c, []);
      _stores__WEBPACK_IMPORTED_MODULE_6__.cmdStore.edit(_objectSpread({}, c));
    }
  } catch (ex) {
    _stores__WEBPACK_IMPORTED_MODULE_6__.stateStore.error("Command Error", ex.message, null);
  }
};
var submitScript = /*#__PURE__*/function () {
  var _ref8 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee21(sc) {
    var validateOnly,
      parsed,
      range,
      vars,
      _args21 = arguments;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee21$(_context21) {
      while (1) switch (_context21.prev = _context21.next) {
        case 0:
          validateOnly = _args21.length > 1 && _args21[1] !== undefined ? _args21[1] : false;
          if (__webpack_require__.g.ready) {
            _context21.next = 3;
            break;
          }
          return _context21.abrupt("return");
        case 3:
          if (!(!sc && !sc.trim())) {
            _context21.next = 5;
            break;
          }
          return _context21.abrupt("return");
        case 5:
          _context21.prev = 5;
          parsed = sc;
          _context21.next = 9;
          return Promise.all(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(parsed.matchAll(/"[^"]*"|.each@(\w*)/g)).map(function (e) {
            return e[1];
          }).filter(function (e, i, a) {
            return e !== undefined && a.indexOf(e) === i;
          }).sort(function (a, b) {
            return b.length - a.length;
          }).map( /*#__PURE__*/function () {
            var _ref9 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee18(name) {
              return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee18$(_context18) {
                while (1) switch (_context18.prev = _context18.next) {
                  case 0:
                    _context18.next = 2;
                    return Excel.run( /*#__PURE__*/function () {
                      var _ref10 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee17(context) {
                        var table, spill, data;
                        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee17$(_context17) {
                          while (1) switch (_context17.prev = _context17.next) {
                            case 0:
                              table = context.workbook.tables.getItemOrNullObject(name);
                              spill = context.workbook.names.getItemOrNullObject(name);
                              _context17.next = 4;
                              return context.sync();
                            case 4:
                              if (!(table.isNullObject && spill.isNullObject)) {
                                _context17.next = 6;
                                break;
                              }
                              throw {
                                message: "Range \"".concat(name, "\" not found!")
                              };
                            case 6:
                              data = spill.isNullObject ? table.getDataBodyRange().getVisibleView().load("values") : spill.getRange().getSpillingToRange().load("values");
                              _context17.next = 9;
                              return context.sync();
                            case 9:
                              return _context17.abrupt("return", {
                                name: name,
                                data: JSON.stringify(data.values)
                              });
                            case 10:
                            case "end":
                              return _context17.stop();
                          }
                        }, _callee17);
                      }));
                      return function (_x22) {
                        return _ref10.apply(this, arguments);
                      };
                    }());
                  case 2:
                    return _context18.abrupt("return", _context18.sent);
                  case 3:
                  case "end":
                    return _context18.stop();
                }
              }, _callee18);
            }));
            return function (_x21) {
              return _ref9.apply(this, arguments);
            };
          }()));
        case 9:
          range = _context21.sent;
          range.forEach(function (t) {
            return parsed = parsed.replaceAll("@".concat(t.name), t.data);
          });
          _context21.next = 13;
          return Promise.all(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(parsed.matchAll(VARS)).map(function (e) {
            return e[2];
          }).filter(function (e, i, a) {
            return e !== undefined && a.indexOf(e) === i;
          }).sort(function (a, b) {
            return b.length - a.length;
          }).map( /*#__PURE__*/function () {
            var _ref11 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee20(name) {
              return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee20$(_context20) {
                while (1) switch (_context20.prev = _context20.next) {
                  case 0:
                    _context20.next = 2;
                    return Excel.run( /*#__PURE__*/function () {
                      var _ref12 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee19(context) {
                        var data;
                        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee19$(_context19) {
                          while (1) switch (_context19.prev = _context19.next) {
                            case 0:
                              _context19.prev = 0;
                              data = context.workbook.names.getItem(name).getRange().load("values");
                              _context19.next = 4;
                              return context.sync();
                            case 4:
                              return _context19.abrupt("return", {
                                name: name,
                                data: data.values
                              });
                            case 7:
                              _context19.prev = 7;
                              _context19.t0 = _context19["catch"](0);
                              if (!(_context19.t0.code === "ItemNotFound")) {
                                _context19.next = 13;
                                break;
                              }
                              throw {
                                message: "Variable Name \"".concat(name, "\" not defined!")
                              };
                            case 13:
                              throw _context19.t0;
                            case 14:
                            case "end":
                              return _context19.stop();
                          }
                        }, _callee19, null, [[0, 7]]);
                      }));
                      return function (_x24) {
                        return _ref12.apply(this, arguments);
                      };
                    }());
                  case 2:
                    return _context20.abrupt("return", _context20.sent);
                  case 3:
                  case "end":
                    return _context20.stop();
                }
              }, _callee20);
            }));
            return function (_x23) {
              return _ref11.apply(this, arguments);
            };
          }()));
        case 13:
          vars = _context21.sent;
          vars.forEach(function (t) {
            var val = t.data.join("\",\"");
            parsed = parsed.replaceAll("@".concat(t.name), /\W/.test(val) ? "\"".concat(val, "\"") : typeof +val === "number" ? val : "\"".concat(val, "\""));
          });
          __webpack_require__.g.blazorLib.invokeMethodAsync("SubmitCsl", parsed, sc, validateOnly);
          _context21.next = 21;
          break;
        case 18:
          _context21.prev = 18;
          _context21.t0 = _context21["catch"](5);
          _stores__WEBPACK_IMPORTED_MODULE_6__.stateStore.error("Error in Script", _context21.t0.message, null);
        case 21:
        case "end":
          return _context21.stop();
      }
    }, _callee21, null, [[5, 18]]);
  }));
  return function submitScript(_x20) {
    return _ref8.apply(this, arguments);
  };
}();
var submitQuery = /*#__PURE__*/function () {
  var _ref13 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee24(query) {
    var _parsed, vars, parsed;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee24$(_context24) {
      while (1) switch (_context24.prev = _context24.next) {
        case 0:
          if (__webpack_require__.g.ready) {
            _context24.next = 2;
            break;
          }
          return _context24.abrupt("return");
        case 2:
          if (!(!query && !query.trim())) {
            _context24.next = 4;
            break;
          }
          return _context24.abrupt("return");
        case 4:
          _context24.prev = 4;
          _context24.next = 7;
          return Promise.all(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(query.matchAll(VARS)).map(function (e) {
            var _e$;
            return {
              literal: e[0],
              operator: (_e$ = e[1]) === null || _e$ === void 0 ? void 0 : _e$.trim(),
              name: e[2],
              index: e.index
            };
          }).filter(function (e, i, a) {
            var test = e.name !== undefined && a.findIndex(function (e1) {
              return e.name === e1.name;
            }) === i;
            return test;
          }).sort(function (a, b) {
            return b.name.length - a.name.length;
          }).map( /*#__PURE__*/function () {
            var _ref14 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee23(e) {
              return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee23$(_context23) {
                while (1) switch (_context23.prev = _context23.next) {
                  case 0:
                    _context23.next = 2;
                    return Excel.run( /*#__PURE__*/function () {
                      var _ref15 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee22(context) {
                        var data;
                        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee22$(_context22) {
                          while (1) switch (_context22.prev = _context22.next) {
                            case 0:
                              _context22.prev = 0;
                              data = context.workbook.names.getItem(e.name).getRange().load("values");
                              _context22.next = 4;
                              return context.sync();
                            case 4:
                              return _context22.abrupt("return", _objectSpread(_objectSpread({}, e), {}, {
                                data: data.values
                              }));
                            case 7:
                              _context22.prev = 7;
                              _context22.t0 = _context22["catch"](0);
                              if (!(_context22.t0.code === "ItemNotFound")) {
                                _context22.next = 13;
                                break;
                              }
                              throw {
                                message: "Variable Name \"".concat(e.name, "\" not defined!")
                              };
                            case 13:
                              throw _context22.t0;
                            case 14:
                            case "end":
                              return _context22.stop();
                          }
                        }, _callee22, null, [[0, 7]]);
                      }));
                      return function (_x27) {
                        return _ref15.apply(this, arguments);
                      };
                    }());
                  case 2:
                    return _context23.abrupt("return", _context23.sent);
                  case 3:
                  case "end":
                    return _context23.stop();
                }
              }, _callee23);
            }));
            return function (_x26) {
              return _ref14.apply(this, arguments);
            };
          }()));
        case 7:
          vars = _context24.sent;
          parsed = null;
          if (vars.length > 0) {
            parsed = query;
            vars.forEach(function (t) {
              var value = t.data.flat().join("\",\"");
              if (value.trim()) {
                parsed = parsed.replaceAll("@".concat(t.name), "\"".concat(value, "\""));
              } else {
                if (t.operator === "=") {
                  parsed = parsed.replaceAll(t.literal, "_blank");
                } else {
                  parsed = parsed.replaceAll(t.literal, "!blank");
                }
              }
            });
          }
          __webpack_require__.g.blazorLib.invokeMethodAsync("SubmitCql", (_parsed = parsed) !== null && _parsed !== void 0 ? _parsed : query, parsed ? query : null);
          _context24.next = 16;
          break;
        case 13:
          _context24.prev = 13;
          _context24.t0 = _context24["catch"](4);
          _stores__WEBPACK_IMPORTED_MODULE_6__.stateStore.error("Error in Query", _context24.t0.message, null);
        case 16:
        case "end":
          return _context24.stop();
      }
    }, _callee24, null, [[4, 13]]);
  }));
  return function submitQuery(_x25) {
    return _ref13.apply(this, arguments);
  };
}();

/***/ }),

/***/ "./JS/types.ts":
/*!*********************!*\
  !*** ./JS/types.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CommandType: () => (/* binding */ CommandType)
/* harmony export */ });
// Types

var CommandType = /*#__PURE__*/function (CommandType) {
  CommandType[CommandType["onMenu"] = 0] = "onMenu";
  CommandType[CommandType["onCql"] = 1] = "onCql";
  CommandType[CommandType["onCsl"] = 2] = "onCsl";
  CommandType[CommandType["func"] = 3] = "func";
  CommandType[CommandType["onTable"] = 4] = "onTable";
  return CommandType;
}({});

/***/ }),

/***/ "./node_modules/localforage/dist/localforage.js":
/*!******************************************************!*\
  !*** ./node_modules/localforage/dist/localforage.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
    localForage -- Offline Storage, Improved
    Version 1.10.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=undefined;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw (f.code="MODULE_NOT_FOUND", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=undefined;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (global){
'use strict';
var Mutation = global.MutationObserver || global.WebKitMutationObserver;

var scheduleDrain;

{
  if (Mutation) {
    var called = 0;
    var observer = new Mutation(nextTick);
    var element = global.document.createTextNode('');
    observer.observe(element, {
      characterData: true
    });
    scheduleDrain = function () {
      element.data = (called = ++called % 2);
    };
  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = nextTick;
    scheduleDrain = function () {
      channel.port2.postMessage(0);
    };
  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
    scheduleDrain = function () {

      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var scriptEl = global.document.createElement('script');
      scriptEl.onreadystatechange = function () {
        nextTick();

        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };
      global.document.documentElement.appendChild(scriptEl);
    };
  } else {
    scheduleDrain = function () {
      setTimeout(nextTick, 0);
    };
  }
}

var draining;
var queue = [];
//named nextTick for less confusing stack traces
function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;
  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;
    while (++i < len) {
      oldQueue[i]();
    }
    len = queue.length;
  }
  draining = false;
}

module.exports = immediate;
function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}

}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],2:[function(_dereq_,module,exports){
'use strict';
var immediate = _dereq_(1);

/* istanbul ignore next */
function INTERNAL() {}

var handlers = {};

var REJECTED = ['REJECTED'];
var FULFILLED = ['FULFILLED'];
var PENDING = ['PENDING'];

module.exports = Promise;

function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('resolver must be a function');
  }
  this.state = PENDING;
  this.queue = [];
  this.outcome = void 0;
  if (resolver !== INTERNAL) {
    safelyResolveThenable(this, resolver);
  }
}

Promise.prototype["catch"] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
    typeof onRejected !== 'function' && this.state === REJECTED) {
    return this;
  }
  var promise = new this.constructor(INTERNAL);
  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }
  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}
QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};
QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};
QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};
QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }
    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}

handlers.resolve = function (self, value) {
  var result = tryCatch(getThen, value);
  if (result.status === 'error') {
    return handlers.reject(self, result.value);
  }
  var thenable = result.value;

  if (thenable) {
    safelyResolveThenable(self, thenable);
  } else {
    self.state = FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;
    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }
  return self;
};
handlers.reject = function (self, error) {
  self.state = REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;
  while (++i < len) {
    self.queue[i].callRejected(error);
  }
  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;
  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}

function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;
  function onError(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }

  var result = tryCatch(tryToUnwrap);
  if (result.status === 'error') {
    onError(result.value);
  }
}

function tryCatch(func, value) {
  var out = {};
  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }
  return out;
}

Promise.resolve = resolve;
function resolve(value) {
  if (value instanceof this) {
    return value;
  }
  return handlers.resolve(new this(INTERNAL), value);
}

Promise.reject = reject;
function reject(reason) {
  var promise = new this(INTERNAL);
  return handlers.reject(promise, reason);
}

Promise.all = all;
function all(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    allResolver(iterable[i], i);
  }
  return promise;
  function allResolver(value, i) {
    self.resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
    function resolveFromAll(outValue) {
      values[i] = outValue;
      if (++resolved === len && !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}

Promise.race = race;
function race(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    resolver(iterable[i]);
  }
  return promise;
  function resolver(value) {
    self.resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}

},{"1":1}],3:[function(_dereq_,module,exports){
(function (global){
'use strict';
if (typeof global.Promise !== 'function') {
  global.Promise = _dereq_(2);
}

}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"2":2}],4:[function(_dereq_,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function getIDB() {
    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */
    try {
        if (typeof indexedDB !== 'undefined') {
            return indexedDB;
        }
        if (typeof webkitIndexedDB !== 'undefined') {
            return webkitIndexedDB;
        }
        if (typeof mozIndexedDB !== 'undefined') {
            return mozIndexedDB;
        }
        if (typeof OIndexedDB !== 'undefined') {
            return OIndexedDB;
        }
        if (typeof msIndexedDB !== 'undefined') {
            return msIndexedDB;
        }
    } catch (e) {
        return;
    }
}

var idb = getIDB();

function isIndexedDBValid() {
    try {
        // Initialize IndexedDB; fall back to vendor-prefixed versions
        // if needed.
        if (!idb || !idb.open) {
            return false;
        }
        // We mimic PouchDB here;
        //
        // We test for openDatabase because IE Mobile identifies itself
        // as Safari. Oh the lulz...
        var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);

        var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;

        // Safari <10.1 does not meet our requirements for IDB support
        // (see: https://github.com/pouchdb/pouchdb/issues/5572).
        // Safari 10.1 shipped with fetch, we can use that to detect it.
        // Note: this creates issues with `window.fetch` polyfills and
        // overrides; see:
        // https://github.com/localForage/localForage/issues/856
        return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&
        // some outdated implementations of IDB that appear on Samsung
        // and HTC Android devices <4.4 are missing IDBKeyRange
        // See: https://github.com/mozilla/localForage/issues/128
        // See: https://github.com/mozilla/localForage/issues/272
        typeof IDBKeyRange !== 'undefined';
    } catch (e) {
        return false;
    }
}

// Abstracts constructing a Blob object, so it also works in older
// browsers that don't support the native Blob constructor. (i.e.
// old QtWebKit versions, at least).
// Abstracts constructing a Blob object, so it also works in older
// browsers that don't support the native Blob constructor. (i.e.
// old QtWebKit versions, at least).
function createBlob(parts, properties) {
    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */
    parts = parts || [];
    properties = properties || {};
    try {
        return new Blob(parts, properties);
    } catch (e) {
        if (e.name !== 'TypeError') {
            throw e;
        }
        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;
        var builder = new Builder();
        for (var i = 0; i < parts.length; i += 1) {
            builder.append(parts[i]);
        }
        return builder.getBlob(properties.type);
    }
}

// This is CommonJS because lie is an external dependency, so Rollup
// can just ignore it.
if (typeof Promise === 'undefined') {
    // In the "nopromises" build this will just throw if you don't have
    // a global promise object, but it would throw anyway later.
    _dereq_(3);
}
var Promise$1 = Promise;

function executeCallback(promise, callback) {
    if (callback) {
        promise.then(function (result) {
            callback(null, result);
        }, function (error) {
            callback(error);
        });
    }
}

function executeTwoCallbacks(promise, callback, errorCallback) {
    if (typeof callback === 'function') {
        promise.then(callback);
    }

    if (typeof errorCallback === 'function') {
        promise["catch"](errorCallback);
    }
}

function normalizeKey(key) {
    // Cast the key to a string, as that's all we can set as a key.
    if (typeof key !== 'string') {
        console.warn(key + ' used as a key, but it is not a string.');
        key = String(key);
    }

    return key;
}

function getCallback() {
    if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {
        return arguments[arguments.length - 1];
    }
}

// Some code originally from async_storage.js in
// [Gaia](https://github.com/mozilla-b2g/gaia).

var DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';
var supportsBlobs = void 0;
var dbContexts = {};
var toString = Object.prototype.toString;

// Transaction Modes
var READ_ONLY = 'readonly';
var READ_WRITE = 'readwrite';

// Transform a binary string to an array buffer, because otherwise
// weird stuff happens when you try to work with the binary string directly.
// It is known.
// From http://stackoverflow.com/questions/14967647/ (continues on next line)
// encode-decode-image-with-base64-breaks-image (2013-04-21)
function _binStringToArrayBuffer(bin) {
    var length = bin.length;
    var buf = new ArrayBuffer(length);
    var arr = new Uint8Array(buf);
    for (var i = 0; i < length; i++) {
        arr[i] = bin.charCodeAt(i);
    }
    return buf;
}

//
// Blobs are not supported in all versions of IndexedDB, notably
// Chrome <37 and Android <5. In those versions, storing a blob will throw.
//
// Various other blob bugs exist in Chrome v37-42 (inclusive).
// Detecting them is expensive and confusing to users, and Chrome 37-42
// is at very low usage worldwide, so we do a hacky userAgent check instead.
//
// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120
// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916
// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836
//
// Code borrowed from PouchDB. See:
// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js
//
function _checkBlobSupportWithoutCaching(idb) {
    return new Promise$1(function (resolve) {
        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
        var blob = createBlob(['']);
        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');

        txn.onabort = function (e) {
            // If the transaction aborts now its due to not being able to
            // write to the database, likely due to the disk being full
            e.preventDefault();
            e.stopPropagation();
            resolve(false);
        };

        txn.oncomplete = function () {
            var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
            var matchedEdge = navigator.userAgent.match(/Edge\//);
            // MS Edge pretends to be Chrome 42:
            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx
            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
        };
    })["catch"](function () {
        return false; // error, so assume unsupported
    });
}

function _checkBlobSupport(idb) {
    if (typeof supportsBlobs === 'boolean') {
        return Promise$1.resolve(supportsBlobs);
    }
    return _checkBlobSupportWithoutCaching(idb).then(function (value) {
        supportsBlobs = value;
        return supportsBlobs;
    });
}

function _deferReadiness(dbInfo) {
    var dbContext = dbContexts[dbInfo.name];

    // Create a deferred object representing the current database operation.
    var deferredOperation = {};

    deferredOperation.promise = new Promise$1(function (resolve, reject) {
        deferredOperation.resolve = resolve;
        deferredOperation.reject = reject;
    });

    // Enqueue the deferred operation.
    dbContext.deferredOperations.push(deferredOperation);

    // Chain its promise to the database readiness.
    if (!dbContext.dbReady) {
        dbContext.dbReady = deferredOperation.promise;
    } else {
        dbContext.dbReady = dbContext.dbReady.then(function () {
            return deferredOperation.promise;
        });
    }
}

function _advanceReadiness(dbInfo) {
    var dbContext = dbContexts[dbInfo.name];

    // Dequeue a deferred operation.
    var deferredOperation = dbContext.deferredOperations.pop();

    // Resolve its promise (which is part of the database readiness
    // chain of promises).
    if (deferredOperation) {
        deferredOperation.resolve();
        return deferredOperation.promise;
    }
}

function _rejectReadiness(dbInfo, err) {
    var dbContext = dbContexts[dbInfo.name];

    // Dequeue a deferred operation.
    var deferredOperation = dbContext.deferredOperations.pop();

    // Reject its promise (which is part of the database readiness
    // chain of promises).
    if (deferredOperation) {
        deferredOperation.reject(err);
        return deferredOperation.promise;
    }
}

function _getConnection(dbInfo, upgradeNeeded) {
    return new Promise$1(function (resolve, reject) {
        dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();

        if (dbInfo.db) {
            if (upgradeNeeded) {
                _deferReadiness(dbInfo);
                dbInfo.db.close();
            } else {
                return resolve(dbInfo.db);
            }
        }

        var dbArgs = [dbInfo.name];

        if (upgradeNeeded) {
            dbArgs.push(dbInfo.version);
        }

        var openreq = idb.open.apply(idb, dbArgs);

        if (upgradeNeeded) {
            openreq.onupgradeneeded = function (e) {
                var db = openreq.result;
                try {
                    db.createObjectStore(dbInfo.storeName);
                    if (e.oldVersion <= 1) {
                        // Added when support for blob shims was added
                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                    }
                } catch (ex) {
                    if (ex.name === 'ConstraintError') {
                        console.warn('The database "' + dbInfo.name + '"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                    } else {
                        throw ex;
                    }
                }
            };
        }

        openreq.onerror = function (e) {
            e.preventDefault();
            reject(openreq.error);
        };

        openreq.onsuccess = function () {
            var db = openreq.result;
            db.onversionchange = function (e) {
                // Triggered when the database is modified (e.g. adding an objectStore) or
                // deleted (even when initiated by other sessions in different tabs).
                // Closing the connection here prevents those operations from being blocked.
                // If the database is accessed again later by this instance, the connection
                // will be reopened or the database recreated as needed.
                e.target.close();
            };
            resolve(db);
            _advanceReadiness(dbInfo);
        };
    });
}

function _getOriginalConnection(dbInfo) {
    return _getConnection(dbInfo, false);
}

function _getUpgradedConnection(dbInfo) {
    return _getConnection(dbInfo, true);
}

function _isUpgradeNeeded(dbInfo, defaultVersion) {
    if (!dbInfo.db) {
        return true;
    }

    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
    var isDowngrade = dbInfo.version < dbInfo.db.version;
    var isUpgrade = dbInfo.version > dbInfo.db.version;

    if (isDowngrade) {
        // If the version is not the default one
        // then warn for impossible downgrade.
        if (dbInfo.version !== defaultVersion) {
            console.warn('The database "' + dbInfo.name + '"' + " can't be downgraded from version " + dbInfo.db.version + ' to version ' + dbInfo.version + '.');
        }
        // Align the versions to prevent errors.
        dbInfo.version = dbInfo.db.version;
    }

    if (isUpgrade || isNewStore) {
        // If the store is new then increment the version (if needed).
        // This will trigger an "upgradeneeded" event which is required
        // for creating a store.
        if (isNewStore) {
            var incVersion = dbInfo.db.version + 1;
            if (incVersion > dbInfo.version) {
                dbInfo.version = incVersion;
            }
        }

        return true;
    }

    return false;
}

// encode a blob for indexeddb engines that don't support blobs
function _encodeBlob(blob) {
    return new Promise$1(function (resolve, reject) {
        var reader = new FileReader();
        reader.onerror = reject;
        reader.onloadend = function (e) {
            var base64 = btoa(e.target.result || '');
            resolve({
                __local_forage_encoded_blob: true,
                data: base64,
                type: blob.type
            });
        };
        reader.readAsBinaryString(blob);
    });
}

// decode an encoded blob
function _decodeBlob(encodedBlob) {
    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
    return createBlob([arrayBuff], { type: encodedBlob.type });
}

// is this one of our fancy encoded blobs?
function _isEncodedBlob(value) {
    return value && value.__local_forage_encoded_blob;
}

// Specialize the default `ready()` function by making it dependent
// on the current database operations. Thus, the driver will be actually
// ready when it's been initialized (default) *and* there are no pending
// operations on the database (initiated by some other instances).
function _fullyReady(callback) {
    var self = this;

    var promise = self._initReady().then(function () {
        var dbContext = dbContexts[self._dbInfo.name];

        if (dbContext && dbContext.dbReady) {
            return dbContext.dbReady;
        }
    });

    executeTwoCallbacks(promise, callback, callback);
    return promise;
}

// Try to establish a new db connection to replace the
// current one which is broken (i.e. experiencing
// InvalidStateError while creating a transaction).
function _tryReconnect(dbInfo) {
    _deferReadiness(dbInfo);

    var dbContext = dbContexts[dbInfo.name];
    var forages = dbContext.forages;

    for (var i = 0; i < forages.length; i++) {
        var forage = forages[i];
        if (forage._dbInfo.db) {
            forage._dbInfo.db.close();
            forage._dbInfo.db = null;
        }
    }
    dbInfo.db = null;

    return _getOriginalConnection(dbInfo).then(function (db) {
        dbInfo.db = db;
        if (_isUpgradeNeeded(dbInfo)) {
            // Reopen the database for upgrading.
            return _getUpgradedConnection(dbInfo);
        }
        return db;
    }).then(function (db) {
        // store the latest db reference
        // in case the db was upgraded
        dbInfo.db = dbContext.db = db;
        for (var i = 0; i < forages.length; i++) {
            forages[i]._dbInfo.db = db;
        }
    })["catch"](function (err) {
        _rejectReadiness(dbInfo, err);
        throw err;
    });
}

// FF doesn't like Promises (micro-tasks) and IDDB store operations,
// so we have to do it with callbacks
function createTransaction(dbInfo, mode, callback, retries) {
    if (retries === undefined) {
        retries = 1;
    }

    try {
        var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
        callback(null, tx);
    } catch (err) {
        if (retries > 0 && (!dbInfo.db || err.name === 'InvalidStateError' || err.name === 'NotFoundError')) {
            return Promise$1.resolve().then(function () {
                if (!dbInfo.db || err.name === 'NotFoundError' && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                    // increase the db version, to create the new ObjectStore
                    if (dbInfo.db) {
                        dbInfo.version = dbInfo.db.version + 1;
                    }
                    // Reopen the database for upgrading.
                    return _getUpgradedConnection(dbInfo);
                }
            }).then(function () {
                return _tryReconnect(dbInfo).then(function () {
                    createTransaction(dbInfo, mode, callback, retries - 1);
                });
            })["catch"](callback);
        }

        callback(err);
    }
}

function createDbContext() {
    return {
        // Running localForages sharing a database.
        forages: [],
        // Shared database.
        db: null,
        // Database readiness (promise).
        dbReady: null,
        // Deferred operations on the database.
        deferredOperations: []
    };
}

// Open the IndexedDB database (automatically creates one if one didn't
// previously exist), using any options set in the config.
function _initStorage(options) {
    var self = this;
    var dbInfo = {
        db: null
    };

    if (options) {
        for (var i in options) {
            dbInfo[i] = options[i];
        }
    }

    // Get the current context of the database;
    var dbContext = dbContexts[dbInfo.name];

    // ...or create a new context.
    if (!dbContext) {
        dbContext = createDbContext();
        // Register the new context in the global container.
        dbContexts[dbInfo.name] = dbContext;
    }

    // Register itself as a running localForage in the current context.
    dbContext.forages.push(self);

    // Replace the default `ready()` function with the specialized one.
    if (!self._initReady) {
        self._initReady = self.ready;
        self.ready = _fullyReady;
    }

    // Create an array of initialization states of the related localForages.
    var initPromises = [];

    function ignoreErrors() {
        // Don't handle errors here,
        // just makes sure related localForages aren't pending.
        return Promise$1.resolve();
    }

    for (var j = 0; j < dbContext.forages.length; j++) {
        var forage = dbContext.forages[j];
        if (forage !== self) {
            // Don't wait for itself...
            initPromises.push(forage._initReady()["catch"](ignoreErrors));
        }
    }

    // Take a snapshot of the related localForages.
    var forages = dbContext.forages.slice(0);

    // Initialize the connection process only when
    // all the related localForages aren't pending.
    return Promise$1.all(initPromises).then(function () {
        dbInfo.db = dbContext.db;
        // Get the connection or open a new one without upgrade.
        return _getOriginalConnection(dbInfo);
    }).then(function (db) {
        dbInfo.db = db;
        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {
            // Reopen the database for upgrading.
            return _getUpgradedConnection(dbInfo);
        }
        return db;
    }).then(function (db) {
        dbInfo.db = dbContext.db = db;
        self._dbInfo = dbInfo;
        // Share the final connection amongst related localForages.
        for (var k = 0; k < forages.length; k++) {
            var forage = forages[k];
            if (forage !== self) {
                // Self is already up-to-date.
                forage._dbInfo.db = dbInfo.db;
                forage._dbInfo.version = dbInfo.version;
            }
        }
    });
}

function getItem(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.get(key);

                    req.onsuccess = function () {
                        var value = req.result;
                        if (value === undefined) {
                            value = null;
                        }
                        if (_isEncodedBlob(value)) {
                            value = _decodeBlob(value);
                        }
                        resolve(value);
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Iterate over all items stored in database.
function iterate(iterator, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.openCursor();
                    var iterationNumber = 1;

                    req.onsuccess = function () {
                        var cursor = req.result;

                        if (cursor) {
                            var value = cursor.value;
                            if (_isEncodedBlob(value)) {
                                value = _decodeBlob(value);
                            }
                            var result = iterator(value, cursor.key, iterationNumber++);

                            // when the iterator callback returns any
                            // (non-`undefined`) value, then we stop
                            // the iteration immediately
                            if (result !== void 0) {
                                resolve(result);
                            } else {
                                cursor["continue"]();
                            }
                        } else {
                            resolve();
                        }
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);

    return promise;
}

function setItem(key, value, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        var dbInfo;
        self.ready().then(function () {
            dbInfo = self._dbInfo;
            if (toString.call(value) === '[object Blob]') {
                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {
                    if (blobSupport) {
                        return value;
                    }
                    return _encodeBlob(value);
                });
            }
            return value;
        }).then(function (value) {
            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);

                    // The reason we don't _save_ null is because IE 10 does
                    // not support saving the `null` type in IndexedDB. How
                    // ironic, given the bug below!
                    // See: https://github.com/mozilla/localForage/issues/161
                    if (value === null) {
                        value = undefined;
                    }

                    var req = store.put(value, key);

                    transaction.oncomplete = function () {
                        // Cast to undefined so the value passed to
                        // callback/promise is the same as what one would get out
                        // of `getItem()` later. This leads to some weirdness
                        // (setItem('foo', undefined) will return `null`), but
                        // it's not my fault localStorage is our baseline and that
                        // it's weird.
                        if (value === undefined) {
                            value = null;
                        }

                        resolve(value);
                    };
                    transaction.onabort = transaction.onerror = function () {
                        var err = req.error ? req.error : req.transaction.error;
                        reject(err);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function removeItem(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    // We use a Grunt task to make this safe for IE and some
                    // versions of Android (including those used by Cordova).
                    // Normally IE won't like `.delete()` and will insist on
                    // using `['delete']()`, but we have a build step that
                    // fixes this for us now.
                    var req = store["delete"](key);
                    transaction.oncomplete = function () {
                        resolve();
                    };

                    transaction.onerror = function () {
                        reject(req.error);
                    };

                    // The request will be also be aborted if we've exceeded our storage
                    // space.
                    transaction.onabort = function () {
                        var err = req.error ? req.error : req.transaction.error;
                        reject(err);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function clear(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.clear();

                    transaction.oncomplete = function () {
                        resolve();
                    };

                    transaction.onabort = transaction.onerror = function () {
                        var err = req.error ? req.error : req.transaction.error;
                        reject(err);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function length(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.count();

                    req.onsuccess = function () {
                        resolve(req.result);
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function key(n, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        if (n < 0) {
            resolve(null);

            return;
        }

        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var advanced = false;
                    var req = store.openKeyCursor();

                    req.onsuccess = function () {
                        var cursor = req.result;
                        if (!cursor) {
                            // this means there weren't enough keys
                            resolve(null);

                            return;
                        }

                        if (n === 0) {
                            // We have the first key, return it if that's what they
                            // wanted.
                            resolve(cursor.key);
                        } else {
                            if (!advanced) {
                                // Otherwise, ask the cursor to skip ahead n
                                // records.
                                advanced = true;
                                cursor.advance(n);
                            } else {
                                // When we get here, we've got the nth key.
                                resolve(cursor.key);
                            }
                        }
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function keys(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.openKeyCursor();
                    var keys = [];

                    req.onsuccess = function () {
                        var cursor = req.result;

                        if (!cursor) {
                            resolve(keys);
                            return;
                        }

                        keys.push(cursor.key);
                        cursor["continue"]();
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function dropInstance(options, callback) {
    callback = getCallback.apply(this, arguments);

    var currentConfig = this.config();
    options = typeof options !== 'function' && options || {};
    if (!options.name) {
        options.name = options.name || currentConfig.name;
        options.storeName = options.storeName || currentConfig.storeName;
    }

    var self = this;
    var promise;
    if (!options.name) {
        promise = Promise$1.reject('Invalid arguments');
    } else {
        var isCurrentDb = options.name === currentConfig.name && self._dbInfo.db;

        var dbPromise = isCurrentDb ? Promise$1.resolve(self._dbInfo.db) : _getOriginalConnection(options).then(function (db) {
            var dbContext = dbContexts[options.name];
            var forages = dbContext.forages;
            dbContext.db = db;
            for (var i = 0; i < forages.length; i++) {
                forages[i]._dbInfo.db = db;
            }
            return db;
        });

        if (!options.storeName) {
            promise = dbPromise.then(function (db) {
                _deferReadiness(options);

                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;

                db.close();
                for (var i = 0; i < forages.length; i++) {
                    var forage = forages[i];
                    forage._dbInfo.db = null;
                }

                var dropDBPromise = new Promise$1(function (resolve, reject) {
                    var req = idb.deleteDatabase(options.name);

                    req.onerror = function () {
                        var db = req.result;
                        if (db) {
                            db.close();
                        }
                        reject(req.error);
                    };

                    req.onblocked = function () {
                        // Closing all open connections in onversionchange handler should prevent this situation, but if
                        // we do get here, it just means the request remains pending - eventually it will succeed or error
                        console.warn('dropInstance blocked for database "' + options.name + '" until all open connections are closed');
                    };

                    req.onsuccess = function () {
                        var db = req.result;
                        if (db) {
                            db.close();
                        }
                        resolve(db);
                    };
                });

                return dropDBPromise.then(function (db) {
                    dbContext.db = db;
                    for (var i = 0; i < forages.length; i++) {
                        var _forage = forages[i];
                        _advanceReadiness(_forage._dbInfo);
                    }
                })["catch"](function (err) {
                    (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
                    throw err;
                });
            });
        } else {
            promise = dbPromise.then(function (db) {
                if (!db.objectStoreNames.contains(options.storeName)) {
                    return;
                }

                var newVersion = db.version + 1;

                _deferReadiness(options);

                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;

                db.close();
                for (var i = 0; i < forages.length; i++) {
                    var forage = forages[i];
                    forage._dbInfo.db = null;
                    forage._dbInfo.version = newVersion;
                }

                var dropObjectPromise = new Promise$1(function (resolve, reject) {
                    var req = idb.open(options.name, newVersion);

                    req.onerror = function (err) {
                        var db = req.result;
                        db.close();
                        reject(err);
                    };

                    req.onupgradeneeded = function () {
                        var db = req.result;
                        db.deleteObjectStore(options.storeName);
                    };

                    req.onsuccess = function () {
                        var db = req.result;
                        db.close();
                        resolve(db);
                    };
                });

                return dropObjectPromise.then(function (db) {
                    dbContext.db = db;
                    for (var j = 0; j < forages.length; j++) {
                        var _forage2 = forages[j];
                        _forage2._dbInfo.db = db;
                        _advanceReadiness(_forage2._dbInfo);
                    }
                })["catch"](function (err) {
                    (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
                    throw err;
                });
            });
        }
    }

    executeCallback(promise, callback);
    return promise;
}

var asyncStorage = {
    _driver: 'asyncStorage',
    _initStorage: _initStorage,
    _support: isIndexedDBValid(),
    iterate: iterate,
    getItem: getItem,
    setItem: setItem,
    removeItem: removeItem,
    clear: clear,
    length: length,
    key: key,
    keys: keys,
    dropInstance: dropInstance
};

function isWebSQLValid() {
    return typeof openDatabase === 'function';
}

// Sadly, the best way to save binary data in WebSQL/localStorage is serializing
// it to Base64, so this is how we store it to prevent very strange errors with less
// verbose ways of binary <-> string data storage.
var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

var BLOB_TYPE_PREFIX = '~~local_forage_type~';
var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;

var SERIALIZED_MARKER = '__lfsc__:';
var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;

// OMG the serializations!
var TYPE_ARRAYBUFFER = 'arbf';
var TYPE_BLOB = 'blob';
var TYPE_INT8ARRAY = 'si08';
var TYPE_UINT8ARRAY = 'ui08';
var TYPE_UINT8CLAMPEDARRAY = 'uic8';
var TYPE_INT16ARRAY = 'si16';
var TYPE_INT32ARRAY = 'si32';
var TYPE_UINT16ARRAY = 'ur16';
var TYPE_UINT32ARRAY = 'ui32';
var TYPE_FLOAT32ARRAY = 'fl32';
var TYPE_FLOAT64ARRAY = 'fl64';
var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;

var toString$1 = Object.prototype.toString;

function stringToBuffer(serializedString) {
    // Fill the string into a ArrayBuffer.
    var bufferLength = serializedString.length * 0.75;
    var len = serializedString.length;
    var i;
    var p = 0;
    var encoded1, encoded2, encoded3, encoded4;

    if (serializedString[serializedString.length - 1] === '=') {
        bufferLength--;
        if (serializedString[serializedString.length - 2] === '=') {
            bufferLength--;
        }
    }

    var buffer = new ArrayBuffer(bufferLength);
    var bytes = new Uint8Array(buffer);

    for (i = 0; i < len; i += 4) {
        encoded1 = BASE_CHARS.indexOf(serializedString[i]);
        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);

        /*jslint bitwise: true */
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    return buffer;
}

// Converts a buffer to a string to store, serialized, in the backend
// storage library.
function bufferToString(buffer) {
    // base64-arraybuffer
    var bytes = new Uint8Array(buffer);
    var base64String = '';
    var i;

    for (i = 0; i < bytes.length; i += 3) {
        /*jslint bitwise: true */
        base64String += BASE_CHARS[bytes[i] >> 2];
        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
        base64String += BASE_CHARS[bytes[i + 2] & 63];
    }

    if (bytes.length % 3 === 2) {
        base64String = base64String.substring(0, base64String.length - 1) + '=';
    } else if (bytes.length % 3 === 1) {
        base64String = base64String.substring(0, base64String.length - 2) + '==';
    }

    return base64String;
}

// Serialize a value, afterwards executing a callback (which usually
// instructs the `setItem()` callback/promise to be executed). This is how
// we store binary data with localStorage.
function serialize(value, callback) {
    var valueType = '';
    if (value) {
        valueType = toString$1.call(value);
    }

    // Cannot use `value instanceof ArrayBuffer` or such here, as these
    // checks fail when running the tests using casper.js...
    //
    // TODO: See why those tests fail and use a better solution.
    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {
        // Convert binary arrays to a string and prefix the string with
        // a special marker.
        var buffer;
        var marker = SERIALIZED_MARKER;

        if (value instanceof ArrayBuffer) {
            buffer = value;
            marker += TYPE_ARRAYBUFFER;
        } else {
            buffer = value.buffer;

            if (valueType === '[object Int8Array]') {
                marker += TYPE_INT8ARRAY;
            } else if (valueType === '[object Uint8Array]') {
                marker += TYPE_UINT8ARRAY;
            } else if (valueType === '[object Uint8ClampedArray]') {
                marker += TYPE_UINT8CLAMPEDARRAY;
            } else if (valueType === '[object Int16Array]') {
                marker += TYPE_INT16ARRAY;
            } else if (valueType === '[object Uint16Array]') {
                marker += TYPE_UINT16ARRAY;
            } else if (valueType === '[object Int32Array]') {
                marker += TYPE_INT32ARRAY;
            } else if (valueType === '[object Uint32Array]') {
                marker += TYPE_UINT32ARRAY;
            } else if (valueType === '[object Float32Array]') {
                marker += TYPE_FLOAT32ARRAY;
            } else if (valueType === '[object Float64Array]') {
                marker += TYPE_FLOAT64ARRAY;
            } else {
                callback(new Error('Failed to get type for BinaryArray'));
            }
        }

        callback(marker + bufferToString(buffer));
    } else if (valueType === '[object Blob]') {
        // Conver the blob to a binaryArray and then to a string.
        var fileReader = new FileReader();

        fileReader.onload = function () {
            // Backwards-compatible prefix for the blob type.
            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);

            callback(SERIALIZED_MARKER + TYPE_BLOB + str);
        };

        fileReader.readAsArrayBuffer(value);
    } else {
        try {
            callback(JSON.stringify(value));
        } catch (e) {
            console.error("Couldn't convert value into a JSON string: ", value);

            callback(null, e);
        }
    }
}

// Deserialize data we've inserted into a value column/field. We place
// special markers into our strings to mark them as encoded; this isn't
// as nice as a meta field, but it's the only sane thing we can do whilst
// keeping localStorage support intact.
//
// Oftentimes this will just deserialize JSON content, but if we have a
// special marker (SERIALIZED_MARKER, defined above), we will extract
// some kind of arraybuffer/binary data/typed array out of the string.
function deserialize(value) {
    // If we haven't marked this string as being specially serialized (i.e.
    // something other than serialized JSON), we can just return it and be
    // done with it.
    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
        return JSON.parse(value);
    }

    // The following code deals with deserializing some kind of Blob or
    // TypedArray. First we separate out the type of data we're dealing
    // with from the data itself.
    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);

    var blobType;
    // Backwards-compatible blob type serialization strategy.
    // DBs created with older versions of localForage will simply not have the blob type.
    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
        blobType = matcher[1];
        serializedString = serializedString.substring(matcher[0].length);
    }
    var buffer = stringToBuffer(serializedString);

    // Return the right type based on the code/type set during
    // serialization.
    switch (type) {
        case TYPE_ARRAYBUFFER:
            return buffer;
        case TYPE_BLOB:
            return createBlob([buffer], { type: blobType });
        case TYPE_INT8ARRAY:
            return new Int8Array(buffer);
        case TYPE_UINT8ARRAY:
            return new Uint8Array(buffer);
        case TYPE_UINT8CLAMPEDARRAY:
            return new Uint8ClampedArray(buffer);
        case TYPE_INT16ARRAY:
            return new Int16Array(buffer);
        case TYPE_UINT16ARRAY:
            return new Uint16Array(buffer);
        case TYPE_INT32ARRAY:
            return new Int32Array(buffer);
        case TYPE_UINT32ARRAY:
            return new Uint32Array(buffer);
        case TYPE_FLOAT32ARRAY:
            return new Float32Array(buffer);
        case TYPE_FLOAT64ARRAY:
            return new Float64Array(buffer);
        default:
            throw new Error('Unkown type: ' + type);
    }
}

var localforageSerializer = {
    serialize: serialize,
    deserialize: deserialize,
    stringToBuffer: stringToBuffer,
    bufferToString: bufferToString
};

/*
 * Includes code from:
 *
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */

function createDbTable(t, dbInfo, callback, errorCallback) {
    t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' ' + '(id INTEGER PRIMARY KEY, key unique, value)', [], callback, errorCallback);
}

// Open the WebSQL database (automatically creates one if one didn't
// previously exist), using any options set in the config.
function _initStorage$1(options) {
    var self = this;
    var dbInfo = {
        db: null
    };

    if (options) {
        for (var i in options) {
            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];
        }
    }

    var dbInfoPromise = new Promise$1(function (resolve, reject) {
        // Open the database; the openDatabase API will automatically
        // create it for us if it doesn't exist.
        try {
            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
        } catch (e) {
            return reject(e);
        }

        // Create our key/value table if it doesn't exist.
        dbInfo.db.transaction(function (t) {
            createDbTable(t, dbInfo, function () {
                self._dbInfo = dbInfo;
                resolve();
            }, function (t, error) {
                reject(error);
            });
        }, reject);
    });

    dbInfo.serializer = localforageSerializer;
    return dbInfoPromise;
}

function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {
    t.executeSql(sqlStatement, args, callback, function (t, error) {
        if (error.code === error.SYNTAX_ERR) {
            t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name = ?", [dbInfo.storeName], function (t, results) {
                if (!results.rows.length) {
                    // if the table is missing (was deleted)
                    // re-create it table and retry
                    createDbTable(t, dbInfo, function () {
                        t.executeSql(sqlStatement, args, callback, errorCallback);
                    }, errorCallback);
                } else {
                    errorCallback(t, error);
                }
            }, errorCallback);
        } else {
            errorCallback(t, error);
        }
    }, errorCallback);
}

function getItem$1(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {
                    var result = results.rows.length ? results.rows.item(0).value : null;

                    // Check to see if this is serialized content we need to
                    // unpack.
                    if (result) {
                        result = dbInfo.serializer.deserialize(result);
                    }

                    resolve(result);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function iterate$1(iterator, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;

            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {
                    var rows = results.rows;
                    var length = rows.length;

                    for (var i = 0; i < length; i++) {
                        var item = rows.item(i);
                        var result = item.value;

                        // Check to see if this is serialized content
                        // we need to unpack.
                        if (result) {
                            result = dbInfo.serializer.deserialize(result);
                        }

                        result = iterator(result, item.key, i + 1);

                        // void(0) prevents problems with redefinition
                        // of `undefined`.
                        if (result !== void 0) {
                            resolve(result);
                            return;
                        }
                    }

                    resolve();
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function _setItem(key, value, callback, retriesLeft) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            // The localStorage API doesn't return undefined values in an
            // "expected" way, so undefined is always cast to null in all
            // drivers. See: https://github.com/mozilla/localForage/pull/42
            if (value === undefined) {
                value = null;
            }

            // Save the original value to pass to the callback.
            var originalValue = value;

            var dbInfo = self._dbInfo;
            dbInfo.serializer.serialize(value, function (value, error) {
                if (error) {
                    reject(error);
                } else {
                    dbInfo.db.transaction(function (t) {
                        tryExecuteSql(t, dbInfo, 'INSERT OR REPLACE INTO ' + dbInfo.storeName + ' ' + '(key, value) VALUES (?, ?)', [key, value], function () {
                            resolve(originalValue);
                        }, function (t, error) {
                            reject(error);
                        });
                    }, function (sqlError) {
                        // The transaction failed; check
                        // to see if it's a quota error.
                        if (sqlError.code === sqlError.QUOTA_ERR) {
                            // We reject the callback outright for now, but
                            // it's worth trying to re-run the transaction.
                            // Even if the user accepts the prompt to use
                            // more storage on Safari, this error will
                            // be called.
                            //
                            // Try to re-run the transaction.
                            if (retriesLeft > 0) {
                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));
                                return;
                            }
                            reject(sqlError);
                        }
                    });
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function setItem$1(key, value, callback) {
    return _setItem.apply(this, [key, value, callback, 1]);
}

function removeItem$1(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {
                    resolve();
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Deletes every item in the table.
// TODO: Find out if this resets the AUTO_INCREMENT number.
function clear$1(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName, [], function () {
                    resolve();
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Does a simple `COUNT(key)` to get the number of items stored in
// localForage.
function length$1(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                // Ahhh, SQL makes this one soooooo easy.
                tryExecuteSql(t, dbInfo, 'SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {
                    var result = results.rows.item(0).c;
                    resolve(result);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Return the key located at key index X; essentially gets the key from a
// `WHERE id = ?`. This is the most efficient way I can think to implement
// this rarely-used (in my experience) part of the API, but it can seem
// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so
// the ID of each key will change every time it's updated. Perhaps a stored
// procedure for the `setItem()` SQL would solve this problem?
// TODO: Don't change ID on `setItem()`.
function key$1(n, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {
                    var result = results.rows.length ? results.rows.item(0).key : null;
                    resolve(result);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function keys$1(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {
                    var keys = [];

                    for (var i = 0; i < results.rows.length; i++) {
                        keys.push(results.rows.item(i).key);
                    }

                    resolve(keys);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// https://www.w3.org/TR/webdatabase/#databases
// > There is no way to enumerate or delete the databases available for an origin from this API.
function getAllStoreNames(db) {
    return new Promise$1(function (resolve, reject) {
        db.transaction(function (t) {
            t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function (t, results) {
                var storeNames = [];

                for (var i = 0; i < results.rows.length; i++) {
                    storeNames.push(results.rows.item(i).name);
                }

                resolve({
                    db: db,
                    storeNames: storeNames
                });
            }, function (t, error) {
                reject(error);
            });
        }, function (sqlError) {
            reject(sqlError);
        });
    });
}

function dropInstance$1(options, callback) {
    callback = getCallback.apply(this, arguments);

    var currentConfig = this.config();
    options = typeof options !== 'function' && options || {};
    if (!options.name) {
        options.name = options.name || currentConfig.name;
        options.storeName = options.storeName || currentConfig.storeName;
    }

    var self = this;
    var promise;
    if (!options.name) {
        promise = Promise$1.reject('Invalid arguments');
    } else {
        promise = new Promise$1(function (resolve) {
            var db;
            if (options.name === currentConfig.name) {
                // use the db reference of the current instance
                db = self._dbInfo.db;
            } else {
                db = openDatabase(options.name, '', '', 0);
            }

            if (!options.storeName) {
                // drop all database tables
                resolve(getAllStoreNames(db));
            } else {
                resolve({
                    db: db,
                    storeNames: [options.storeName]
                });
            }
        }).then(function (operationInfo) {
            return new Promise$1(function (resolve, reject) {
                operationInfo.db.transaction(function (t) {
                    function dropTable(storeName) {
                        return new Promise$1(function (resolve, reject) {
                            t.executeSql('DROP TABLE IF EXISTS ' + storeName, [], function () {
                                resolve();
                            }, function (t, error) {
                                reject(error);
                            });
                        });
                    }

                    var operations = [];
                    for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
                        operations.push(dropTable(operationInfo.storeNames[i]));
                    }

                    Promise$1.all(operations).then(function () {
                        resolve();
                    })["catch"](function (e) {
                        reject(e);
                    });
                }, function (sqlError) {
                    reject(sqlError);
                });
            });
        });
    }

    executeCallback(promise, callback);
    return promise;
}

var webSQLStorage = {
    _driver: 'webSQLStorage',
    _initStorage: _initStorage$1,
    _support: isWebSQLValid(),
    iterate: iterate$1,
    getItem: getItem$1,
    setItem: setItem$1,
    removeItem: removeItem$1,
    clear: clear$1,
    length: length$1,
    key: key$1,
    keys: keys$1,
    dropInstance: dropInstance$1
};

function isLocalStorageValid() {
    try {
        return typeof localStorage !== 'undefined' && 'setItem' in localStorage &&
        // in IE8 typeof localStorage.setItem === 'object'
        !!localStorage.setItem;
    } catch (e) {
        return false;
    }
}

function _getKeyPrefix(options, defaultConfig) {
    var keyPrefix = options.name + '/';

    if (options.storeName !== defaultConfig.storeName) {
        keyPrefix += options.storeName + '/';
    }
    return keyPrefix;
}

// Check if localStorage throws when saving an item
function checkIfLocalStorageThrows() {
    var localStorageTestKey = '_localforage_support_test';

    try {
        localStorage.setItem(localStorageTestKey, true);
        localStorage.removeItem(localStorageTestKey);

        return false;
    } catch (e) {
        return true;
    }
}

// Check if localStorage is usable and allows to save an item
// This method checks if localStorage is usable in Safari Private Browsing
// mode, or in any other case where the available quota for localStorage
// is 0 and there wasn't any saved items yet.
function _isLocalStorageUsable() {
    return !checkIfLocalStorageThrows() || localStorage.length > 0;
}

// Config the localStorage backend, using options set in the config.
function _initStorage$2(options) {
    var self = this;
    var dbInfo = {};
    if (options) {
        for (var i in options) {
            dbInfo[i] = options[i];
        }
    }

    dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);

    if (!_isLocalStorageUsable()) {
        return Promise$1.reject();
    }

    self._dbInfo = dbInfo;
    dbInfo.serializer = localforageSerializer;

    return Promise$1.resolve();
}

// Remove all keys from the datastore, effectively destroying all data in
// the app's key/value store!
function clear$2(callback) {
    var self = this;
    var promise = self.ready().then(function () {
        var keyPrefix = self._dbInfo.keyPrefix;

        for (var i = localStorage.length - 1; i >= 0; i--) {
            var key = localStorage.key(i);

            if (key.indexOf(keyPrefix) === 0) {
                localStorage.removeItem(key);
            }
        }
    });

    executeCallback(promise, callback);
    return promise;
}

// Retrieve an item from the store. Unlike the original async_storage
// library in Gaia, we don't modify return values at all. If a key's value
// is `undefined`, we pass that value to the callback function.
function getItem$2(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var result = localStorage.getItem(dbInfo.keyPrefix + key);

        // If a result was found, parse it from the serialized
        // string into a JS object. If result isn't truthy, the key
        // is likely undefined and we'll pass it straight to the
        // callback.
        if (result) {
            result = dbInfo.serializer.deserialize(result);
        }

        return result;
    });

    executeCallback(promise, callback);
    return promise;
}

// Iterate over all items in the store.
function iterate$2(iterator, callback) {
    var self = this;

    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var keyPrefix = dbInfo.keyPrefix;
        var keyPrefixLength = keyPrefix.length;
        var length = localStorage.length;

        // We use a dedicated iterator instead of the `i` variable below
        // so other keys we fetch in localStorage aren't counted in
        // the `iterationNumber` argument passed to the `iterate()`
        // callback.
        //
        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530
        var iterationNumber = 1;

        for (var i = 0; i < length; i++) {
            var key = localStorage.key(i);
            if (key.indexOf(keyPrefix) !== 0) {
                continue;
            }
            var value = localStorage.getItem(key);

            // If a result was found, parse it from the serialized
            // string into a JS object. If result isn't truthy, the
            // key is likely undefined and we'll pass it straight
            // to the iterator.
            if (value) {
                value = dbInfo.serializer.deserialize(value);
            }

            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);

            if (value !== void 0) {
                return value;
            }
        }
    });

    executeCallback(promise, callback);
    return promise;
}

// Same as localStorage's key() method, except takes a callback.
function key$2(n, callback) {
    var self = this;
    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var result;
        try {
            result = localStorage.key(n);
        } catch (error) {
            result = null;
        }

        // Remove the prefix from the key, if a key is found.
        if (result) {
            result = result.substring(dbInfo.keyPrefix.length);
        }

        return result;
    });

    executeCallback(promise, callback);
    return promise;
}

function keys$2(callback) {
    var self = this;
    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var length = localStorage.length;
        var keys = [];

        for (var i = 0; i < length; i++) {
            var itemKey = localStorage.key(i);
            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
                keys.push(itemKey.substring(dbInfo.keyPrefix.length));
            }
        }

        return keys;
    });

    executeCallback(promise, callback);
    return promise;
}

// Supply the number of keys in the datastore to the callback function.
function length$2(callback) {
    var self = this;
    var promise = self.keys().then(function (keys) {
        return keys.length;
    });

    executeCallback(promise, callback);
    return promise;
}

// Remove an item from the store, nice and simple.
function removeItem$2(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        localStorage.removeItem(dbInfo.keyPrefix + key);
    });

    executeCallback(promise, callback);
    return promise;
}

// Set a key's value and run an optional callback once the value is set.
// Unlike Gaia's implementation, the callback function is passed the value,
// in case you want to operate on that value only after you're sure it
// saved, or something like that.
function setItem$2(key, value, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = self.ready().then(function () {
        // Convert undefined values to null.
        // https://github.com/mozilla/localForage/pull/42
        if (value === undefined) {
            value = null;
        }

        // Save the original value to pass to the callback.
        var originalValue = value;

        return new Promise$1(function (resolve, reject) {
            var dbInfo = self._dbInfo;
            dbInfo.serializer.serialize(value, function (value, error) {
                if (error) {
                    reject(error);
                } else {
                    try {
                        localStorage.setItem(dbInfo.keyPrefix + key, value);
                        resolve(originalValue);
                    } catch (e) {
                        // localStorage capacity exceeded.
                        // TODO: Make this a specific error/event.
                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                            reject(e);
                        }
                        reject(e);
                    }
                }
            });
        });
    });

    executeCallback(promise, callback);
    return promise;
}

function dropInstance$2(options, callback) {
    callback = getCallback.apply(this, arguments);

    options = typeof options !== 'function' && options || {};
    if (!options.name) {
        var currentConfig = this.config();
        options.name = options.name || currentConfig.name;
        options.storeName = options.storeName || currentConfig.storeName;
    }

    var self = this;
    var promise;
    if (!options.name) {
        promise = Promise$1.reject('Invalid arguments');
    } else {
        promise = new Promise$1(function (resolve) {
            if (!options.storeName) {
                resolve(options.name + '/');
            } else {
                resolve(_getKeyPrefix(options, self._defaultConfig));
            }
        }).then(function (keyPrefix) {
            for (var i = localStorage.length - 1; i >= 0; i--) {
                var key = localStorage.key(i);

                if (key.indexOf(keyPrefix) === 0) {
                    localStorage.removeItem(key);
                }
            }
        });
    }

    executeCallback(promise, callback);
    return promise;
}

var localStorageWrapper = {
    _driver: 'localStorageWrapper',
    _initStorage: _initStorage$2,
    _support: isLocalStorageValid(),
    iterate: iterate$2,
    getItem: getItem$2,
    setItem: setItem$2,
    removeItem: removeItem$2,
    clear: clear$2,
    length: length$2,
    key: key$2,
    keys: keys$2,
    dropInstance: dropInstance$2
};

var sameValue = function sameValue(x, y) {
    return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);
};

var includes = function includes(array, searchElement) {
    var len = array.length;
    var i = 0;
    while (i < len) {
        if (sameValue(array[i], searchElement)) {
            return true;
        }
        i++;
    }

    return false;
};

var isArray = Array.isArray || function (arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
};

// Drivers are stored here when `defineDriver()` is called.
// They are shared across all instances of localForage.
var DefinedDrivers = {};

var DriverSupport = {};

var DefaultDrivers = {
    INDEXEDDB: asyncStorage,
    WEBSQL: webSQLStorage,
    LOCALSTORAGE: localStorageWrapper
};

var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];

var OptionalDriverMethods = ['dropInstance'];

var LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'].concat(OptionalDriverMethods);

var DefaultConfig = {
    description: '',
    driver: DefaultDriverOrder.slice(),
    name: 'localforage',
    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
    // we can use without a prompt.
    size: 4980736,
    storeName: 'keyvaluepairs',
    version: 1.0
};

function callWhenReady(localForageInstance, libraryMethod) {
    localForageInstance[libraryMethod] = function () {
        var _args = arguments;
        return localForageInstance.ready().then(function () {
            return localForageInstance[libraryMethod].apply(localForageInstance, _args);
        });
    };
}

function extend() {
    for (var i = 1; i < arguments.length; i++) {
        var arg = arguments[i];

        if (arg) {
            for (var _key in arg) {
                if (arg.hasOwnProperty(_key)) {
                    if (isArray(arg[_key])) {
                        arguments[0][_key] = arg[_key].slice();
                    } else {
                        arguments[0][_key] = arg[_key];
                    }
                }
            }
        }
    }

    return arguments[0];
}

var LocalForage = function () {
    function LocalForage(options) {
        _classCallCheck(this, LocalForage);

        for (var driverTypeKey in DefaultDrivers) {
            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
                var driver = DefaultDrivers[driverTypeKey];
                var driverName = driver._driver;
                this[driverTypeKey] = driverName;

                if (!DefinedDrivers[driverName]) {
                    // we don't need to wait for the promise,
                    // since the default drivers can be defined
                    // in a blocking manner
                    this.defineDriver(driver);
                }
            }
        }

        this._defaultConfig = extend({}, DefaultConfig);
        this._config = extend({}, this._defaultConfig, options);
        this._driverSet = null;
        this._initDriver = null;
        this._ready = false;
        this._dbInfo = null;

        this._wrapLibraryMethodsWithReady();
        this.setDriver(this._config.driver)["catch"](function () {});
    }

    // Set any config values for localForage; can be called anytime before
    // the first API call (e.g. `getItem`, `setItem`).
    // We loop through options so we don't overwrite existing config
    // values.


    LocalForage.prototype.config = function config(options) {
        // If the options argument is an object, we use it to set values.
        // Otherwise, we return either a specified config value or all
        // config values.
        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
            // If localforage is ready and fully initialized, we can't set
            // any new configuration values. Instead, we return an error.
            if (this._ready) {
                return new Error("Can't call config() after localforage " + 'has been used.');
            }

            for (var i in options) {
                if (i === 'storeName') {
                    options[i] = options[i].replace(/\W/g, '_');
                }

                if (i === 'version' && typeof options[i] !== 'number') {
                    return new Error('Database version must be a number.');
                }

                this._config[i] = options[i];
            }

            // after all config options are set and
            // the driver option is used, try setting it
            if ('driver' in options && options.driver) {
                return this.setDriver(this._config.driver);
            }

            return true;
        } else if (typeof options === 'string') {
            return this._config[options];
        } else {
            return this._config;
        }
    };

    // Used to define a custom driver, shared across all instances of
    // localForage.


    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
        var promise = new Promise$1(function (resolve, reject) {
            try {
                var driverName = driverObject._driver;
                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');

                // A driver name should be defined and not overlap with the
                // library-defined, default drivers.
                if (!driverObject._driver) {
                    reject(complianceError);
                    return;
                }

                var driverMethods = LibraryMethods.concat('_initStorage');
                for (var i = 0, len = driverMethods.length; i < len; i++) {
                    var driverMethodName = driverMethods[i];

                    // when the property is there,
                    // it should be a method even when optional
                    var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                    if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== 'function') {
                        reject(complianceError);
                        return;
                    }
                }

                var configureMissingMethods = function configureMissingMethods() {
                    var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {
                        return function () {
                            var error = new Error('Method ' + methodName + ' is not implemented by the current driver');
                            var promise = Promise$1.reject(error);
                            executeCallback(promise, arguments[arguments.length - 1]);
                            return promise;
                        };
                    };

                    for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                        var optionalDriverMethod = OptionalDriverMethods[_i];
                        if (!driverObject[optionalDriverMethod]) {
                            driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                        }
                    }
                };

                configureMissingMethods();

                var setDriverSupport = function setDriverSupport(support) {
                    if (DefinedDrivers[driverName]) {
                        console.info('Redefining LocalForage driver: ' + driverName);
                    }
                    DefinedDrivers[driverName] = driverObject;
                    DriverSupport[driverName] = support;
                    // don't use a then, so that we can define
                    // drivers that have simple _support methods
                    // in a blocking manner
                    resolve();
                };

                if ('_support' in driverObject) {
                    if (driverObject._support && typeof driverObject._support === 'function') {
                        driverObject._support().then(setDriverSupport, reject);
                    } else {
                        setDriverSupport(!!driverObject._support);
                    }
                } else {
                    setDriverSupport(true);
                }
            } catch (e) {
                reject(e);
            }
        });

        executeTwoCallbacks(promise, callback, errorCallback);
        return promise;
    };

    LocalForage.prototype.driver = function driver() {
        return this._driver || null;
    };

    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
        var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));

        executeTwoCallbacks(getDriverPromise, callback, errorCallback);
        return getDriverPromise;
    };

    LocalForage.prototype.getSerializer = function getSerializer(callback) {
        var serializerPromise = Promise$1.resolve(localforageSerializer);
        executeTwoCallbacks(serializerPromise, callback);
        return serializerPromise;
    };

    LocalForage.prototype.ready = function ready(callback) {
        var self = this;

        var promise = self._driverSet.then(function () {
            if (self._ready === null) {
                self._ready = self._initDriver();
            }

            return self._ready;
        });

        executeTwoCallbacks(promise, callback, callback);
        return promise;
    };

    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
        var self = this;

        if (!isArray(drivers)) {
            drivers = [drivers];
        }

        var supportedDrivers = this._getSupportedDrivers(drivers);

        function setDriverToConfig() {
            self._config.driver = self.driver();
        }

        function extendSelfWithDriver(driver) {
            self._extend(driver);
            setDriverToConfig();

            self._ready = self._initStorage(self._config);
            return self._ready;
        }

        function initDriver(supportedDrivers) {
            return function () {
                var currentDriverIndex = 0;

                function driverPromiseLoop() {
                    while (currentDriverIndex < supportedDrivers.length) {
                        var driverName = supportedDrivers[currentDriverIndex];
                        currentDriverIndex++;

                        self._dbInfo = null;
                        self._ready = null;

                        return self.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                    }

                    setDriverToConfig();
                    var error = new Error('No available storage method found.');
                    self._driverSet = Promise$1.reject(error);
                    return self._driverSet;
                }

                return driverPromiseLoop();
            };
        }

        // There might be a driver initialization in progress
        // so wait for it to finish in order to avoid a possible
        // race condition to set _dbInfo
        var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function () {
            return Promise$1.resolve();
        }) : Promise$1.resolve();

        this._driverSet = oldDriverSetDone.then(function () {
            var driverName = supportedDrivers[0];
            self._dbInfo = null;
            self._ready = null;

            return self.getDriver(driverName).then(function (driver) {
                self._driver = driver._driver;
                setDriverToConfig();
                self._wrapLibraryMethodsWithReady();
                self._initDriver = initDriver(supportedDrivers);
            });
        })["catch"](function () {
            setDriverToConfig();
            var error = new Error('No available storage method found.');
            self._driverSet = Promise$1.reject(error);
            return self._driverSet;
        });

        executeTwoCallbacks(this._driverSet, callback, errorCallback);
        return this._driverSet;
    };

    LocalForage.prototype.supports = function supports(driverName) {
        return !!DriverSupport[driverName];
    };

    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {
        extend(this, libraryMethodsAndProperties);
    };

    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
        var supportedDrivers = [];
        for (var i = 0, len = drivers.length; i < len; i++) {
            var driverName = drivers[i];
            if (this.supports(driverName)) {
                supportedDrivers.push(driverName);
            }
        }
        return supportedDrivers;
    };

    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
        // Add a stub for each driver API method that delays the call to the
        // corresponding driver method until localForage is ready. These stubs
        // will be replaced by the driver methods as soon as the driver is
        // loaded, so there is no performance impact.
        for (var i = 0, len = LibraryMethods.length; i < len; i++) {
            callWhenReady(this, LibraryMethods[i]);
        }
    };

    LocalForage.prototype.createInstance = function createInstance(options) {
        return new LocalForage(options);
    };

    return LocalForage;
}();

// The actual localForage object that we expose as a module or via a
// global. It's extended by pulling in one of our other libraries.


var localforage_js = new LocalForage();

module.exports = localforage_js;

},{"3":3}]},{},[4])(4)
});


/***/ }),

/***/ "./JS/style.css":
/*!**********************!*\
  !*** ./JS/style.css ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/prismjs/prism.js":
/*!***************************************!*\
  !*** ./node_modules/prismjs/prism.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/* **********************************************
     Begin prism-core.js
********************************************** */

/// <reference lib="WebWorker"/>

var _self = (typeof window !== 'undefined')
	? window   // if in browser
	: (
		(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
			? self // if in worker
			: {}   // if in node js
	);

/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */
var Prism = (function (_self) {

	// Private helper vars
	var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
	var uniqueId = 0;

	// The grammar object for plaintext
	var plainTextGrammar = {};


	var _ = {
		/**
		 * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
		 * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
		 * additional languages or plugins yourself.
		 *
		 * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
		 *
		 * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
		 * empty Prism object into the global scope before loading the Prism script like this:
		 *
		 * ```js
		 * window.Prism = window.Prism || {};
		 * Prism.manual = true;
		 * // add a new <script> to load Prism's script
		 * ```
		 *
		 * @default false
		 * @type {boolean}
		 * @memberof Prism
		 * @public
		 */
		manual: _self.Prism && _self.Prism.manual,
		/**
		 * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
		 * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
		 * own worker, you don't want it to do this.
		 *
		 * By setting this value to `true`, Prism will not add its own listeners to the worker.
		 *
		 * You obviously have to change this value before Prism executes. To do this, you can add an
		 * empty Prism object into the global scope before loading the Prism script like this:
		 *
		 * ```js
		 * window.Prism = window.Prism || {};
		 * Prism.disableWorkerMessageHandler = true;
		 * // Load Prism's script
		 * ```
		 *
		 * @default false
		 * @type {boolean}
		 * @memberof Prism
		 * @public
		 */
		disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,

		/**
		 * A namespace for utility methods.
		 *
		 * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
		 * change or disappear at any time.
		 *
		 * @namespace
		 * @memberof Prism
		 */
		util: {
			encode: function encode(tokens) {
				if (tokens instanceof Token) {
					return new Token(tokens.type, encode(tokens.content), tokens.alias);
				} else if (Array.isArray(tokens)) {
					return tokens.map(encode);
				} else {
					return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
				}
			},

			/**
			 * Returns the name of the type of the given value.
			 *
			 * @param {any} o
			 * @returns {string}
			 * @example
			 * type(null)      === 'Null'
			 * type(undefined) === 'Undefined'
			 * type(123)       === 'Number'
			 * type('foo')     === 'String'
			 * type(true)      === 'Boolean'
			 * type([1, 2])    === 'Array'
			 * type({})        === 'Object'
			 * type(String)    === 'Function'
			 * type(/abc+/)    === 'RegExp'
			 */
			type: function (o) {
				return Object.prototype.toString.call(o).slice(8, -1);
			},

			/**
			 * Returns a unique number for the given object. Later calls will still return the same number.
			 *
			 * @param {Object} obj
			 * @returns {number}
			 */
			objId: function (obj) {
				if (!obj['__id']) {
					Object.defineProperty(obj, '__id', { value: ++uniqueId });
				}
				return obj['__id'];
			},

			/**
			 * Creates a deep clone of the given object.
			 *
			 * The main intended use of this function is to clone language definitions.
			 *
			 * @param {T} o
			 * @param {Record<number, any>} [visited]
			 * @returns {T}
			 * @template T
			 */
			clone: function deepClone(o, visited) {
				visited = visited || {};

				var clone; var id;
				switch (_.util.type(o)) {
					case 'Object':
						id = _.util.objId(o);
						if (visited[id]) {
							return visited[id];
						}
						clone = /** @type {Record<string, any>} */ ({});
						visited[id] = clone;

						for (var key in o) {
							if (o.hasOwnProperty(key)) {
								clone[key] = deepClone(o[key], visited);
							}
						}

						return /** @type {any} */ (clone);

					case 'Array':
						id = _.util.objId(o);
						if (visited[id]) {
							return visited[id];
						}
						clone = [];
						visited[id] = clone;

						(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {
							clone[i] = deepClone(v, visited);
						});

						return /** @type {any} */ (clone);

					default:
						return o;
				}
			},

			/**
			 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
			 *
			 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
			 *
			 * @param {Element} element
			 * @returns {string}
			 */
			getLanguage: function (element) {
				while (element) {
					var m = lang.exec(element.className);
					if (m) {
						return m[1].toLowerCase();
					}
					element = element.parentElement;
				}
				return 'none';
			},

			/**
			 * Sets the Prism `language-xxxx` class of the given element.
			 *
			 * @param {Element} element
			 * @param {string} language
			 * @returns {void}
			 */
			setLanguage: function (element, language) {
				// remove all `language-xxxx` classes
				// (this might leave behind a leading space)
				element.className = element.className.replace(RegExp(lang, 'gi'), '');

				// add the new `language-xxxx` class
				// (using `classList` will automatically clean up spaces for us)
				element.classList.add('language-' + language);
			},

			/**
			 * Returns the script element that is currently executing.
			 *
			 * This does __not__ work for line script element.
			 *
			 * @returns {HTMLScriptElement | null}
			 */
			currentScript: function () {
				if (typeof document === 'undefined') {
					return null;
				}
				if ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {
					return /** @type {any} */ (document.currentScript);
				}

				// IE11 workaround
				// we'll get the src of the current script by parsing IE11's error stack trace
				// this will not work for inline scripts

				try {
					throw new Error();
				} catch (err) {
					// Get file src url from stack. Specifically works with the format of stack traces in IE.
					// A stack will look like this:
					//
					// Error
					//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
					//    at Global code (http://localhost/components/prism-core.js:606:1)

					var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
					if (src) {
						var scripts = document.getElementsByTagName('script');
						for (var i in scripts) {
							if (scripts[i].src == src) {
								return scripts[i];
							}
						}
					}
					return null;
				}
			},

			/**
			 * Returns whether a given class is active for `element`.
			 *
			 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
			 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
			 * given class is just the given class with a `no-` prefix.
			 *
			 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
			 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
			 * ancestors have the given class or the negated version of it, then the default activation will be returned.
			 *
			 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
			 * version of it, the class is considered active.
			 *
			 * @param {Element} element
			 * @param {string} className
			 * @param {boolean} [defaultActivation=false]
			 * @returns {boolean}
			 */
			isActive: function (element, className, defaultActivation) {
				var no = 'no-' + className;

				while (element) {
					var classList = element.classList;
					if (classList.contains(className)) {
						return true;
					}
					if (classList.contains(no)) {
						return false;
					}
					element = element.parentElement;
				}
				return !!defaultActivation;
			}
		},

		/**
		 * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
		 *
		 * @namespace
		 * @memberof Prism
		 * @public
		 */
		languages: {
			/**
			 * The grammar for plain, unformatted text.
			 */
			plain: plainTextGrammar,
			plaintext: plainTextGrammar,
			text: plainTextGrammar,
			txt: plainTextGrammar,

			/**
			 * Creates a deep copy of the language with the given id and appends the given tokens.
			 *
			 * If a token in `redef` also appears in the copied language, then the existing token in the copied language
			 * will be overwritten at its original position.
			 *
			 * ## Best practices
			 *
			 * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
			 * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
			 * understand the language definition because, normally, the order of tokens matters in Prism grammars.
			 *
			 * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
			 * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
			 *
			 * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
			 * @param {Grammar} redef The new tokens to append.
			 * @returns {Grammar} The new language created.
			 * @public
			 * @example
			 * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
			 *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
			 *     // at its original position
			 *     'comment': { ... },
			 *     // CSS doesn't have a 'color' token, so this token will be appended
			 *     'color': /\b(?:red|green|blue)\b/
			 * });
			 */
			extend: function (id, redef) {
				var lang = _.util.clone(_.languages[id]);

				for (var key in redef) {
					lang[key] = redef[key];
				}

				return lang;
			},

			/**
			 * Inserts tokens _before_ another token in a language definition or any other grammar.
			 *
			 * ## Usage
			 *
			 * This helper method makes it easy to modify existing languages. For example, the CSS language definition
			 * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
			 * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
			 * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
			 * this:
			 *
			 * ```js
			 * Prism.languages.markup.style = {
			 *     // token
			 * };
			 * ```
			 *
			 * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
			 * before existing tokens. For the CSS example above, you would use it like this:
			 *
			 * ```js
			 * Prism.languages.insertBefore('markup', 'cdata', {
			 *     'style': {
			 *         // token
			 *     }
			 * });
			 * ```
			 *
			 * ## Special cases
			 *
			 * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
			 * will be ignored.
			 *
			 * This behavior can be used to insert tokens after `before`:
			 *
			 * ```js
			 * Prism.languages.insertBefore('markup', 'comment', {
			 *     'comment': Prism.languages.markup.comment,
			 *     // tokens after 'comment'
			 * });
			 * ```
			 *
			 * ## Limitations
			 *
			 * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
			 * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
			 * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
			 * deleting properties which is necessary to insert at arbitrary positions.
			 *
			 * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
			 * Instead, it will create a new object and replace all references to the target object with the new one. This
			 * can be done without temporarily deleting properties, so the iteration order is well-defined.
			 *
			 * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
			 * you hold the target object in a variable, then the value of the variable will not change.
			 *
			 * ```js
			 * var oldMarkup = Prism.languages.markup;
			 * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
			 *
			 * assert(oldMarkup !== Prism.languages.markup);
			 * assert(newMarkup === Prism.languages.markup);
			 * ```
			 *
			 * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
			 * object to be modified.
			 * @param {string} before The key to insert before.
			 * @param {Grammar} insert An object containing the key-value pairs to be inserted.
			 * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
			 * object to be modified.
			 *
			 * Defaults to `Prism.languages`.
			 * @returns {Grammar} The new grammar object.
			 * @public
			 */
			insertBefore: function (inside, before, insert, root) {
				root = root || /** @type {any} */ (_.languages);
				var grammar = root[inside];
				/** @type {Grammar} */
				var ret = {};

				for (var token in grammar) {
					if (grammar.hasOwnProperty(token)) {

						if (token == before) {
							for (var newToken in insert) {
								if (insert.hasOwnProperty(newToken)) {
									ret[newToken] = insert[newToken];
								}
							}
						}

						// Do not insert token which also occur in insert. See #1525
						if (!insert.hasOwnProperty(token)) {
							ret[token] = grammar[token];
						}
					}
				}

				var old = root[inside];
				root[inside] = ret;

				// Update references in other language definitions
				_.languages.DFS(_.languages, function (key, value) {
					if (value === old && key != inside) {
						this[key] = ret;
					}
				});

				return ret;
			},

			// Traverse a language definition with Depth First Search
			DFS: function DFS(o, callback, type, visited) {
				visited = visited || {};

				var objId = _.util.objId;

				for (var i in o) {
					if (o.hasOwnProperty(i)) {
						callback.call(o, i, o[i], type || i);

						var property = o[i];
						var propertyType = _.util.type(property);

						if (propertyType === 'Object' && !visited[objId(property)]) {
							visited[objId(property)] = true;
							DFS(property, callback, null, visited);
						} else if (propertyType === 'Array' && !visited[objId(property)]) {
							visited[objId(property)] = true;
							DFS(property, callback, i, visited);
						}
					}
				}
			}
		},

		plugins: {},

		/**
		 * This is the most high-level function in Prism’s API.
		 * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
		 * each one of them.
		 *
		 * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
		 *
		 * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
		 * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
		 * @memberof Prism
		 * @public
		 */
		highlightAll: function (async, callback) {
			_.highlightAllUnder(document, async, callback);
		},

		/**
		 * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
		 * {@link Prism.highlightElement} on each one of them.
		 *
		 * The following hooks will be run:
		 * 1. `before-highlightall`
		 * 2. `before-all-elements-highlight`
		 * 3. All hooks of {@link Prism.highlightElement} for each element.
		 *
		 * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
		 * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
		 * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
		 * @memberof Prism
		 * @public
		 */
		highlightAllUnder: function (container, async, callback) {
			var env = {
				callback: callback,
				container: container,
				selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
			};

			_.hooks.run('before-highlightall', env);

			env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));

			_.hooks.run('before-all-elements-highlight', env);

			for (var i = 0, element; (element = env.elements[i++]);) {
				_.highlightElement(element, async === true, env.callback);
			}
		},

		/**
		 * Highlights the code inside a single element.
		 *
		 * The following hooks will be run:
		 * 1. `before-sanity-check`
		 * 2. `before-highlight`
		 * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
		 * 4. `before-insert`
		 * 5. `after-highlight`
		 * 6. `complete`
		 *
		 * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
		 * the element's language.
		 *
		 * @param {Element} element The element containing the code.
		 * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
		 * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
		 * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
		 * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
		 *
		 * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
		 * asynchronous highlighting to work. You can build your own bundle on the
		 * [Download page](https://prismjs.com/download.html).
		 * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
		 * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
		 * @memberof Prism
		 * @public
		 */
		highlightElement: function (element, async, callback) {
			// Find language
			var language = _.util.getLanguage(element);
			var grammar = _.languages[language];

			// Set language on the element, if not present
			_.util.setLanguage(element, language);

			// Set language on the parent, for styling
			var parent = element.parentElement;
			if (parent && parent.nodeName.toLowerCase() === 'pre') {
				_.util.setLanguage(parent, language);
			}

			var code = element.textContent;

			var env = {
				element: element,
				language: language,
				grammar: grammar,
				code: code
			};

			function insertHighlightedCode(highlightedCode) {
				env.highlightedCode = highlightedCode;

				_.hooks.run('before-insert', env);

				env.element.innerHTML = env.highlightedCode;

				_.hooks.run('after-highlight', env);
				_.hooks.run('complete', env);
				callback && callback.call(env.element);
			}

			_.hooks.run('before-sanity-check', env);

			// plugins may change/add the parent/element
			parent = env.element.parentElement;
			if (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {
				parent.setAttribute('tabindex', '0');
			}

			if (!env.code) {
				_.hooks.run('complete', env);
				callback && callback.call(env.element);
				return;
			}

			_.hooks.run('before-highlight', env);

			if (!env.grammar) {
				insertHighlightedCode(_.util.encode(env.code));
				return;
			}

			if (async && _self.Worker) {
				var worker = new Worker(_.filename);

				worker.onmessage = function (evt) {
					insertHighlightedCode(evt.data);
				};

				worker.postMessage(JSON.stringify({
					language: env.language,
					code: env.code,
					immediateClose: true
				}));
			} else {
				insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
			}
		},

		/**
		 * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
		 * and the language definitions to use, and returns a string with the HTML produced.
		 *
		 * The following hooks will be run:
		 * 1. `before-tokenize`
		 * 2. `after-tokenize`
		 * 3. `wrap`: On each {@link Token}.
		 *
		 * @param {string} text A string with the code to be highlighted.
		 * @param {Grammar} grammar An object containing the tokens to use.
		 *
		 * Usually a language definition like `Prism.languages.markup`.
		 * @param {string} language The name of the language definition passed to `grammar`.
		 * @returns {string} The highlighted HTML.
		 * @memberof Prism
		 * @public
		 * @example
		 * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
		 */
		highlight: function (text, grammar, language) {
			var env = {
				code: text,
				grammar: grammar,
				language: language
			};
			_.hooks.run('before-tokenize', env);
			if (!env.grammar) {
				throw new Error('The language "' + env.language + '" has no grammar.');
			}
			env.tokens = _.tokenize(env.code, env.grammar);
			_.hooks.run('after-tokenize', env);
			return Token.stringify(_.util.encode(env.tokens), env.language);
		},

		/**
		 * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
		 * and the language definitions to use, and returns an array with the tokenized code.
		 *
		 * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
		 *
		 * This method could be useful in other contexts as well, as a very crude parser.
		 *
		 * @param {string} text A string with the code to be highlighted.
		 * @param {Grammar} grammar An object containing the tokens to use.
		 *
		 * Usually a language definition like `Prism.languages.markup`.
		 * @returns {TokenStream} An array of strings and tokens, a token stream.
		 * @memberof Prism
		 * @public
		 * @example
		 * let code = `var foo = 0;`;
		 * let tokens = Prism.tokenize(code, Prism.languages.javascript);
		 * tokens.forEach(token => {
		 *     if (token instanceof Prism.Token && token.type === 'number') {
		 *         console.log(`Found numeric literal: ${token.content}`);
		 *     }
		 * });
		 */
		tokenize: function (text, grammar) {
			var rest = grammar.rest;
			if (rest) {
				for (var token in rest) {
					grammar[token] = rest[token];
				}

				delete grammar.rest;
			}

			var tokenList = new LinkedList();
			addAfter(tokenList, tokenList.head, text);

			matchGrammar(text, tokenList, grammar, tokenList.head, 0);

			return toArray(tokenList);
		},

		/**
		 * @namespace
		 * @memberof Prism
		 * @public
		 */
		hooks: {
			all: {},

			/**
			 * Adds the given callback to the list of callbacks for the given hook.
			 *
			 * The callback will be invoked when the hook it is registered for is run.
			 * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
			 *
			 * One callback function can be registered to multiple hooks and the same hook multiple times.
			 *
			 * @param {string} name The name of the hook.
			 * @param {HookCallback} callback The callback function which is given environment variables.
			 * @public
			 */
			add: function (name, callback) {
				var hooks = _.hooks.all;

				hooks[name] = hooks[name] || [];

				hooks[name].push(callback);
			},

			/**
			 * Runs a hook invoking all registered callbacks with the given environment variables.
			 *
			 * Callbacks will be invoked synchronously and in the order in which they were registered.
			 *
			 * @param {string} name The name of the hook.
			 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
			 * @public
			 */
			run: function (name, env) {
				var callbacks = _.hooks.all[name];

				if (!callbacks || !callbacks.length) {
					return;
				}

				for (var i = 0, callback; (callback = callbacks[i++]);) {
					callback(env);
				}
			}
		},

		Token: Token
	};
	_self.Prism = _;


	// Typescript note:
	// The following can be used to import the Token type in JSDoc:
	//
	//   @typedef {InstanceType<import("./prism-core")["Token"]>} Token

	/**
	 * Creates a new token.
	 *
	 * @param {string} type See {@link Token#type type}
	 * @param {string | TokenStream} content See {@link Token#content content}
	 * @param {string|string[]} [alias] The alias(es) of the token.
	 * @param {string} [matchedStr=""] A copy of the full string this token was created from.
	 * @class
	 * @global
	 * @public
	 */
	function Token(type, content, alias, matchedStr) {
		/**
		 * The type of the token.
		 *
		 * This is usually the key of a pattern in a {@link Grammar}.
		 *
		 * @type {string}
		 * @see GrammarToken
		 * @public
		 */
		this.type = type;
		/**
		 * The strings or tokens contained by this token.
		 *
		 * This will be a token stream if the pattern matched also defined an `inside` grammar.
		 *
		 * @type {string | TokenStream}
		 * @public
		 */
		this.content = content;
		/**
		 * The alias(es) of the token.
		 *
		 * @type {string|string[]}
		 * @see GrammarToken
		 * @public
		 */
		this.alias = alias;
		// Copy of the full string this token was created from
		this.length = (matchedStr || '').length | 0;
	}

	/**
	 * A token stream is an array of strings and {@link Token Token} objects.
	 *
	 * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
	 * them.
	 *
	 * 1. No adjacent strings.
	 * 2. No empty strings.
	 *
	 *    The only exception here is the token stream that only contains the empty string and nothing else.
	 *
	 * @typedef {Array<string | Token>} TokenStream
	 * @global
	 * @public
	 */

	/**
	 * Converts the given token or token stream to an HTML representation.
	 *
	 * The following hooks will be run:
	 * 1. `wrap`: On each {@link Token}.
	 *
	 * @param {string | Token | TokenStream} o The token or token stream to be converted.
	 * @param {string} language The name of current language.
	 * @returns {string} The HTML representation of the token or token stream.
	 * @memberof Token
	 * @static
	 */
	Token.stringify = function stringify(o, language) {
		if (typeof o == 'string') {
			return o;
		}
		if (Array.isArray(o)) {
			var s = '';
			o.forEach(function (e) {
				s += stringify(e, language);
			});
			return s;
		}

		var env = {
			type: o.type,
			content: stringify(o.content, language),
			tag: 'span',
			classes: ['token', o.type],
			attributes: {},
			language: language
		};

		var aliases = o.alias;
		if (aliases) {
			if (Array.isArray(aliases)) {
				Array.prototype.push.apply(env.classes, aliases);
			} else {
				env.classes.push(aliases);
			}
		}

		_.hooks.run('wrap', env);

		var attributes = '';
		for (var name in env.attributes) {
			attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
		}

		return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
	};

	/**
	 * @param {RegExp} pattern
	 * @param {number} pos
	 * @param {string} text
	 * @param {boolean} lookbehind
	 * @returns {RegExpExecArray | null}
	 */
	function matchPattern(pattern, pos, text, lookbehind) {
		pattern.lastIndex = pos;
		var match = pattern.exec(text);
		if (match && lookbehind && match[1]) {
			// change the match to remove the text matched by the Prism lookbehind group
			var lookbehindLength = match[1].length;
			match.index += lookbehindLength;
			match[0] = match[0].slice(lookbehindLength);
		}
		return match;
	}

	/**
	 * @param {string} text
	 * @param {LinkedList<string | Token>} tokenList
	 * @param {any} grammar
	 * @param {LinkedListNode<string | Token>} startNode
	 * @param {number} startPos
	 * @param {RematchOptions} [rematch]
	 * @returns {void}
	 * @private
	 *
	 * @typedef RematchOptions
	 * @property {string} cause
	 * @property {number} reach
	 */
	function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
		for (var token in grammar) {
			if (!grammar.hasOwnProperty(token) || !grammar[token]) {
				continue;
			}

			var patterns = grammar[token];
			patterns = Array.isArray(patterns) ? patterns : [patterns];

			for (var j = 0; j < patterns.length; ++j) {
				if (rematch && rematch.cause == token + ',' + j) {
					return;
				}

				var patternObj = patterns[j];
				var inside = patternObj.inside;
				var lookbehind = !!patternObj.lookbehind;
				var greedy = !!patternObj.greedy;
				var alias = patternObj.alias;

				if (greedy && !patternObj.pattern.global) {
					// Without the global flag, lastIndex won't work
					var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
					patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');
				}

				/** @type {RegExp} */
				var pattern = patternObj.pattern || patternObj;

				for ( // iterate the token list and keep track of the current token/string position
					var currentNode = startNode.next, pos = startPos;
					currentNode !== tokenList.tail;
					pos += currentNode.value.length, currentNode = currentNode.next
				) {

					if (rematch && pos >= rematch.reach) {
						break;
					}

					var str = currentNode.value;

					if (tokenList.length > text.length) {
						// Something went terribly wrong, ABORT, ABORT!
						return;
					}

					if (str instanceof Token) {
						continue;
					}

					var removeCount = 1; // this is the to parameter of removeBetween
					var match;

					if (greedy) {
						match = matchPattern(pattern, pos, text, lookbehind);
						if (!match || match.index >= text.length) {
							break;
						}

						var from = match.index;
						var to = match.index + match[0].length;
						var p = pos;

						// find the node that contains the match
						p += currentNode.value.length;
						while (from >= p) {
							currentNode = currentNode.next;
							p += currentNode.value.length;
						}
						// adjust pos (and p)
						p -= currentNode.value.length;
						pos = p;

						// the current node is a Token, then the match starts inside another Token, which is invalid
						if (currentNode.value instanceof Token) {
							continue;
						}

						// find the last node which is affected by this match
						for (
							var k = currentNode;
							k !== tokenList.tail && (p < to || typeof k.value === 'string');
							k = k.next
						) {
							removeCount++;
							p += k.value.length;
						}
						removeCount--;

						// replace with the new match
						str = text.slice(pos, p);
						match.index -= pos;
					} else {
						match = matchPattern(pattern, 0, str, lookbehind);
						if (!match) {
							continue;
						}
					}

					// eslint-disable-next-line no-redeclare
					var from = match.index;
					var matchStr = match[0];
					var before = str.slice(0, from);
					var after = str.slice(from + matchStr.length);

					var reach = pos + str.length;
					if (rematch && reach > rematch.reach) {
						rematch.reach = reach;
					}

					var removeFrom = currentNode.prev;

					if (before) {
						removeFrom = addAfter(tokenList, removeFrom, before);
						pos += before.length;
					}

					removeRange(tokenList, removeFrom, removeCount);

					var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
					currentNode = addAfter(tokenList, removeFrom, wrapped);

					if (after) {
						addAfter(tokenList, currentNode, after);
					}

					if (removeCount > 1) {
						// at least one Token object was removed, so we have to do some rematching
						// this can only happen if the current pattern is greedy

						/** @type {RematchOptions} */
						var nestedRematch = {
							cause: token + ',' + j,
							reach: reach
						};
						matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);

						// the reach might have been extended because of the rematching
						if (rematch && nestedRematch.reach > rematch.reach) {
							rematch.reach = nestedRematch.reach;
						}
					}
				}
			}
		}
	}

	/**
	 * @typedef LinkedListNode
	 * @property {T} value
	 * @property {LinkedListNode<T> | null} prev The previous node.
	 * @property {LinkedListNode<T> | null} next The next node.
	 * @template T
	 * @private
	 */

	/**
	 * @template T
	 * @private
	 */
	function LinkedList() {
		/** @type {LinkedListNode<T>} */
		var head = { value: null, prev: null, next: null };
		/** @type {LinkedListNode<T>} */
		var tail = { value: null, prev: head, next: null };
		head.next = tail;

		/** @type {LinkedListNode<T>} */
		this.head = head;
		/** @type {LinkedListNode<T>} */
		this.tail = tail;
		this.length = 0;
	}

	/**
	 * Adds a new node with the given value to the list.
	 *
	 * @param {LinkedList<T>} list
	 * @param {LinkedListNode<T>} node
	 * @param {T} value
	 * @returns {LinkedListNode<T>} The added node.
	 * @template T
	 */
	function addAfter(list, node, value) {
		// assumes that node != list.tail && values.length >= 0
		var next = node.next;

		var newNode = { value: value, prev: node, next: next };
		node.next = newNode;
		next.prev = newNode;
		list.length++;

		return newNode;
	}
	/**
	 * Removes `count` nodes after the given node. The given node will not be removed.
	 *
	 * @param {LinkedList<T>} list
	 * @param {LinkedListNode<T>} node
	 * @param {number} count
	 * @template T
	 */
	function removeRange(list, node, count) {
		var next = node.next;
		for (var i = 0; i < count && next !== list.tail; i++) {
			next = next.next;
		}
		node.next = next;
		next.prev = node;
		list.length -= i;
	}
	/**
	 * @param {LinkedList<T>} list
	 * @returns {T[]}
	 * @template T
	 */
	function toArray(list) {
		var array = [];
		var node = list.head.next;
		while (node !== list.tail) {
			array.push(node.value);
			node = node.next;
		}
		return array;
	}


	if (!_self.document) {
		if (!_self.addEventListener) {
			// in Node.js
			return _;
		}

		if (!_.disableWorkerMessageHandler) {
			// In worker
			_self.addEventListener('message', function (evt) {
				var message = JSON.parse(evt.data);
				var lang = message.language;
				var code = message.code;
				var immediateClose = message.immediateClose;

				_self.postMessage(_.highlight(code, _.languages[lang], lang));
				if (immediateClose) {
					_self.close();
				}
			}, false);
		}

		return _;
	}

	// Get current script and highlight
	var script = _.util.currentScript();

	if (script) {
		_.filename = script.src;

		if (script.hasAttribute('data-manual')) {
			_.manual = true;
		}
	}

	function highlightAutomaticallyCallback() {
		if (!_.manual) {
			_.highlightAll();
		}
	}

	if (!_.manual) {
		// If the document state is "loading", then we'll use DOMContentLoaded.
		// If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
		// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
		// might take longer one animation frame to execute which can create a race condition where only some plugins have
		// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
		// See https://github.com/PrismJS/prism/issues/2102
		var readyState = document.readyState;
		if (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {
			document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);
		} else {
			if (window.requestAnimationFrame) {
				window.requestAnimationFrame(highlightAutomaticallyCallback);
			} else {
				window.setTimeout(highlightAutomaticallyCallback, 16);
			}
		}
	}

	return _;

}(_self));

if ( true && module.exports) {
	module.exports = Prism;
}

// hack for components to work correctly in node.js
if (typeof __webpack_require__.g !== 'undefined') {
	__webpack_require__.g.Prism = Prism;
}

// some additional documentation/types

/**
 * The expansion of a simple `RegExp` literal to support additional properties.
 *
 * @typedef GrammarToken
 * @property {RegExp} pattern The regular expression of the token.
 * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
 * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
 * @property {boolean} [greedy=false] Whether the token is greedy.
 * @property {string|string[]} [alias] An optional alias or list of aliases.
 * @property {Grammar} [inside] The nested grammar of this token.
 *
 * The `inside` grammar will be used to tokenize the text value of each token of this kind.
 *
 * This can be used to make nested and even recursive language definitions.
 *
 * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
 * each another.
 * @global
 * @public
 */

/**
 * @typedef Grammar
 * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
 * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
 * @global
 * @public
 */

/**
 * A function which will invoked after an element was successfully highlighted.
 *
 * @callback HighlightCallback
 * @param {Element} element The element successfully highlighted.
 * @returns {void}
 * @global
 * @public
 */

/**
 * @callback HookCallback
 * @param {Object<string, any>} env The environment variables of the hook.
 * @returns {void}
 * @global
 * @public
 */


/* **********************************************
     Begin prism-markup.js
********************************************** */

Prism.languages.markup = {
	'comment': {
		pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
		greedy: true
	},
	'prolog': {
		pattern: /<\?[\s\S]+?\?>/,
		greedy: true
	},
	'doctype': {
		// https://www.w3.org/TR/xml/#NT-doctypedecl
		pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
		greedy: true,
		inside: {
			'internal-subset': {
				pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
				lookbehind: true,
				greedy: true,
				inside: null // see below
			},
			'string': {
				pattern: /"[^"]*"|'[^']*'/,
				greedy: true
			},
			'punctuation': /^<!|>$|[[\]]/,
			'doctype-tag': /^DOCTYPE/i,
			'name': /[^\s<>'"]+/
		}
	},
	'cdata': {
		pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
		greedy: true
	},
	'tag': {
		pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
		greedy: true,
		inside: {
			'tag': {
				pattern: /^<\/?[^\s>\/]+/,
				inside: {
					'punctuation': /^<\/?/,
					'namespace': /^[^\s>\/:]+:/
				}
			},
			'special-attr': [],
			'attr-value': {
				pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
				inside: {
					'punctuation': [
						{
							pattern: /^=/,
							alias: 'attr-equals'
						},
						{
							pattern: /^(\s*)["']|["']$/,
							lookbehind: true
						}
					]
				}
			},
			'punctuation': /\/?>/,
			'attr-name': {
				pattern: /[^\s>\/]+/,
				inside: {
					'namespace': /^[^\s>\/:]+:/
				}
			}

		}
	},
	'entity': [
		{
			pattern: /&[\da-z]{1,8};/i,
			alias: 'named-entity'
		},
		/&#x?[\da-f]{1,8};/i
	]
};

Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
	Prism.languages.markup['entity'];
Prism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;

// Plugin to make entity title show the real entity, idea by Roman Komarov
Prism.hooks.add('wrap', function (env) {

	if (env.type === 'entity') {
		env.attributes['title'] = env.content.replace(/&amp;/, '&');
	}
});

Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
	/**
	 * Adds an inlined language to markup.
	 *
	 * An example of an inlined language is CSS with `<style>` tags.
	 *
	 * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
	 * case insensitive.
	 * @param {string} lang The language key.
	 * @example
	 * addInlined('style', 'css');
	 */
	value: function addInlined(tagName, lang) {
		var includedCdataInside = {};
		includedCdataInside['language-' + lang] = {
			pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
			lookbehind: true,
			inside: Prism.languages[lang]
		};
		includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;

		var inside = {
			'included-cdata': {
				pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
				inside: includedCdataInside
			}
		};
		inside['language-' + lang] = {
			pattern: /[\s\S]+/,
			inside: Prism.languages[lang]
		};

		var def = {};
		def[tagName] = {
			pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),
			lookbehind: true,
			greedy: true,
			inside: inside
		};

		Prism.languages.insertBefore('markup', 'cdata', def);
	}
});
Object.defineProperty(Prism.languages.markup.tag, 'addAttribute', {
	/**
	 * Adds an pattern to highlight languages embedded in HTML attributes.
	 *
	 * An example of an inlined language is CSS with `style` attributes.
	 *
	 * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
	 * case insensitive.
	 * @param {string} lang The language key.
	 * @example
	 * addAttribute('style', 'css');
	 */
	value: function (attrName, lang) {
		Prism.languages.markup.tag.inside['special-attr'].push({
			pattern: RegExp(
				/(^|["'\s])/.source + '(?:' + attrName + ')' + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
				'i'
			),
			lookbehind: true,
			inside: {
				'attr-name': /^[^\s=]+/,
				'attr-value': {
					pattern: /=[\s\S]+/,
					inside: {
						'value': {
							pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
							lookbehind: true,
							alias: [lang, 'language-' + lang],
							inside: Prism.languages[lang]
						},
						'punctuation': [
							{
								pattern: /^=/,
								alias: 'attr-equals'
							},
							/"|'/
						]
					}
				}
			}
		});
	}
});

Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;

Prism.languages.xml = Prism.languages.extend('markup', {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;


/* **********************************************
     Begin prism-css.js
********************************************** */

(function (Prism) {

	var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;

	Prism.languages.css = {
		'comment': /\/\*[\s\S]*?\*\//,
		'atrule': {
			pattern: RegExp('@[\\w-](?:' + /[^;{\s"']|\s+(?!\s)/.source + '|' + string.source + ')*?' + /(?:;|(?=\s*\{))/.source),
			inside: {
				'rule': /^@[\w-]+/,
				'selector-function-argument': {
					pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
					lookbehind: true,
					alias: 'selector'
				},
				'keyword': {
					pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
					lookbehind: true
				}
				// See rest below
			}
		},
		'url': {
			// https://drafts.csswg.org/css-values-3/#urls
			pattern: RegExp('\\burl\\((?:' + string.source + '|' + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ')\\)', 'i'),
			greedy: true,
			inside: {
				'function': /^url/i,
				'punctuation': /^\(|\)$/,
				'string': {
					pattern: RegExp('^' + string.source + '$'),
					alias: 'url'
				}
			}
		},
		'selector': {
			pattern: RegExp('(^|[{}\\s])[^{}\\s](?:[^{};"\'\\s]|\\s+(?![\\s{])|' + string.source + ')*(?=\\s*\\{)'),
			lookbehind: true
		},
		'string': {
			pattern: string,
			greedy: true
		},
		'property': {
			pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
			lookbehind: true
		},
		'important': /!important\b/i,
		'function': {
			pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
			lookbehind: true
		},
		'punctuation': /[(){};:,]/
	};

	Prism.languages.css['atrule'].inside.rest = Prism.languages.css;

	var markup = Prism.languages.markup;
	if (markup) {
		markup.tag.addInlined('style', 'css');
		markup.tag.addAttribute('style', 'css');
	}

}(Prism));


/* **********************************************
     Begin prism-clike.js
********************************************** */

Prism.languages.clike = {
	'comment': [
		{
			pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
			lookbehind: true,
			greedy: true
		},
		{
			pattern: /(^|[^\\:])\/\/.*/,
			lookbehind: true,
			greedy: true
		}
	],
	'string': {
		pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
		greedy: true
	},
	'class-name': {
		pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
		lookbehind: true,
		inside: {
			'punctuation': /[.\\]/
		}
	},
	'keyword': /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
	'boolean': /\b(?:false|true)\b/,
	'function': /\b\w+(?=\()/,
	'number': /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
	'operator': /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
	'punctuation': /[{}[\];(),.:]/
};


/* **********************************************
     Begin prism-javascript.js
********************************************** */

Prism.languages.javascript = Prism.languages.extend('clike', {
	'class-name': [
		Prism.languages.clike['class-name'],
		{
			pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
			lookbehind: true
		}
	],
	'keyword': [
		{
			pattern: /((?:^|\})\s*)catch\b/,
			lookbehind: true
		},
		{
			pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
			lookbehind: true
		},
	],
	// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
	'function': /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
	'number': {
		pattern: RegExp(
			/(^|[^\w$])/.source +
			'(?:' +
			(
				// constant
				/NaN|Infinity/.source +
				'|' +
				// binary integer
				/0[bB][01]+(?:_[01]+)*n?/.source +
				'|' +
				// octal integer
				/0[oO][0-7]+(?:_[0-7]+)*n?/.source +
				'|' +
				// hexadecimal integer
				/0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source +
				'|' +
				// decimal bigint
				/\d+(?:_\d+)*n/.source +
				'|' +
				// decimal number (integer or float) but no bigint
				/(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source
			) +
			')' +
			/(?![\w$])/.source
		),
		lookbehind: true
	},
	'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});

Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;

Prism.languages.insertBefore('javascript', 'keyword', {
	'regex': {
		pattern: RegExp(
			// lookbehind
			// eslint-disable-next-line regexp/no-dupe-characters-character-class
			/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source +
			// Regex pattern:
			// There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
			// classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
			// with the only syntax, so we have to define 2 different regex patterns.
			/\//.source +
			'(?:' +
			/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source +
			'|' +
			// `v` flag syntax. This supports 3 levels of nested character classes.
			/(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source +
			')' +
			// lookahead
			/(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
		),
		lookbehind: true,
		greedy: true,
		inside: {
			'regex-source': {
				pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
				lookbehind: true,
				alias: 'language-regex',
				inside: Prism.languages.regex
			},
			'regex-delimiter': /^\/|\/$/,
			'regex-flags': /^[a-z]+$/,
		}
	},
	// This must be declared before keyword because we use "function" inside the look-forward
	'function-variable': {
		pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
		alias: 'function'
	},
	'parameter': [
		{
			pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
			lookbehind: true,
			inside: Prism.languages.javascript
		},
		{
			pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
			lookbehind: true,
			inside: Prism.languages.javascript
		},
		{
			pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
			lookbehind: true,
			inside: Prism.languages.javascript
		},
		{
			pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
			lookbehind: true,
			inside: Prism.languages.javascript
		}
	],
	'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});

Prism.languages.insertBefore('javascript', 'string', {
	'hashbang': {
		pattern: /^#!.*/,
		greedy: true,
		alias: 'comment'
	},
	'template-string': {
		pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
		greedy: true,
		inside: {
			'template-punctuation': {
				pattern: /^`|`$/,
				alias: 'string'
			},
			'interpolation': {
				pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
				lookbehind: true,
				inside: {
					'interpolation-punctuation': {
						pattern: /^\$\{|\}$/,
						alias: 'punctuation'
					},
					rest: Prism.languages.javascript
				}
			},
			'string': /[\s\S]+/
		}
	},
	'string-property': {
		pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
		lookbehind: true,
		greedy: true,
		alias: 'property'
	}
});

Prism.languages.insertBefore('javascript', 'operator', {
	'literal-property': {
		pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
		lookbehind: true,
		alias: 'property'
	},
});

if (Prism.languages.markup) {
	Prism.languages.markup.tag.addInlined('script', 'javascript');

	// add attribute support for all DOM events.
	// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events
	Prism.languages.markup.tag.addAttribute(
		/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
		'javascript'
	);
}

Prism.languages.js = Prism.languages.javascript;


/* **********************************************
     Begin prism-file-highlight.js
********************************************** */

(function () {

	if (typeof Prism === 'undefined' || typeof document === 'undefined') {
		return;
	}

	// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill
	if (!Element.prototype.matches) {
		Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
	}

	var LOADING_MESSAGE = 'Loading…';
	var FAILURE_MESSAGE = function (status, message) {
		return '✖ Error ' + status + ' while fetching file: ' + message;
	};
	var FAILURE_EMPTY_MESSAGE = '✖ Error: File does not exist or is empty';

	var EXTENSIONS = {
		'js': 'javascript',
		'py': 'python',
		'rb': 'ruby',
		'ps1': 'powershell',
		'psm1': 'powershell',
		'sh': 'bash',
		'bat': 'batch',
		'h': 'c',
		'tex': 'latex'
	};

	var STATUS_ATTR = 'data-src-status';
	var STATUS_LOADING = 'loading';
	var STATUS_LOADED = 'loaded';
	var STATUS_FAILED = 'failed';

	var SELECTOR = 'pre[data-src]:not([' + STATUS_ATTR + '="' + STATUS_LOADED + '"])'
		+ ':not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';

	/**
	 * Loads the given file.
	 *
	 * @param {string} src The URL or path of the source file to load.
	 * @param {(result: string) => void} success
	 * @param {(reason: string) => void} error
	 */
	function loadFile(src, success, error) {
		var xhr = new XMLHttpRequest();
		xhr.open('GET', src, true);
		xhr.onreadystatechange = function () {
			if (xhr.readyState == 4) {
				if (xhr.status < 400 && xhr.responseText) {
					success(xhr.responseText);
				} else {
					if (xhr.status >= 400) {
						error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
					} else {
						error(FAILURE_EMPTY_MESSAGE);
					}
				}
			}
		};
		xhr.send(null);
	}

	/**
	 * Parses the given range.
	 *
	 * This returns a range with inclusive ends.
	 *
	 * @param {string | null | undefined} range
	 * @returns {[number, number | undefined] | undefined}
	 */
	function parseRange(range) {
		var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || '');
		if (m) {
			var start = Number(m[1]);
			var comma = m[2];
			var end = m[3];

			if (!comma) {
				return [start, start];
			}
			if (!end) {
				return [start, undefined];
			}
			return [start, Number(end)];
		}
		return undefined;
	}

	Prism.hooks.add('before-highlightall', function (env) {
		env.selector += ', ' + SELECTOR;
	});

	Prism.hooks.add('before-sanity-check', function (env) {
		var pre = /** @type {HTMLPreElement} */ (env.element);
		if (pre.matches(SELECTOR)) {
			env.code = ''; // fast-path the whole thing and go to complete

			pre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading

			// add code element with loading message
			var code = pre.appendChild(document.createElement('CODE'));
			code.textContent = LOADING_MESSAGE;

			var src = pre.getAttribute('data-src');

			var language = env.language;
			if (language === 'none') {
				// the language might be 'none' because there is no language set;
				// in this case, we want to use the extension as the language
				var extension = (/\.(\w+)$/.exec(src) || [, 'none'])[1];
				language = EXTENSIONS[extension] || extension;
			}

			// set language classes
			Prism.util.setLanguage(code, language);
			Prism.util.setLanguage(pre, language);

			// preload the language
			var autoloader = Prism.plugins.autoloader;
			if (autoloader) {
				autoloader.loadLanguages(language);
			}

			// load file
			loadFile(
				src,
				function (text) {
					// mark as loaded
					pre.setAttribute(STATUS_ATTR, STATUS_LOADED);

					// handle data-range
					var range = parseRange(pre.getAttribute('data-range'));
					if (range) {
						var lines = text.split(/\r\n?|\n/g);

						// the range is one-based and inclusive on both ends
						var start = range[0];
						var end = range[1] == null ? lines.length : range[1];

						if (start < 0) { start += lines.length; }
						start = Math.max(0, Math.min(start - 1, lines.length));
						if (end < 0) { end += lines.length; }
						end = Math.max(0, Math.min(end, lines.length));

						text = lines.slice(start, end).join('\n');

						// add data-start for line numbers
						if (!pre.hasAttribute('data-start')) {
							pre.setAttribute('data-start', String(start + 1));
						}
					}

					// highlight code
					code.textContent = text;
					Prism.highlightElement(code);
				},
				function (error) {
					// mark as failed
					pre.setAttribute(STATUS_ATTR, STATUS_FAILED);

					code.textContent = error;
				}
			);
		}
	});

	Prism.plugins.fileHighlight = {
		/**
		 * Executes the File Highlight plugin for all matching `pre` elements under the given container.
		 *
		 * Note: Elements which are already loaded or currently loading will not be touched by this method.
		 *
		 * @param {ParentNode} [container=document]
		 */
		highlight: function highlight(container) {
			var elements = (container || document).querySelectorAll(SELECTOR);

			for (var i = 0, element; (element = elements[i++]);) {
				Prism.highlightElement(element);
			}
		}
	};

	var logged = false;
	/** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */
	Prism.fileHighlight = function () {
		if (!logged) {
			console.warn('Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.');
			logged = true;
		}
		Prism.plugins.fileHighlight.highlight.apply(this, arguments);
	};

}());


/***/ }),

/***/ "./node_modules/svelte-hmr/runtime/hot-api.js":
/*!****************************************************!*\
  !*** ./node_modules/svelte-hmr/runtime/hot-api.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   makeApplyHmr: () => (/* binding */ makeApplyHmr)
/* harmony export */ });
/* harmony import */ var _proxy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./proxy.js */ "./node_modules/svelte-hmr/runtime/proxy.js");
/* eslint-env browser */



const logPrefix = '[HMR:Svelte]'

// eslint-disable-next-line no-console
const log = (...args) => console.log(logPrefix, ...args)

const domReload = () => {
  // eslint-disable-next-line no-undef
  const win = typeof window !== 'undefined' && window
  if (win && win.location && win.location.reload) {
    log('Reload')
    win.location.reload()
  } else {
    log('Full reload required')
  }
}

const replaceCss = (previousId, newId) => {
  if (typeof document === 'undefined') return false
  if (!previousId) return false
  if (!newId) return false
  // svelte-xxx-style => svelte-xxx
  const previousClass = previousId.slice(0, -6)
  const newClass = newId.slice(0, -6)
  // eslint-disable-next-line no-undef
  document.querySelectorAll('.' + previousClass).forEach(el => {
    el.classList.remove(previousClass)
    el.classList.add(newClass)
  })
  return true
}

const removeStylesheet = cssId => {
  if (cssId == null) return
  if (typeof document === 'undefined') return
  // eslint-disable-next-line no-undef
  const el = document.getElementById(cssId)
  if (el) el.remove()
  return
}

const defaultArgs = {
  reload: domReload,
}

const makeApplyHmr = transformArgs => args => {
  const allArgs = transformArgs({ ...defaultArgs, ...args })
  return applyHmr(allArgs)
}

let needsReload = false

function applyHmr(args) {
  const {
    id,
    cssId,
    nonCssHash,
    reload = domReload,
    // normalized hot API (must conform to rollup-plugin-hot)
    hot,
    hotOptions,
    Component,
    acceptable, // some types of components are impossible to HMR correctly
    preserveLocalState,
    ProxyAdapter,
    emitCss,
  } = args

  const existing = hot.data && hot.data.record

  const canAccept = acceptable && (!existing || existing.current.canAccept)

  const r =
    existing ||
    (0,_proxy_js__WEBPACK_IMPORTED_MODULE_0__.createProxy)({
      Adapter: ProxyAdapter,
      id,
      Component,
      hotOptions,
      canAccept,
      preserveLocalState,
    })

  const cssOnly =
    hotOptions.injectCss &&
    existing &&
    nonCssHash &&
    existing.current.nonCssHash === nonCssHash

  r.update({
    Component,
    hotOptions,
    canAccept,
    nonCssHash,
    cssId,
    previousCssId: r.current.cssId,
    cssOnly,
    preserveLocalState,
  })

  hot.dispose(data => {
    // handle previous fatal errors
    if (needsReload || (0,_proxy_js__WEBPACK_IMPORTED_MODULE_0__.hasFatalError)()) {
      if (hotOptions && hotOptions.noReload) {
        log('Full reload required')
      } else {
        reload()
      }
    }

    // 2020-09-21 Snowpack master doesn't pass data as arg to dispose handler
    data = data || hot.data

    data.record = r

    if (!emitCss && cssId && r.current.cssId !== cssId) {
      if (hotOptions.cssEjectDelay) {
        setTimeout(() => removeStylesheet(cssId), hotOptions.cssEjectDelay)
      } else {
        removeStylesheet(cssId)
      }
    }
  })

  if (canAccept) {
    hot.accept(async arg => {
      const { bubbled } = arg || {}

      // NOTE Snowpack registers accept handlers only once, so we can NOT rely
      // on the surrounding scope variables -- they're not the last version!
      const { cssId: newCssId, previousCssId } = r.current
      const cssChanged = newCssId !== previousCssId
      // ensure old style sheet has been removed by now
      if (!emitCss && cssChanged) removeStylesheet(previousCssId)
      // guard: css only change
      if (
        // NOTE bubbled is provided only by rollup-plugin-hot, and we
        // can't safely assume a CSS only change without it... this means we
        // can't support CSS only injection with Nollup or Webpack currently
        bubbled === false && // WARNING check false, not falsy!
        r.current.cssOnly &&
        (!cssChanged || replaceCss(previousCssId, newCssId))
      ) {
        return
      }

      const success = await r.reload()

      if ((0,_proxy_js__WEBPACK_IMPORTED_MODULE_0__.hasFatalError)() || (!success && !hotOptions.optimistic)) {
        needsReload = true
      }
    })
  }

  // well, endgame... we won't be able to render next updates, even successful,
  // if we don't have proxies in svelte's tree
  //
  // since we won't return the proxy and the app will expect a svelte component,
  // it's gonna crash... so it's best to report the real cause
  //
  // full reload required
  //
  const proxyOk = r && r.proxy
  if (!proxyOk) {
    throw new Error(`Failed to create HMR proxy for Svelte component ${id}`)
  }

  return r.proxy
}


/***/ }),

/***/ "./node_modules/svelte-hmr/runtime/index.js":
/*!**************************************************!*\
  !*** ./node_modules/svelte-hmr/runtime/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   makeApplyHmr: () => (/* reexport safe */ _hot_api_js__WEBPACK_IMPORTED_MODULE_0__.makeApplyHmr)
/* harmony export */ });
/* harmony import */ var _hot_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hot-api.js */ "./node_modules/svelte-hmr/runtime/hot-api.js");



/***/ }),

/***/ "./node_modules/svelte-hmr/runtime/overlay.js":
/*!****************************************************!*\
  !*** ./node_modules/svelte-hmr/runtime/overlay.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* eslint-env browser */

const removeElement = el => el && el.parentNode && el.parentNode.removeChild(el)

const ErrorOverlay = () => {
  let errors = []
  let compileError = null

  const errorsTitle = 'Failed to init component'
  const compileErrorTitle = 'Failed to compile'

  const style = {
    section: `
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 32px;
      background: rgba(0, 0, 0, .85);
      font-family: Menlo, Consolas, monospace;
      font-size: large;
      color: rgb(232, 232, 232);
      overflow: auto;
      z-index: 2147483647;
    `,
    h1: `
      margin-top: 0;
      color: #E36049;
      font-size: large;
      font-weight: normal;
    `,
    h2: `
      margin: 32px 0 0;
      font-size: large;
      font-weight: normal;
    `,
    pre: ``,
  }

  const createOverlay = () => {
    const h1 = document.createElement('h1')
    h1.style = style.h1
    const section = document.createElement('section')
    section.appendChild(h1)
    section.style = style.section
    const body = document.createElement('div')
    section.appendChild(body)
    return { h1, el: section, body }
  }

  const setTitle = title => {
    overlay.h1.textContent = title
  }

  const show = () => {
    const { el } = overlay
    if (!el.parentNode) {
      const target = document.body
      target.appendChild(overlay.el)
    }
  }

  const hide = () => {
    const { el } = overlay
    if (el.parentNode) {
      overlay.el.remove()
    }
  }

  const update = () => {
    if (compileError) {
      overlay.body.innerHTML = ''
      setTitle(compileErrorTitle)
      const errorEl = renderError(compileError)
      overlay.body.appendChild(errorEl)
      show()
    } else if (errors.length > 0) {
      overlay.body.innerHTML = ''
      setTitle(errorsTitle)
      errors.forEach(({ title, message }) => {
        const errorEl = renderError(message, title)
        overlay.body.appendChild(errorEl)
      })
      show()
    } else {
      hide()
    }
  }

  const renderError = (message, title) => {
    const div = document.createElement('div')
    if (title) {
      const h2 = document.createElement('h2')
      h2.textContent = title
      h2.style = style.h2
      div.appendChild(h2)
    }
    const pre = document.createElement('pre')
    pre.textContent = message
    div.appendChild(pre)
    return div
  }

  const addError = (error, title) => {
    const message = (error && error.stack) || error
    errors.push({ title, message })
    update()
  }

  const clearErrors = () => {
    errors.forEach(({ element }) => {
      removeElement(element)
    })
    errors = []
    update()
  }

  const setCompileError = message => {
    compileError = message
    update()
  }

  const overlay = createOverlay()

  return {
    addError,
    clearErrors,
    setCompileError,
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ErrorOverlay);


/***/ }),

/***/ "./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js":
/*!**************************************************************!*\
  !*** ./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   adapter: () => (/* binding */ adapter),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var _overlay_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./overlay.js */ "./node_modules/svelte-hmr/runtime/overlay.js");
/* global window, document */

// NOTE from 3.38.3 (or so), insert was carrying the hydration logic, that must
// be used because DOM elements are reused more (and so insertion points are not
// necessarily added in order); then in 3.40 the logic was moved to
// insert_hydration, which is the one we must use for HMR
const svelteInsert = svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_hydration || svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert
if (!svelteInsert) {
  throw new Error(
    'failed to find insert_hydration and insert in svelte/internal'
  )
}



const removeElement = el => el && el.parentNode && el.parentNode.removeChild(el)

const adapter = class ProxyAdapterDom {
  constructor(instance) {
    this.instance = instance
    this.insertionPoint = null

    this.afterMount = this.afterMount.bind(this)
    this.rerender = this.rerender.bind(this)

    this._noOverlay = !!instance.hotOptions.noOverlay
  }

  // NOTE overlay is only created before being actually shown to help test
  // runner (it won't have to account for error overlay when running assertions
  // about the contents of the rendered page)
  static getErrorOverlay(noCreate = false) {
    if (!noCreate && !this.errorOverlay) {
      this.errorOverlay = (0,_overlay_js__WEBPACK_IMPORTED_MODULE_1__["default"])()
    }
    return this.errorOverlay
  }

  // TODO this is probably unused now: remove in next breaking release
  static renderCompileError(message) {
    const noCreate = !message
    const overlay = this.getErrorOverlay(noCreate)
    if (!overlay) return
    overlay.setCompileError(message)
  }

  dispose() {
    // Component is being destroyed, detaching is not optional in Svelte3's
    // component API, so we can dispose of the insertion point in every case.
    if (this.insertionPoint) {
      removeElement(this.insertionPoint)
      this.insertionPoint = null
    }
    this.clearError()
  }

  // NOTE afterMount CAN be called multiple times (e.g. keyed list)
  afterMount(target, anchor) {
    const {
      instance: { debugName },
    } = this
    if (!this.insertionPoint) {
      this.insertionPoint = document.createComment(debugName)
    }
    svelteInsert(target, this.insertionPoint, anchor)
  }

  rerender() {
    this.clearError()
    const {
      instance: { refreshComponent },
      insertionPoint,
    } = this
    if (!insertionPoint) {
      throw new Error('Cannot rerender: missing insertion point')
    }
    refreshComponent(insertionPoint.parentNode, insertionPoint)
  }

  renderError(err) {
    if (this._noOverlay) return
    const {
      instance: { debugName },
    } = this
    const title = debugName || err.moduleName || 'Error'
    this.constructor.getErrorOverlay().addError(err, title)
  }

  clearError() {
    if (this._noOverlay) return
    const overlay = this.constructor.getErrorOverlay(true)
    if (!overlay) return
    overlay.clearErrors()
  }
}

// TODO this is probably unused now: remove in next breaking release
if (typeof window !== 'undefined') {
  window.__SVELTE_HMR_ADAPTER = adapter
}

// mitigate situation with Snowpack remote source pulling latest of runtime,
// but using previous version of the Node code transform in the plugin
// see: https://github.com/rixo/svelte-hmr/issues/27
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (adapter);


/***/ }),

/***/ "./node_modules/svelte-hmr/runtime/proxy.js":
/*!**************************************************!*\
  !*** ./node_modules/svelte-hmr/runtime/proxy.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createProxy: () => (/* binding */ createProxy),
/* harmony export */   hasFatalError: () => (/* binding */ hasFatalError)
/* harmony export */ });
/* harmony import */ var _svelte_hooks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./svelte-hooks.js */ "./node_modules/svelte-hmr/runtime/svelte-hooks.js");
/* eslint-env browser */
/**
 * The HMR proxy is a component-like object whose task is to sit in the
 * component tree in place of the proxied component, and rerender each
 * successive versions of said component.
 */



const handledMethods = ['constructor', '$destroy']
const forwardedMethods = ['$set', '$on']

const logError = (msg, err) => {
  // eslint-disable-next-line no-console
  console.error('[HMR][Svelte]', msg)
  if (err) {
    // NOTE avoid too much wrapping around user errors
    // eslint-disable-next-line no-console
    console.error(err)
  }
}

const posixify = file => file.replace(/[/\\]/g, '/')

const getBaseName = id =>
  id
    .split('/')
    .pop()
    .split('.')
    .slice(0, -1)
    .join('.')

const capitalize = str => str[0].toUpperCase() + str.slice(1)

const getFriendlyName = id => capitalize(getBaseName(posixify(id)))

const getDebugName = id => `<${getFriendlyName(id)}>`

const relayCalls = (getTarget, names, dest = {}) => {
  for (const key of names) {
    dest[key] = function(...args) {
      const target = getTarget()
      if (!target) {
        return
      }
      return target[key] && target[key].call(this, ...args)
    }
  }
  return dest
}

const isInternal = key => key !== '$$' && key.slice(0, 2) === '$$'

// This is intented as a somewhat generic / prospective fix to the situation
// that arised with the introduction of $$set in Svelte 3.24.1 -- trying to
// avoid giving full knowledge (like its name) of this implementation detail
// to the proxy. The $$set method can be present or not on the component, and
// its presence impacts the behaviour (but with HMR it will be tested if it is
// present _on the proxy_). So the idea here is to expose exactly the same $$
// props as the current version of the component and, for those that are
// functions, proxy the calls to the current component.
const relayInternalMethods = (proxy, cmp) => {
  // delete any previously added $$ prop
  Object.keys(proxy)
    .filter(isInternal)
    .forEach(key => {
      delete proxy[key]
    })
  // guard: no component
  if (!cmp) return
  // proxy current $$ props to the actual component
  Object.keys(cmp)
    .filter(isInternal)
    .forEach(key => {
      Object.defineProperty(proxy, key, {
        configurable: true,
        get() {
          const value = cmp[key]
          if (typeof value !== 'function') return value
          return (
            value &&
            function(...args) {
              return value.apply(this, args)
            }
          )
        },
      })
    })
}

// proxy custom methods
const copyComponentProperties = (proxy, cmp, previous) => {
  if (previous) {
    previous.forEach(prop => {
      delete proxy[prop]
    })
  }

  const props = Object.getOwnPropertyNames(Object.getPrototypeOf(cmp))
  const wrappedProps = props.filter(prop => {
    if (!handledMethods.includes(prop) && !forwardedMethods.includes(prop)) {
      Object.defineProperty(proxy, prop, {
        configurable: true,
        get() {
          return cmp[prop]
        },
        set(value) {
          // we're changing it on the real component first to see what it
          // gives... if it throws an error, we want to throw the same error in
          // order to most closely follow non-hmr behaviour.
          cmp[prop] = value
        },
      })
      return true
    }
  })

  return wrappedProps
}

// everything in the constructor!
//
// so we don't polute the component class with new members
//
class ProxyComponent {
  constructor(
    {
      Adapter,
      id,
      debugName,
      current, // { Component, hotOptions: { preserveLocalState, ... } }
      register,
    },
    options // { target, anchor, ... }
  ) {
    let cmp
    let disposed = false
    let lastError = null

    const setComponent = _cmp => {
      cmp = _cmp
      relayInternalMethods(this, cmp)
    }

    const getComponent = () => cmp

    const destroyComponent = () => {
      // destroyComponent is tolerant (don't crash on no cmp) because it
      // is possible that reload/rerender is called after a previous
      // createComponent has failed (hence we have a proxy, but no cmp)
      if (cmp) {
        cmp.$destroy()
        setComponent(null)
      }
    }

    const refreshComponent = (target, anchor, conservativeDestroy) => {
      if (lastError) {
        lastError = null
        adapter.rerender()
      } else {
        try {
          const replaceOptions = {
            target,
            anchor,
            preserveLocalState: current.preserveLocalState,
          }
          if (conservativeDestroy) {
            replaceOptions.conservativeDestroy = true
          }
          cmp.$replace(current.Component, replaceOptions)
        } catch (err) {
          setError(err, target, anchor)
          if (
            !current.hotOptions.optimistic ||
            // non acceptable components (that is components that have to defer
            // to their parent for rerender -- e.g. accessors, named exports)
            // are most tricky, and they havent been considered when most of the
            // code has been written... as a result, they are especially tricky
            // to deal with, it's better to consider any error with them to be
            // fatal to avoid odities
            !current.canAccept ||
            (err && err.hmrFatal)
          ) {
            throw err
          } else {
            // const errString = String((err && err.stack) || err)
            logError(`Error during component init: ${debugName}`, err)
          }
        }
      }
    }

    const setError = err => {
      lastError = err
      adapter.renderError(err)
    }

    const instance = {
      hotOptions: current.hotOptions,
      proxy: this,
      id,
      debugName,
      refreshComponent,
    }

    const adapter = new Adapter(instance)

    const { afterMount, rerender } = adapter

    // $destroy is not called when a child component is disposed, so we
    // need to hook from fragment.
    const onDestroy = () => {
      // NOTE do NOT call $destroy on the cmp from here; the cmp is already
      //   dead, this would not work
      if (!disposed) {
        disposed = true
        adapter.dispose()
        unregister()
      }
    }

    // ---- register proxy instance ----

    const unregister = register(rerender)

    // ---- augmented methods ----

    this.$destroy = () => {
      destroyComponent()
      onDestroy()
    }

    // ---- forwarded methods ----

    relayCalls(getComponent, forwardedMethods, this)

    // ---- create & mount target component instance ---

    try {
      let lastProperties
      ;(0,_svelte_hooks_js__WEBPACK_IMPORTED_MODULE_0__.createProxiedComponent)(current.Component, options, {
        allowLiveBinding: current.hotOptions.allowLiveBinding,
        onDestroy,
        onMount: afterMount,
        onInstance: comp => {
          setComponent(comp)
          // WARNING the proxy MUST use the same $$ object as its component
          // instance, because a lot of wiring happens during component
          // initialisation... lots of references to $$ and $$.fragment have
          // already been distributed around when the component constructor
          // returns, before we have a chance to wrap them (and so we can't
          // wrap them no more, because existing references would become
          // invalid)
          this.$$ = comp.$$
          lastProperties = copyComponentProperties(this, comp, lastProperties)
        },
      })
    } catch (err) {
      const { target, anchor } = options
      setError(err, target, anchor)
      throw err
    }
  }
}

const syncStatics = (component, proxy, previousKeys) => {
  // remove previously copied keys
  if (previousKeys) {
    for (const key of previousKeys) {
      delete proxy[key]
    }
  }

  // forward static properties and methods
  const keys = []
  for (const key in component) {
    keys.push(key)
    proxy[key] = component[key]
  }

  return keys
}

const globalListeners = {}

const onGlobal = (event, fn) => {
  event = event.toLowerCase()
  if (!globalListeners[event]) globalListeners[event] = []
  globalListeners[event].push(fn)
}

const fireGlobal = (event, ...args) => {
  const listeners = globalListeners[event]
  if (!listeners) return
  for (const fn of listeners) {
    fn(...args)
  }
}

const fireBeforeUpdate = () => fireGlobal('beforeupdate')

const fireAfterUpdate = () => fireGlobal('afterupdate')

if (typeof window !== 'undefined') {
  window.__SVELTE_HMR = {
    on: onGlobal,
  }
  window.dispatchEvent(new CustomEvent('svelte-hmr:ready'))
}

let fatalError = false

const hasFatalError = () => fatalError

/**
 * Creates a HMR proxy and its associated `reload` function that pushes a new
 * version to all existing instances of the component.
 */
function createProxy({
  Adapter,
  id,
  Component,
  hotOptions,
  canAccept,
  preserveLocalState,
}) {
  const debugName = getDebugName(id)
  const instances = []

  // current object will be updated, proxy instances will keep a ref
  const current = {
    Component,
    hotOptions,
    canAccept,
    preserveLocalState,
  }

  const name = `Proxy${debugName}`

  // this trick gives the dynamic name Proxy<MyComponent> to the concrete
  // proxy class... unfortunately, this doesn't shows in dev tools, but
  // it stills allow to inspect cmp.constructor.name to confirm an instance
  // is a proxy
  const proxy = {
    [name]: class extends ProxyComponent {
      constructor(options) {
        try {
          super(
            {
              Adapter,
              id,
              debugName,
              current,
              register: rerender => {
                instances.push(rerender)
                const unregister = () => {
                  const i = instances.indexOf(rerender)
                  instances.splice(i, 1)
                }
                return unregister
              },
            },
            options
          )
        } catch (err) {
          // If we fail to create a proxy instance, any instance, that means
          // that we won't be able to fix this instance when it is updated.
          // Recovering to normal state will be impossible. HMR's dead.
          //
          // Fatal error will trigger a full reload on next update (reloading
          // right now is kinda pointless since buggy code still exists).
          //
          // NOTE Only report first error to avoid too much polution -- following
          // errors are probably caused by the first one, or they will show up
          // in turn when the first one is fixed ¯\_(ツ)_/¯
          //
          if (!fatalError) {
            fatalError = true
            logError(
              `Unrecoverable HMR error in ${debugName}: ` +
                `next update will trigger a full reload`
            )
          }
          throw err
        }
      }
    },
  }[name]

  // initialize static members
  let previousStatics = syncStatics(current.Component, proxy)

  const update = newState => Object.assign(current, newState)

  // reload all existing instances of this component
  const reload = () => {
    fireBeforeUpdate()

    // copy statics before doing anything because a static prop/method
    // could be used somewhere in the create/render call
    previousStatics = syncStatics(current.Component, proxy, previousStatics)

    const errors = []

    instances.forEach(rerender => {
      try {
        rerender()
      } catch (err) {
        logError(`Failed to rerender ${debugName}`, err)
        errors.push(err)
      }
    })

    if (errors.length > 0) {
      return false
    }

    fireAfterUpdate()

    return true
  }

  const hasFatalError = () => fatalError

  return { id, proxy, update, reload, hasFatalError, current }
}


/***/ }),

/***/ "./node_modules/svelte-hmr/runtime/svelte-hooks.js":
/*!*********************************************************!*\
  !*** ./node_modules/svelte-hmr/runtime/svelte-hooks.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createProxiedComponent: () => (/* binding */ createProxiedComponent)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/**
 * Emulates forthcoming HMR hooks in Svelte.
 *
 * All references to private component state ($$) are now isolated in this
 * module.
 */


const captureState = cmp => {
  // sanity check: propper behaviour here is to crash noisily so that
  // user knows that they're looking at something broken
  if (!cmp) {
    throw new Error('Missing component')
  }
  if (!cmp.$$) {
    throw new Error('Invalid component')
  }

  const {
    $$: { callbacks, bound, ctx, props },
  } = cmp

  const state = cmp.$capture_state()

  // capturing current value of props (or we'll recreate the component with the
  // initial prop values, that may have changed -- and would not be reflected in
  // options.props)
  const hmr_props_values = {}
  Object.keys(cmp.$$.props).forEach(prop => {
    hmr_props_values[prop] = ctx[props[prop]]
  })

  return {
    ctx,
    props,
    callbacks,
    bound,
    state,
    hmr_props_values,
  }
}

// remapping all existing bindings (including hmr_future_foo ones) to the
// new version's props indexes, and refresh them with the new value from
// context
const restoreBound = (cmp, restore) => {
  // reverse prop:ctxIndex in $$.props to ctxIndex:prop
  //
  // ctxIndex can be either a regular index in $$.ctx or a hmr_future_ prop
  //
  const propsByIndex = {}
  for (const [name, i] of Object.entries(restore.props)) {
    propsByIndex[i] = name
  }

  // NOTE $$.bound cannot change in the HMR lifetime of a component, because
  //      if bindings changes, that means the parent component has changed,
  //      which means the child (current) component will be wholly recreated
  for (const [oldIndex, updateBinding] of Object.entries(restore.bound)) {
    // can be either regular prop, or future_hmr_ prop
    const propName = propsByIndex[oldIndex]

    // this should never happen if remembering of future props is enabled...
    // in any case, there's nothing we can do about it if we have lost prop
    // name knowledge at this point
    if (propName == null) continue

    // NOTE $$.props[propName] also propagates knowledge of a possible
    //      future prop to the new $$.props (via $$.props being a Proxy)
    const newIndex = cmp.$$.props[propName]
    cmp.$$.bound[newIndex] = updateBinding

    // NOTE if the prop doesn't exist or doesn't exist anymore in the new
    //      version of the component, clearing the binding is the expected
    //      behaviour (since that's what would happen in non HMR code)
    const newValue = cmp.$$.ctx[newIndex]
    updateBinding(newValue)
  }
}

// restoreState
//
// It is too late to restore context at this point because component instance
// function has already been called (and so context has already been read).
// Instead, we rely on setting current_component to the same value it has when
// the component was first rendered -- which fix support for context, and is
// also generally more respectful of normal operation.
//
const restoreState = (cmp, restore) => {
  if (!restore) return

  if (restore.callbacks) {
    cmp.$$.callbacks = restore.callbacks
  }

  if (restore.bound) {
    restoreBound(cmp, restore)
  }

  // props, props.$$slots are restored at component creation (works
  // better -- well, at all actually)
}

const get_current_component_safe = () => {
  // NOTE relying on dynamic bindings (current_component) makes us dependent on
  // bundler config (and apparently it does not work in demo-svelte-nollup)
  try {
    // unfortunately, unlike current_component, get_current_component() can
    // crash in the normal path (when there is really no parent)
    return (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_current_component)()
  } catch (err) {
    // ... so we need to consider that this error means that there is no parent
    //
    // that makes us tightly coupled to the error message but, at least, we
    // won't mute an unexpected error, which is quite a horrible thing to do
    if (err.message === 'Function called outside component initialization') {
      // who knows...
      return svelte_internal__WEBPACK_IMPORTED_MODULE_0__.current_component
    } else {
      throw err
    }
  }
}

const createProxiedComponent = (
  Component,
  initialOptions,
  { allowLiveBinding, onInstance, onMount, onDestroy }
) => {
  let cmp
  let options = initialOptions

  const isCurrent = _cmp => cmp === _cmp

  const assignOptions = (target, anchor, restore, preserveLocalState) => {
    const props = Object.assign({}, options.props)

    // Filtering props to avoid "unexpected prop" warning
    // NOTE this is based on props present in initial options, but it should
    //      always works, because props that are passed from the parent can't
    //      change without a code change to the parent itself -- hence, the
    //      child component will be fully recreated, and initial options should
    //      always represent props that are currnetly passed by the parent
    if (options.props && restore.hmr_props_values) {
      for (const prop of Object.keys(options.props)) {
        if (restore.hmr_props_values.hasOwnProperty(prop)) {
          props[prop] = restore.hmr_props_values[prop]
        }
      }
    }

    if (preserveLocalState && restore.state) {
      if (Array.isArray(preserveLocalState)) {
        // form ['a', 'b'] => preserve only 'a' and 'b'
        props.$$inject = {}
        for (const key of preserveLocalState) {
          props.$$inject[key] = restore.state[key]
        }
      } else {
        props.$$inject = restore.state
      }
    } else {
      delete props.$$inject
    }
    options = Object.assign({}, initialOptions, {
      target,
      anchor,
      props,
      hydrate: false,
    })
  }

  // Preserving knowledge of "future props" -- very hackish version (maybe
  // there should be an option to opt out of this)
  //
  // The use case is bind:something where something doesn't exist yet in the
  // target component, but comes to exist later, after a HMR update.
  //
  // If Svelte can't map a prop in the current version of the component, it
  // will just completely discard it:
  // https://github.com/sveltejs/svelte/blob/1632bca34e4803d6b0e0b0abd652ab5968181860/src/runtime/internal/Component.ts#L46
  //
  const rememberFutureProps = cmp => {
    if (typeof Proxy === 'undefined') return

    cmp.$$.props = new Proxy(cmp.$$.props, {
      get(target, name) {
        if (target[name] === undefined) {
          target[name] = 'hmr_future_' + name
        }
        return target[name]
      },
      set(target, name, value) {
        target[name] = value
      },
    })
  }

  const instrument = targetCmp => {
    const createComponent = (Component, restore, previousCmp) => {
      ;(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_current_component)(parentComponent || previousCmp)
      const comp = new Component(options)
      // NOTE must be instrumented before restoreState, because restoring
      // bindings relies on hacked $$.props
      instrument(comp)
      restoreState(comp, restore)
      return comp
    }

    rememberFutureProps(targetCmp)

    targetCmp.$$.on_hmr = []

    // `conservative: true` means we want to be sure that the new component has
    // actually been successfuly created before destroying the old instance.
    // This could be useful for preventing runtime errors in component init to
    // bring down the whole HMR. Unfortunately the implementation bellow is
    // broken (FIXME), but that remains an interesting target for when HMR hooks
    // will actually land in Svelte itself.
    //
    // The goal would be to render an error inplace in case of error, to avoid
    // losing the navigation stack (especially annoying in native, that is not
    // based on URL navigation, so we lose the current page on each error).
    //
    targetCmp.$replace = (
      Component,
      {
        target = options.target,
        anchor = options.anchor,
        preserveLocalState,
        conservative = false,
      }
    ) => {
      const restore = captureState(targetCmp)
      assignOptions(
        target || options.target,
        anchor,
        restore,
        preserveLocalState
      )

      const callbacks = cmp ? cmp.$$.on_hmr : []

      const afterCallbacks = callbacks.map(fn => fn(cmp)).filter(Boolean)

      const previous = cmp
      if (conservative) {
        try {
          const next = createComponent(Component, restore, previous)
          // prevents on_destroy from firing on non-final cmp instance
          cmp = null
          previous.$destroy()
          cmp = next
        } catch (err) {
          cmp = previous
          throw err
        }
      } else {
        // prevents on_destroy from firing on non-final cmp instance
        cmp = null
        if (previous) {
          // previous can be null if last constructor has crashed
          previous.$destroy()
        }
        cmp = createComponent(Component, restore, cmp)
      }

      cmp.$$.hmr_cmp = cmp

      for (const fn of afterCallbacks) {
        fn(cmp)
      }

      cmp.$$.on_hmr = callbacks

      return cmp
    }

    // NOTE onMount must provide target & anchor (for us to be able to determinate
    // 			actual DOM insertion point)
    //
    // 			And also, to support keyed list, it needs to be called each time the
    // 			component is moved (same as $$.fragment.m)
    if (onMount) {
      const m = targetCmp.$$.fragment.m
      targetCmp.$$.fragment.m = (...args) => {
        const result = m(...args)
        onMount(...args)
        return result
      }
    }

    // NOTE onDestroy must be called even if the call doesn't pass through the
    //      component's $destroy method (that we can hook onto by ourselves, since
    //      it's public API) -- this happens a lot in svelte's internals, that
    //      manipulates cmp.$$.fragment directly, often binding to fragment.d,
    //      for example
    if (onDestroy) {
      targetCmp.$$.on_destroy.push(() => {
        if (isCurrent(targetCmp)) {
          onDestroy()
        }
      })
    }

    if (onInstance) {
      onInstance(targetCmp)
    }

    // Svelte 3 creates and mount components from their constructor if
    // options.target is present.
    //
    // This means that at this point, the component's `fragment.c` and,
    // most notably, `fragment.m` will already have been called _from inside
    // createComponent_. That is: before we have a chance to hook on it.
    //
    // Proxy's constructor
    //   -> createComponent
    //     -> component constructor
    //       -> component.$$.fragment.c(...) (or l, if hydrate:true)
    //       -> component.$$.fragment.m(...)
    //
    //   -> you are here <-
    //
    if (onMount) {
      const { target, anchor } = options
      if (target) {
        onMount(target, anchor)
      }
    }
  }

  const parentComponent = allowLiveBinding
    ? svelte_internal__WEBPACK_IMPORTED_MODULE_0__.current_component
    : get_current_component_safe()

  cmp = new Component(options)
  cmp.$$.hmr_cmp = cmp

  instrument(cmp)

  return cmp
}


/***/ }),

/***/ "./JS/Components/AliasLookup.svelte":
/*!******************************************!*\
  !*** ./JS/Components/AliasLookup.svelte ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var svelte__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte */ "./node_modules/svelte/index.mjs");
/* harmony import */ var svelte_select__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! svelte-select */ "./node_modules/svelte-select/index.js");
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../stores */ "./JS/stores.ts");
/* harmony import */ var _loadSubjectDemo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../loadSubjectDemo */ "./JS/loadSubjectDemo.ts");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_loader_lib_hot_api_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./node_modules/svelte-loader/lib/hot-api.js */ "./node_modules/svelte-loader/lib/hot-api.js");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_hmr_runtime_proxy_adapter_dom_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js */ "./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/* JS\Components\AliasLookup.svelte generated by Svelte v3.59.2 */






const file = "JS\\Components\\AliasLookup.svelte";

function add_css(target) {
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_styles)(target, "svelte-1jsyuv", ".style.svelte-1jsyuv{--listMaxHeight:320px;--background:rgb(226 232 240);--listBackground:rgb(226 232 240);--border:0px;--margin:0px;--height:34px;--errorBorder:0px;--errorBackground:rgb(245, 178, 178);color:rgb(15 23 42);font-family:monospace;font-size:12px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWxpYXNMb29rdXAuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTJCRSxvQkFBTyxDQUNMLGVBQWUsQ0FBRSxLQUFLLENBQ3RCLFlBQVksQ0FBRSxnQkFBZ0IsQ0FDOUIsZ0JBQWdCLENBQUUsZ0JBQWdCLENBQ2xDLFFBQVEsQ0FBRSxHQUFHLENBQ2IsUUFBUSxDQUFFLEdBQUcsQ0FDYixRQUFRLENBQUUsSUFBSSxDQUNkLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLGlCQUFpQixDQUFFLGtCQUFrQixDQUNyQyxLQUFLLENBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUNwQixXQUFXLENBQUUsU0FBUyxDQUN0QixTQUFTLENBQUUsSUFDYiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJBbGlhc0xvb2t1cC5zdmVsdGUiXX0= */");
}

function create_fragment(ctx) {
	let div;
	let select;
	let current;

	select = new svelte_select__WEBPACK_IMPORTED_MODULE_2__["default"]({
			props: {
				items: /*$subjectDemoStore*/ ctx[0]?.list,
				placeholder: (/*$subjectDemoStore*/ ctx[0]?.subject)
				? (/*$subjectDemoStore*/ ctx[0]?.list)
					? `Specs for ${/*$subjectDemoStore*/ ctx[0].subject.value}...`
					: "Loading specs..."
				: "Select subject...",
				placeholderAlwaysShow: true
			},
			$$inline: true
		});

	select.$on("select", /*select_handler*/ ctx[2]);

	const block = {
		c: function create() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(select.$$.fragment);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div, "class", "style pr-2 w-2/5 svelte-1jsyuv");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div, file, 8, 0, 286);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(select, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const select_changes = {};
			if (dirty & /*$subjectDemoStore*/ 1) select_changes.items = /*$subjectDemoStore*/ ctx[0]?.list;

			if (dirty & /*$subjectDemoStore*/ 1) select_changes.placeholder = (/*$subjectDemoStore*/ ctx[0]?.subject)
			? (/*$subjectDemoStore*/ ctx[0]?.list)
				? `Specs for ${/*$subjectDemoStore*/ ctx[0].subject.value}...`
				: "Loading specs..."
			: "Select subject...";

			select.$set(select_changes);
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(select.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(select.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(select);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $subjectDemoStore;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_store)(_stores__WEBPACK_IMPORTED_MODULE_3__.subjectDemoStore, 'subjectDemoStore');
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, _stores__WEBPACK_IMPORTED_MODULE_3__.subjectDemoStore, $$value => $$invalidate(0, $subjectDemoStore = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)('AliasLookup', slots, []);
	const dispatch = (0,svelte__WEBPACK_IMPORTED_MODULE_1__.createEventDispatcher)();
	const notify = text => dispatch("alias", { text });
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AliasLookup> was created with unknown prop '${key}'`);
	});

	const select_handler = ev => {
		notify(ev.detail.value);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher: svelte__WEBPACK_IMPORTED_MODULE_1__.createEventDispatcher,
		Select: svelte_select__WEBPACK_IMPORTED_MODULE_2__["default"],
		subjectDemoStore: _stores__WEBPACK_IMPORTED_MODULE_3__.subjectDemoStore,
		dispatch,
		notify,
		$subjectDemoStore
	});

	return [$subjectDemoStore, notify, select_handler];
}

class AliasLookup extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {
	constructor(options) {
		super(options);
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {}, add_css);

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "AliasLookup",
			options,
			id: create_fragment.name
		});
	}
}

if (module && module.hot) {}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AliasLookup);



/***/ }),

/***/ "./JS/Components/CmdEditor.svelte":
/*!****************************************!*\
  !*** ./JS/Components/CmdEditor.svelte ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var svelte_transition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte/transition */ "./node_modules/svelte/transition/index.mjs");
/* harmony import */ var prismjs_prism__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prismjs/prism */ "./node_modules/prismjs/prism.js");
/* harmony import */ var prismjs_prism__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prismjs_prism__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _prism_celincm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../prism-celincm */ "./JS/prism-celincm.js");
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../stores */ "./JS/stores.ts");
/* harmony import */ var _selected__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../selected */ "./JS/selected.ts");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_loader_lib_hot_api_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./node_modules/svelte-loader/lib/hot-api.js */ "./node_modules/svelte-loader/lib/hot-api.js");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_hmr_runtime_proxy_adapter_dom_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js */ "./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/* JS\Components\CmdEditor.svelte generated by Svelte v3.59.2 */








const file = "JS\\Components\\CmdEditor.svelte";

function add_css(target) {
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_styles)(target, "svelte-xl5d0h", "div.svelte-xl5d0h.svelte-xl5d0h.svelte-xl5d0h{font-size:16px}div.svelte-xl5d0h>code.svelte-xl5d0h>span.svelte-xl5d0h{z-index:6}textarea.svelte-xl5d0h.svelte-xl5d0h.svelte-xl5d0h,code.svelte-xl5d0h.svelte-xl5d0h.svelte-xl5d0h{margin:0px;padding:10px;border:0;left:0;word-break:break-all;white-space:break-spaces;overflow:visible;position:absolute;font-family:inherit;opacity:0.6}textarea.svelte-xl5d0h.svelte-xl5d0h.svelte-xl5d0h{width:100%;min-height:100%;overflow:hidden;background:transparent !important;z-index:2;resize:none;-webkit-text-fill-color:transparent}textarea.svelte-xl5d0h.svelte-xl5d0h.svelte-xl5d0h:focus{outline:0;border:0;box-shadow:none}code.svelte-xl5d0h.svelte-xl5d0h.svelte-xl5d0h{z-index:1}pre.svelte-xl5d0h.svelte-xl5d0h.svelte-xl5d0h{margin:0px;white-space:pre-wrap;word-wrap:break-word;font-family:inherit}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ21kRWRpdG9yLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFxRUUsNkNBQUksQ0FDRixTQUFTLENBQUUsSUFDYixDQUNBLGlCQUFHLENBQUcsa0JBQUksQ0FBRyxrQkFBSyxDQUNoQixPQUFPLENBQUUsQ0FDWCxDQUNBLGtEQUFRLENBQ1IsOENBQUssQ0FDSCxNQUFNLENBQUUsR0FBRyxDQUNYLE9BQU8sQ0FBRSxJQUFJLENBQ2IsTUFBTSxDQUFFLENBQUMsQ0FDVCxJQUFJLENBQUUsQ0FBQyxDQUNQLFVBQVUsQ0FBRSxTQUFTLENBQ3JCLFdBQVcsQ0FBRSxZQUFZLENBQ3pCLFFBQVEsQ0FBRSxPQUFPLENBQ2pCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLFdBQVcsQ0FBRSxPQUFPLENBQ3BCLE9BQU8sQ0FBRSxHQUNYLENBQ0Esa0RBQVMsQ0FDUCxLQUFLLENBQUUsSUFBSSxDQUNYLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLFVBQVUsQ0FBRSxXQUFXLENBQUMsVUFBVSxDQUNsQyxPQUFPLENBQUUsQ0FBQyxDQUNWLE1BQU0sQ0FBRSxJQUFJLENBQ1osdUJBQXVCLENBQUUsV0FDM0IsQ0FDQSxrREFBUSxNQUFPLENBQ2IsT0FBTyxDQUFFLENBQUMsQ0FDVixNQUFNLENBQUUsQ0FBQyxDQUNULFVBQVUsQ0FBRSxJQUNkLENBQ0EsOENBQUssQ0FDSCxPQUFPLENBQUUsQ0FDWCxDQUNBLDZDQUFJLENBQ0YsTUFBTSxDQUFFLEdBQUcsQ0FDWCxXQUFXLENBQUUsUUFBUSxDQUNyQixTQUFTLENBQUUsVUFBVSxDQUNyQixXQUFXLENBQUUsT0FDZiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDbWRFZGl0b3Iuc3ZlbHRlIl19 */");
}

function create_fragment(ctx) {
	let div;
	let textarea;
	let t0;
	let pre;
	let code0;
	let code0_transition;
	let t1;
	let code1;
	let t2_value = /*selected*/ ctx[1].before + "";
	let t2;
	let span;
	let raw1_value = prismjs_prism__WEBPACK_IMPORTED_MODULE_2___default().highlight(/*selected*/ ctx[1].snippet, _prism_celincm__WEBPACK_IMPORTED_MODULE_3__.celincm, "celincm") + "";
	let current;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			textarea = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("textarea");
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			pre = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("pre");
			code0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("code");
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			code1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("code");
			t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t2_value);
			span = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(textarea, "spellcheck", "false");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(textarea, "class", "svelte-xl5d0h");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(textarea, "height", /*height*/ ctx[3]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(textarea, file, 46, 2, 1136);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(code0, "id", "cmd-display");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(code0, "class", "svelte-xl5d0h");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(code0, file, 56, 7, 1386);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(pre, "class", "svelte-xl5d0h");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(pre, file, 56, 2, 1381);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(span, "class", "svelte-xl5d0h");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(span, file, 58, 22, 1483);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(code1, "class", "svelte-xl5d0h");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(code1, file, 57, 2, 1454);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div, "class", "relative font-mono h-full w-full overflow-auto svelte-xl5d0h");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div, file, 45, 0, 1072);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div, textarea);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_input_value)(textarea, /*$cmdEditStore*/ ctx[2]);
			/*textarea_binding*/ ctx[8](textarea);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div, t0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div, pre);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(pre, code0);
			code0.innerHTML = /*code*/ ctx[4];
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div, t1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div, code1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(code1, t2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(code1, span);
			span.innerHTML = raw1_value;
			current = true;

			if (!mounted) {
				dispose = [
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(textarea, "input", /*textarea_input_handler*/ ctx[6]),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(textarea, "keyup", /*keyup_handler*/ ctx[7], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(textarea, "click", /*handlePos*/ ctx[5], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*$cmdEditStore*/ 4) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_input_value)(textarea, /*$cmdEditStore*/ ctx[2]);
			}

			if (dirty & /*height*/ 8) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(textarea, "height", /*height*/ ctx[3]);
			}

			if (!current || dirty & /*code*/ 16) code0.innerHTML = /*code*/ ctx[4];;
			if ((!current || dirty & /*selected*/ 2) && t2_value !== (t2_value = /*selected*/ ctx[1].before + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t2, t2_value);
			if ((!current || dirty & /*selected*/ 2) && raw1_value !== (raw1_value = prismjs_prism__WEBPACK_IMPORTED_MODULE_2___default().highlight(/*selected*/ ctx[1].snippet, _prism_celincm__WEBPACK_IMPORTED_MODULE_3__.celincm, "celincm") + "")) span.innerHTML = raw1_value;;
		},
		i: function intro(local) {
			if (current) return;

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_render_callback)(() => {
				if (!current) return;
				if (!code0_transition) code0_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(code0, svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fade, {}, true);
				code0_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			if (!code0_transition) code0_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(code0, svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fade, {}, false);
			code0_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div);
			/*textarea_binding*/ ctx[8](null);
			if (detaching && code0_transition) code0_transition.end();
			mounted = false;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.run_all)(dispose);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let code;
	let $cmdEditStore;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_store)(_stores__WEBPACK_IMPORTED_MODULE_4__.cmdEditStore, 'cmdEditStore');
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, _stores__WEBPACK_IMPORTED_MODULE_4__.cmdEditStore, $$value => $$invalidate(2, $cmdEditStore = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)('CmdEditor', slots, []);
	let { textareaEl = null } = $$props;
	let { selected } = $$props;
	let height;

	const handlePos = () => {
		$$invalidate(1, selected = (0,_selected__WEBPACK_IMPORTED_MODULE_5__.selectedCode)($cmdEditStore, textareaEl?.selectionStart ?? 0, textareaEl?.selectionEnd ?? 0));
	};

	const resizeObserver = new ResizeObserver(entries => {
			for (let entry of entries) {
				if (entry.borderBoxSize) {
					$$invalidate(3, height = `${24 + entry.borderBoxSize[0].blockSize}px`);
				}
			}
		});

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.onMount)(() => {
		resizeObserver.observe(document.getElementById("cmd-display"));
	});

	$$self.$$.on_mount.push(function () {
		if (selected === undefined && !('selected' in $$props || $$self.$$.bound[$$self.$$.props['selected']])) {
			console.warn("<CmdEditor> was created without expected prop 'selected'");
		}
	});

	const writable_props = ['textareaEl', 'selected'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CmdEditor> was created with unknown prop '${key}'`);
	});

	function textarea_input_handler() {
		$cmdEditStore = this.value;
		_stores__WEBPACK_IMPORTED_MODULE_4__.cmdEditStore.set($cmdEditStore);
	}

	const keyup_handler = ev => {
		if ((/^(?:Arrow|Page|Home|End)/).test(ev.key)) handlePos();
	};

	function textarea_binding($$value) {
		svelte_internal__WEBPACK_IMPORTED_MODULE_0__.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			textareaEl = $$value;
			$$invalidate(0, textareaEl);
		});
	}

	$$self.$$set = $$props => {
		if ('textareaEl' in $$props) $$invalidate(0, textareaEl = $$props.textareaEl);
		if ('selected' in $$props) $$invalidate(1, selected = $$props.selected);
	};

	$$self.$capture_state = () => ({
		onMount: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.onMount,
		fade: svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fade,
		Prism: (prismjs_prism__WEBPACK_IMPORTED_MODULE_2___default()),
		celincm: _prism_celincm__WEBPACK_IMPORTED_MODULE_3__.celincm,
		cmdEditStore: _stores__WEBPACK_IMPORTED_MODULE_4__.cmdEditStore,
		selectedCode: _selected__WEBPACK_IMPORTED_MODULE_5__.selectedCode,
		textareaEl,
		selected,
		height,
		handlePos,
		resizeObserver,
		code,
		$cmdEditStore
	});

	$$self.$inject_state = $$props => {
		if ('textareaEl' in $$props) $$invalidate(0, textareaEl = $$props.textareaEl);
		if ('selected' in $$props) $$invalidate(1, selected = $$props.selected);
		if ('height' in $$props) $$invalidate(3, height = $$props.height);
		if ('code' in $$props) $$invalidate(4, code = $$props.code);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$cmdEditStore*/ 4) {
			$: $$invalidate(4, code = prismjs_prism__WEBPACK_IMPORTED_MODULE_2___default().highlight($cmdEditStore, _prism_celincm__WEBPACK_IMPORTED_MODULE_3__.celincm, "celincm"));
		}

		if ($$self.$$.dirty & /*$cmdEditStore, textareaEl*/ 5) {
			$: $$invalidate(1, selected = (0,_selected__WEBPACK_IMPORTED_MODULE_5__.selectedCode)($cmdEditStore, textareaEl?.selectionStart ?? 0, textareaEl?.selectionEnd ?? 0));
		}
	};

	return [
		textareaEl,
		selected,
		$cmdEditStore,
		height,
		code,
		handlePos,
		textarea_input_handler,
		keyup_handler,
		textarea_binding
	];
}

class CmdEditor extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {
	constructor(options) {
		super(options);
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, { textareaEl: 0, selected: 1 }, add_css);

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "CmdEditor",
			options,
			id: create_fragment.name
		});
	}

	get textareaEl() {
		throw new Error("<CmdEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set textareaEl(value) {
		throw new Error("<CmdEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selected() {
		throw new Error("<CmdEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selected(value) {
		throw new Error("<CmdEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

if (module && module.hot) {}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CmdEditor);



/***/ }),

/***/ "./JS/Components/CqlEditor.svelte":
/*!****************************************!*\
  !*** ./JS/Components/CqlEditor.svelte ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var svelte__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte */ "./node_modules/svelte/index.mjs");
/* harmony import */ var svelte_transition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! svelte/transition */ "./node_modules/svelte/transition/index.mjs");
/* harmony import */ var prismjs_prism__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prismjs/prism */ "./node_modules/prismjs/prism.js");
/* harmony import */ var prismjs_prism__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prismjs_prism__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _prism_celinql__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../prism-celinql */ "./JS/prism-celinql.js");
/* harmony import */ var _selected__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../selected */ "./JS/selected.ts");
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../stores */ "./JS/stores.ts");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_loader_lib_hot_api_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./node_modules/svelte-loader/lib/hot-api.js */ "./node_modules/svelte-loader/lib/hot-api.js");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_hmr_runtime_proxy_adapter_dom_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js */ "./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/* JS\Components\CqlEditor.svelte generated by Svelte v3.59.2 */








const file = "JS\\Components\\CqlEditor.svelte";

function add_css(target) {
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_styles)(target, "svelte-xl5d0h", "div.svelte-xl5d0h.svelte-xl5d0h.svelte-xl5d0h{font-size:16px}div.svelte-xl5d0h>code.svelte-xl5d0h>span.svelte-xl5d0h{z-index:6}textarea.svelte-xl5d0h.svelte-xl5d0h.svelte-xl5d0h,code.svelte-xl5d0h.svelte-xl5d0h.svelte-xl5d0h{margin:0px;padding:10px;border:0;left:0;word-break:break-all;white-space:break-spaces;overflow:visible;position:absolute;font-family:inherit;opacity:0.6}textarea.svelte-xl5d0h.svelte-xl5d0h.svelte-xl5d0h{width:100%;min-height:100%;overflow:hidden;background:transparent !important;z-index:2;resize:none;-webkit-text-fill-color:transparent}textarea.svelte-xl5d0h.svelte-xl5d0h.svelte-xl5d0h:focus{outline:0;border:0;box-shadow:none}code.svelte-xl5d0h.svelte-xl5d0h.svelte-xl5d0h{z-index:1}pre.svelte-xl5d0h.svelte-xl5d0h.svelte-xl5d0h{margin:0px;white-space:pre-wrap;word-wrap:break-word;font-family:inherit}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ3FsRWRpdG9yLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUE2RUUsNkNBQUksQ0FDRixTQUFTLENBQUUsSUFDYixDQUNBLGlCQUFHLENBQUcsa0JBQUksQ0FBRyxrQkFBSyxDQUNoQixPQUFPLENBQUUsQ0FDWCxDQUNBLGtEQUFRLENBQ1IsOENBQUssQ0FDSCxNQUFNLENBQUUsR0FBRyxDQUNYLE9BQU8sQ0FBRSxJQUFJLENBQ2IsTUFBTSxDQUFFLENBQUMsQ0FDVCxJQUFJLENBQUUsQ0FBQyxDQUNQLFVBQVUsQ0FBRSxTQUFTLENBQ3JCLFdBQVcsQ0FBRSxZQUFZLENBQ3pCLFFBQVEsQ0FBRSxPQUFPLENBQ2pCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLFdBQVcsQ0FBRSxPQUFPLENBQ3BCLE9BQU8sQ0FBRSxHQUNYLENBQ0Esa0RBQVMsQ0FDUCxLQUFLLENBQUUsSUFBSSxDQUNYLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLFVBQVUsQ0FBRSxXQUFXLENBQUMsVUFBVSxDQUNsQyxPQUFPLENBQUUsQ0FBQyxDQUNWLE1BQU0sQ0FBRSxJQUFJLENBQ1osdUJBQXVCLENBQUUsV0FDM0IsQ0FDQSxrREFBUSxNQUFPLENBQ2IsT0FBTyxDQUFFLENBQUMsQ0FDVixNQUFNLENBQUUsQ0FBQyxDQUNULFVBQVUsQ0FBRSxJQUNkLENBQ0EsOENBQUssQ0FDSCxPQUFPLENBQUUsQ0FDWCxDQUNBLDZDQUFJLENBQ0YsTUFBTSxDQUFFLEdBQUcsQ0FDWCxXQUFXLENBQUUsUUFBUSxDQUNyQixTQUFTLENBQUUsVUFBVSxDQUNyQixXQUFXLENBQUUsT0FDZiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDcWxFZGl0b3Iuc3ZlbHRlIl19 */");
}

function create_fragment(ctx) {
	let div;
	let textarea;
	let t0;
	let pre;
	let code0;
	let code0_transition;
	let t1;
	let code1;
	let t2_value = /*selected*/ ctx[1].before + "";
	let t2;
	let span;
	let raw1_value = prismjs_prism__WEBPACK_IMPORTED_MODULE_3___default().highlight(/*selected*/ ctx[1].snippet, _prism_celinql__WEBPACK_IMPORTED_MODULE_4__.celinql, "CelinQL") + "";
	let current;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			textarea = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("textarea");
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			pre = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("pre");
			code0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("code");
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			code1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("code");
			t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t2_value);
			span = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(textarea, "spellcheck", "false");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(textarea, "class", "svelte-xl5d0h");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(textarea, "height", /*height*/ ctx[3]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(textarea, file, 58, 2, 1599);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(code0, "id", "cql-display");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(code0, "class", "svelte-xl5d0h");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(code0, file, 68, 7, 1847);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(pre, "class", "svelte-xl5d0h");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(pre, file, 68, 2, 1842);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(span, "class", "svelte-xl5d0h");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(span, file, 70, 22, 1944);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(code1, "class", "svelte-xl5d0h");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(code1, file, 69, 2, 1915);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div, "class", "relative font-mono h-full w-full overflow-auto svelte-xl5d0h");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div, file, 57, 0, 1535);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div, textarea);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_input_value)(textarea, /*$queryStore*/ ctx[2]);
			/*textarea_binding*/ ctx[9](textarea);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div, t0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div, pre);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(pre, code0);
			code0.innerHTML = /*code*/ ctx[4];
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div, t1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div, code1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(code1, t2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(code1, span);
			span.innerHTML = raw1_value;
			current = true;

			if (!mounted) {
				dispose = [
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(textarea, "input", /*textarea_input_handler*/ ctx[7]),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(textarea, "keyup", /*keyup_handler*/ ctx[8], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(textarea, "click", /*handlePos*/ ctx[5], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*$queryStore*/ 4) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_input_value)(textarea, /*$queryStore*/ ctx[2]);
			}

			if (dirty & /*height*/ 8) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(textarea, "height", /*height*/ ctx[3]);
			}

			if (!current || dirty & /*code*/ 16) code0.innerHTML = /*code*/ ctx[4];;
			if ((!current || dirty & /*selected*/ 2) && t2_value !== (t2_value = /*selected*/ ctx[1].before + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t2, t2_value);
			if ((!current || dirty & /*selected*/ 2) && raw1_value !== (raw1_value = prismjs_prism__WEBPACK_IMPORTED_MODULE_3___default().highlight(/*selected*/ ctx[1].snippet, _prism_celinql__WEBPACK_IMPORTED_MODULE_4__.celinql, "CelinQL") + "")) span.innerHTML = raw1_value;;
		},
		i: function intro(local) {
			if (current) return;

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_render_callback)(() => {
				if (!current) return;
				if (!code0_transition) code0_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(code0, svelte_transition__WEBPACK_IMPORTED_MODULE_2__.fade, {}, true);
				code0_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			if (!code0_transition) code0_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(code0, svelte_transition__WEBPACK_IMPORTED_MODULE_2__.fade, {}, false);
			code0_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div);
			/*textarea_binding*/ ctx[9](null);
			if (detaching && code0_transition) code0_transition.end();
			mounted = false;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.run_all)(dispose);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let code;
	let $queryStore;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_store)(_stores__WEBPACK_IMPORTED_MODULE_6__.queryStore, 'queryStore');
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, _stores__WEBPACK_IMPORTED_MODULE_6__.queryStore, $$value => $$invalidate(2, $queryStore = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)('CqlEditor', slots, []);
	let { textareaEl = null } = $$props;
	let { selected } = $$props;

	const paste = text => {
		const last = textareaEl.selectionStart > 0
		? textareaEl.value[textareaEl.selectionStart - 1]
		: " ";

		const alias = (/\w/).test(last) ? `,${text}` : text;
		textareaEl.setRangeText(alias, textareaEl.selectionStart, textareaEl.selectionEnd, "end");
		_stores__WEBPACK_IMPORTED_MODULE_6__.queryStore.set(textareaEl.value);
	};

	let height;

	const handlePos = () => {
		$$invalidate(1, selected = (0,_selected__WEBPACK_IMPORTED_MODULE_5__.selectedCode)($queryStore, textareaEl?.selectionStart, textareaEl?.selectionEnd));
	};

	const resizeObserver = new ResizeObserver(entries => {
			for (let entry of entries) {
				if (entry.borderBoxSize) {
					$$invalidate(3, height = `${24 + entry.borderBoxSize[0].blockSize}px`);
				}
			}
		});

	(0,svelte__WEBPACK_IMPORTED_MODULE_1__.onMount)(() => {
		resizeObserver.observe(document.getElementById("cql-display"));
	});

	$$self.$$.on_mount.push(function () {
		if (selected === undefined && !('selected' in $$props || $$self.$$.bound[$$self.$$.props['selected']])) {
			console.warn("<CqlEditor> was created without expected prop 'selected'");
		}
	});

	const writable_props = ['textareaEl', 'selected'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CqlEditor> was created with unknown prop '${key}'`);
	});

	function textarea_input_handler() {
		$queryStore = this.value;
		_stores__WEBPACK_IMPORTED_MODULE_6__.queryStore.set($queryStore);
	}

	const keyup_handler = ev => {
		if ((/^(?:Arrow|Page|Home|End)/).test(ev.key)) handlePos();
	};

	function textarea_binding($$value) {
		svelte_internal__WEBPACK_IMPORTED_MODULE_0__.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			textareaEl = $$value;
			$$invalidate(0, textareaEl);
		});
	}

	$$self.$$set = $$props => {
		if ('textareaEl' in $$props) $$invalidate(0, textareaEl = $$props.textareaEl);
		if ('selected' in $$props) $$invalidate(1, selected = $$props.selected);
	};

	$$self.$capture_state = () => ({
		onMount: svelte__WEBPACK_IMPORTED_MODULE_1__.onMount,
		fade: svelte_transition__WEBPACK_IMPORTED_MODULE_2__.fade,
		Prism: (prismjs_prism__WEBPACK_IMPORTED_MODULE_3___default()),
		celinql: _prism_celinql__WEBPACK_IMPORTED_MODULE_4__.celinql,
		selectedCode: _selected__WEBPACK_IMPORTED_MODULE_5__.selectedCode,
		queryStore: _stores__WEBPACK_IMPORTED_MODULE_6__.queryStore,
		textareaEl,
		selected,
		paste,
		height,
		handlePos,
		resizeObserver,
		code,
		$queryStore
	});

	$$self.$inject_state = $$props => {
		if ('textareaEl' in $$props) $$invalidate(0, textareaEl = $$props.textareaEl);
		if ('selected' in $$props) $$invalidate(1, selected = $$props.selected);
		if ('height' in $$props) $$invalidate(3, height = $$props.height);
		if ('code' in $$props) $$invalidate(4, code = $$props.code);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$queryStore*/ 4) {
			$: $$invalidate(4, code = prismjs_prism__WEBPACK_IMPORTED_MODULE_3___default().highlight($queryStore, _prism_celinql__WEBPACK_IMPORTED_MODULE_4__.celinql, "CelinQL") || "<em style='color: lightgray; opacity: .6'>Subject (alias list...) all|any(alias filters...)</em>");
		}

		if ($$self.$$.dirty & /*$queryStore, textareaEl*/ 5) {
			$: $$invalidate(1, selected = (0,_selected__WEBPACK_IMPORTED_MODULE_5__.selectedCode)($queryStore, textareaEl?.selectionStart ?? 0, textareaEl?.selectionEnd ?? 0));
		}
	};

	return [
		textareaEl,
		selected,
		$queryStore,
		height,
		code,
		handlePos,
		paste,
		textarea_input_handler,
		keyup_handler,
		textarea_binding
	];
}

class CqlEditor extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {
	constructor(options) {
		super(options);
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, { textareaEl: 0, selected: 1, paste: 6 }, add_css);

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "CqlEditor",
			options,
			id: create_fragment.name
		});
	}

	get textareaEl() {
		throw new Error("<CqlEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set textareaEl(value) {
		throw new Error("<CqlEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selected() {
		throw new Error("<CqlEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selected(value) {
		throw new Error("<CqlEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get paste() {
		return this.$$.ctx[6];
	}

	set paste(value) {
		throw new Error("<CqlEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

if (module && module.hot) {}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CqlEditor);



/***/ }),

/***/ "./JS/Components/CslEditor.svelte":
/*!****************************************!*\
  !*** ./JS/Components/CslEditor.svelte ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var svelte_transition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte/transition */ "./node_modules/svelte/transition/index.mjs");
/* harmony import */ var prismjs_prism__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prismjs/prism */ "./node_modules/prismjs/prism.js");
/* harmony import */ var prismjs_prism__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prismjs_prism__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _prism_celinsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../prism-celinsl */ "./JS/prism-celinsl.js");
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../stores */ "./JS/stores.ts");
/* harmony import */ var _selected__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../selected */ "./JS/selected.ts");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_loader_lib_hot_api_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./node_modules/svelte-loader/lib/hot-api.js */ "./node_modules/svelte-loader/lib/hot-api.js");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_hmr_runtime_proxy_adapter_dom_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js */ "./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/* JS\Components\CslEditor.svelte generated by Svelte v3.59.2 */








const file = "JS\\Components\\CslEditor.svelte";

function add_css(target) {
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_styles)(target, "svelte-1y4qb4i", "div.svelte-1y4qb4i.svelte-1y4qb4i.svelte-1y4qb4i{font-size:16px}div.svelte-1y4qb4i>code.svelte-1y4qb4i>span.svelte-1y4qb4i{z-index:6}textarea.svelte-1y4qb4i.svelte-1y4qb4i.svelte-1y4qb4i,code.svelte-1y4qb4i.svelte-1y4qb4i.svelte-1y4qb4i{margin:0px;padding:10px;border:0;left:0;word-break:break-all;white-space:break-spaces;overflow:visible;position:absolute;font-family:inherit;opacity:0.7}textarea.svelte-1y4qb4i.svelte-1y4qb4i.svelte-1y4qb4i{width:100%;min-height:100%;overflow:hidden;background:transparent !important;z-index:2;resize:none;-webkit-text-fill-color:transparent}textarea.svelte-1y4qb4i.svelte-1y4qb4i.svelte-1y4qb4i:focus{outline:0;border:0;box-shadow:none}code.svelte-1y4qb4i.svelte-1y4qb4i.svelte-1y4qb4i{z-index:1}pre.svelte-1y4qb4i.svelte-1y4qb4i.svelte-1y4qb4i{margin:0px;white-space:pre-wrap;word-wrap:break-word;font-family:inherit}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ3NsRWRpdG9yLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFnRUUsZ0RBQUksQ0FDRixTQUFTLENBQUUsSUFDYixDQUNBLGtCQUFHLENBQUcsbUJBQUksQ0FBRyxtQkFBSyxDQUNoQixPQUFPLENBQUUsQ0FDWCxDQUNBLHFEQUFRLENBQ1IsaURBQUssQ0FDSCxNQUFNLENBQUUsR0FBRyxDQUNYLE9BQU8sQ0FBRSxJQUFJLENBQ2IsTUFBTSxDQUFFLENBQUMsQ0FDVCxJQUFJLENBQUUsQ0FBQyxDQUNQLFVBQVUsQ0FBRSxTQUFTLENBQ3JCLFdBQVcsQ0FBRSxZQUFZLENBQ3pCLFFBQVEsQ0FBRSxPQUFPLENBQ2pCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLFdBQVcsQ0FBRSxPQUFPLENBQ3BCLE9BQU8sQ0FBRSxHQUNYLENBQ0EscURBQVMsQ0FDUCxLQUFLLENBQUUsSUFBSSxDQUNYLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLFVBQVUsQ0FBRSxXQUFXLENBQUMsVUFBVSxDQUNsQyxPQUFPLENBQUUsQ0FBQyxDQUNWLE1BQU0sQ0FBRSxJQUFJLENBQ1osdUJBQXVCLENBQUUsV0FDM0IsQ0FDQSxxREFBUSxNQUFPLENBQ2IsT0FBTyxDQUFFLENBQUMsQ0FDVixNQUFNLENBQUUsQ0FBQyxDQUNULFVBQVUsQ0FBRSxJQUNkLENBQ0EsaURBQUssQ0FDSCxPQUFPLENBQUUsQ0FDWCxDQUNBLGdEQUFJLENBQ0YsTUFBTSxDQUFFLEdBQUcsQ0FDWCxXQUFXLENBQUUsUUFBUSxDQUNyQixTQUFTLENBQUUsVUFBVSxDQUNyQixXQUFXLENBQUUsT0FDZiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDc2xFZGl0b3Iuc3ZlbHRlIl19 */");
}

function create_fragment(ctx) {
	let div;
	let textarea;
	let t0;
	let pre;
	let code0;
	let code0_transition;
	let t1;
	let code1;
	let t2_value = /*selected*/ ctx[1].before + "";
	let t2;
	let span;
	let raw1_value = prismjs_prism__WEBPACK_IMPORTED_MODULE_2___default().highlight(/*selected*/ ctx[1].snippet, _prism_celinsl__WEBPACK_IMPORTED_MODULE_3__.celinsl, "CSL") + "";
	let current;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			textarea = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("textarea");
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			pre = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("pre");
			code0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("code");
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			code1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("code");
			t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t2_value);
			span = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(textarea, "spellcheck", "false");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(textarea, "class", "svelte-1y4qb4i");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(textarea, "height", /*height*/ ctx[3]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(textarea, file, 45, 2, 1218);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(code0, "id", "csl-display");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(code0, "class", "svelte-1y4qb4i");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(code0, file, 55, 7, 1467);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(pre, "class", "svelte-1y4qb4i");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(pre, file, 55, 2, 1462);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(span, "class", "svelte-1y4qb4i");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(span, file, 57, 22, 1564);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(code1, "class", "svelte-1y4qb4i");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(code1, file, 56, 2, 1535);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div, "class", "relative font-mono h-full w-full overflow-auto svelte-1y4qb4i");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div, file, 44, 0, 1154);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div, textarea);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_input_value)(textarea, /*$scriptStore*/ ctx[2]);
			/*textarea_binding*/ ctx[8](textarea);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div, t0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div, pre);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(pre, code0);
			code0.innerHTML = /*code*/ ctx[4];
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div, t1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div, code1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(code1, t2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(code1, span);
			span.innerHTML = raw1_value;
			current = true;

			if (!mounted) {
				dispose = [
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(textarea, "input", /*textarea_input_handler*/ ctx[6]),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(textarea, "keyup", /*keyup_handler*/ ctx[7], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(textarea, "click", /*handlePos*/ ctx[5], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*$scriptStore*/ 4) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_input_value)(textarea, /*$scriptStore*/ ctx[2]);
			}

			if (dirty & /*height*/ 8) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(textarea, "height", /*height*/ ctx[3]);
			}

			if (!current || dirty & /*code*/ 16) code0.innerHTML = /*code*/ ctx[4];;
			if ((!current || dirty & /*selected*/ 2) && t2_value !== (t2_value = /*selected*/ ctx[1].before + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t2, t2_value);
			if ((!current || dirty & /*selected*/ 2) && raw1_value !== (raw1_value = prismjs_prism__WEBPACK_IMPORTED_MODULE_2___default().highlight(/*selected*/ ctx[1].snippet, _prism_celinsl__WEBPACK_IMPORTED_MODULE_3__.celinsl, "CSL") + "")) span.innerHTML = raw1_value;;
		},
		i: function intro(local) {
			if (current) return;

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_render_callback)(() => {
				if (!current) return;
				if (!code0_transition) code0_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(code0, svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fade, {}, true);
				code0_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			if (!code0_transition) code0_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(code0, svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fade, {}, false);
			code0_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div);
			/*textarea_binding*/ ctx[8](null);
			if (detaching && code0_transition) code0_transition.end();
			mounted = false;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.run_all)(dispose);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let code;
	let $scriptStore;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_store)(_stores__WEBPACK_IMPORTED_MODULE_4__.scriptStore, 'scriptStore');
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, _stores__WEBPACK_IMPORTED_MODULE_4__.scriptStore, $$value => $$invalidate(2, $scriptStore = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)('CslEditor', slots, []);
	let { textareaEl = null } = $$props;
	let { selected } = $$props;
	let height;
	let pos;

	const handlePos = () => {
		$$invalidate(1, selected = (0,_selected__WEBPACK_IMPORTED_MODULE_5__.selectedCode)($scriptStore, textareaEl?.selectionStart ?? 0, textareaEl?.selectionEnd ?? 0));
	};

	const resizeObserver = new ResizeObserver(entries => {
			for (let entry of entries) {
				if (entry.borderBoxSize) {
					$$invalidate(3, height = `${24 + entry.borderBoxSize[0].blockSize}px`);
				}
			}
		});

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.onMount)(() => {
		resizeObserver.observe(document.getElementById("csl-display"));
	});

	$$self.$$.on_mount.push(function () {
		if (selected === undefined && !('selected' in $$props || $$self.$$.bound[$$self.$$.props['selected']])) {
			console.warn("<CslEditor> was created without expected prop 'selected'");
		}
	});

	const writable_props = ['textareaEl', 'selected'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CslEditor> was created with unknown prop '${key}'`);
	});

	function textarea_input_handler() {
		$scriptStore = this.value;
		_stores__WEBPACK_IMPORTED_MODULE_4__.scriptStore.set($scriptStore);
	}

	const keyup_handler = ev => {
		if ((/^(?:Arrow|Page|Home|End)/).test(ev.key)) handlePos();
	};

	function textarea_binding($$value) {
		svelte_internal__WEBPACK_IMPORTED_MODULE_0__.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			textareaEl = $$value;
			$$invalidate(0, textareaEl);
		});
	}

	$$self.$$set = $$props => {
		if ('textareaEl' in $$props) $$invalidate(0, textareaEl = $$props.textareaEl);
		if ('selected' in $$props) $$invalidate(1, selected = $$props.selected);
	};

	$$self.$capture_state = () => ({
		onMount: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.onMount,
		fade: svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fade,
		Prism: (prismjs_prism__WEBPACK_IMPORTED_MODULE_2___default()),
		celinsl: _prism_celinsl__WEBPACK_IMPORTED_MODULE_3__.celinsl,
		scriptStore: _stores__WEBPACK_IMPORTED_MODULE_4__.scriptStore,
		selectedCode: _selected__WEBPACK_IMPORTED_MODULE_5__.selectedCode,
		textareaEl,
		selected,
		height,
		pos,
		handlePos,
		resizeObserver,
		code,
		$scriptStore
	});

	$$self.$inject_state = $$props => {
		if ('textareaEl' in $$props) $$invalidate(0, textareaEl = $$props.textareaEl);
		if ('selected' in $$props) $$invalidate(1, selected = $$props.selected);
		if ('height' in $$props) $$invalidate(3, height = $$props.height);
		if ('pos' in $$props) pos = $$props.pos;
		if ('code' in $$props) $$invalidate(4, code = $$props.code);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$scriptStore*/ 4) {
			$: $$invalidate(4, code = prismjs_prism__WEBPACK_IMPORTED_MODULE_2___default().highlight($scriptStore, _prism_celinsl__WEBPACK_IMPORTED_MODULE_3__.celinsl, "CSL") || "<em style='color: lightgray; opacity: .6'>open.<i>Form.Version</i>.action[...</em>");
		}

		if ($$self.$$.dirty & /*$scriptStore, textareaEl*/ 5) {
			$: $$invalidate(1, selected = (0,_selected__WEBPACK_IMPORTED_MODULE_5__.selectedCode)($scriptStore, textareaEl?.selectionStart ?? 0, textareaEl?.selectionEnd ?? 0));
		}
	};

	return [
		textareaEl,
		selected,
		$scriptStore,
		height,
		code,
		handlePos,
		textarea_input_handler,
		keyup_handler,
		textarea_binding
	];
}

class CslEditor extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {
	constructor(options) {
		super(options);
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, { textareaEl: 0, selected: 1 }, add_css);

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "CslEditor",
			options,
			id: create_fragment.name
		});
	}

	get textareaEl() {
		throw new Error("<CslEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set textareaEl(value) {
		throw new Error("<CslEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selected() {
		throw new Error("<CslEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selected(value) {
		throw new Error("<CslEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

if (module && module.hot) {}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CslEditor);



/***/ }),

/***/ "./JS/Components/EditorApp.svelte":
/*!****************************************!*\
  !*** ./JS/Components/EditorApp.svelte ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var svelte__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte */ "./node_modules/svelte/index.mjs");
/* harmony import */ var svelte_transition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! svelte/transition */ "./node_modules/svelte/transition/index.mjs");
/* harmony import */ var _persist__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../persist */ "./JS/persist.ts");
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../stores */ "./JS/stores.ts");
/* harmony import */ var _submit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../submit */ "./JS/submit.ts");
/* harmony import */ var _menus__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../menus */ "./JS/menus.ts");
/* harmony import */ var _CqlEditor_svelte__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./CqlEditor.svelte */ "./JS/Components/CqlEditor.svelte");
/* harmony import */ var _CslEditor_svelte__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./CslEditor.svelte */ "./JS/Components/CslEditor.svelte");
/* harmony import */ var _CmdEditor_svelte__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./CmdEditor.svelte */ "./JS/Components/CmdEditor.svelte");
/* harmony import */ var _Server_svelte__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Server.svelte */ "./JS/Components/Server.svelte");
/* harmony import */ var _Login_svelte__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Login.svelte */ "./JS/Components/Login.svelte");
/* harmony import */ var _WebLogin_svelte__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./WebLogin.svelte */ "./JS/Components/WebLogin.svelte");
/* harmony import */ var _Header_svelte__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Header.svelte */ "./JS/Components/Header.svelte");
/* harmony import */ var _SubjectLookup_svelte__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./SubjectLookup.svelte */ "./JS/Components/SubjectLookup.svelte");
/* harmony import */ var _AliasLookup_svelte__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./AliasLookup.svelte */ "./JS/Components/AliasLookup.svelte");
/* harmony import */ var _Notification_svelte__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./Notification.svelte */ "./JS/Components/Notification.svelte");
/* harmony import */ var _Slider_svelte__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./Slider.svelte */ "./JS/Components/Slider.svelte");
/* harmony import */ var _v2_CmdList_svelte__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./v2/CmdList.svelte */ "./JS/Components/v2/CmdList.svelte");
/* harmony import */ var _v2_CqlList_svelte__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./v2/CqlList.svelte */ "./JS/Components/v2/CqlList.svelte");
/* harmony import */ var _v2_CslList_svelte__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./v2/CslList.svelte */ "./JS/Components/v2/CslList.svelte");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_loader_lib_hot_api_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./node_modules/svelte-loader/lib/hot-api.js */ "./node_modules/svelte-loader/lib/hot-api.js");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_hmr_runtime_proxy_adapter_dom_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js */ "./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/* JS\Components\EditorApp.svelte generated by Svelte v3.59.2 */






















const file = "JS\\Components\\EditorApp.svelte";

// (1:0) <script>    import { onDestroy, onMount }
function create_catch_block(ctx) {
	const block = {
		c: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		m: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		d: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_catch_block.name,
		type: "catch",
		source: "(1:0) <script>    import { onDestroy, onMount }",
		ctx
	});

	return block;
}

// (94:25)     {#if yes}
function create_then_block(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*yes*/ ctx[32]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, [-1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, if_block_anchor, anchor);
			current = true;
		},
		p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(if_block_anchor);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_then_block.name,
		type: "then",
		source: "(94:25)     {#if yes}",
		ctx
	});

	return block;
}

// (97:2) {:else}
function create_else_block(ctx) {
	let weblogin;
	let current;
	weblogin = new _WebLogin_svelte__WEBPACK_IMPORTED_MODULE_12__["default"]({ $$inline: true });

	const block = {
		c: function create() {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(weblogin.$$.fragment);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(weblogin, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(weblogin.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(weblogin.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(weblogin, detaching);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(97:2) {:else}",
		ctx
	});

	return block;
}

// (95:2) {#if yes}
function create_if_block_1(ctx) {
	let login;
	let current;
	login = new _Login_svelte__WEBPACK_IMPORTED_MODULE_11__["default"]({ $$inline: true });

	const block = {
		c: function create() {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(login.$$.fragment);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(login, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(login.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(login.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(login, detaching);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(95:2) {#if yes}",
		ctx
	});

	return block;
}

// (1:0) <script>    import { onDestroy, onMount }
function create_pending_block(ctx) {
	const block = {
		c: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		m: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		d: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_pending_block.name,
		type: "pending",
		source: "(1:0) <script>    import { onDestroy, onMount }",
		ctx
	});

	return block;
}

// (103:0) {#if ready}
function create_if_block(ctx) {
	let header;
	let updating_openMenu;
	let t0;
	let main;
	let div3;
	let div0;
	let cqleditor;
	let updating_textareaEl;
	let updating_selected;
	let updating_paste;
	let t1;
	let slider0;
	let updating_ratio;
	let t2;
	let div2;
	let div1;
	let subjectlookup;
	let t3;
	let aliaslookup;
	let t4;
	let cqllist;
	let t5;
	let div6;
	let div4;
	let csleditor;
	let updating_textareaEl_1;
	let updating_selected_1;
	let t6;
	let slider1;
	let updating_ratio_1;
	let t7;
	let div5;
	let csllist;
	let t8;
	let div9;
	let div7;
	let cmdeditor;
	let updating_textareaEl_2;
	let updating_selected_2;
	let t9;
	let slider2;
	let updating_ratio_2;
	let t10;
	let div8;
	let cmdlist;
	let main_transition;
	let current;

	function header_openMenu_binding(value) {
		/*header_openMenu_binding*/ ctx[17](value);
	}

	let header_props = {
		version: /*version*/ ctx[0],
		menu: /*menu*/ ctx[14],
		currentTab: /*currentTab*/ ctx[13],
		setTab: /*func*/ ctx[16]
	};

	if (/*openMenu*/ ctx[12] !== void 0) {
		header_props.openMenu = /*openMenu*/ ctx[12];
	}

	header = new _Header_svelte__WEBPACK_IMPORTED_MODULE_13__["default"]({ props: header_props, $$inline: true });
	svelte_internal__WEBPACK_IMPORTED_MODULE_0__.binding_callbacks.push(() => (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bind)(header, 'openMenu', header_openMenu_binding));

	function cqleditor_textareaEl_binding(value) {
		/*cqleditor_textareaEl_binding*/ ctx[18](value);
	}

	function cqleditor_selected_binding(value) {
		/*cqleditor_selected_binding*/ ctx[19](value);
	}

	function cqleditor_paste_binding(value) {
		/*cqleditor_paste_binding*/ ctx[20](value);
	}

	let cqleditor_props = {};

	if (/*cqlTextElement*/ ctx[5] !== void 0) {
		cqleditor_props.textareaEl = /*cqlTextElement*/ ctx[5];
	}

	if (/*cqlSelected*/ ctx[6] !== void 0) {
		cqleditor_props.selected = /*cqlSelected*/ ctx[6];
	}

	if (/*cqlPaste*/ ctx[7] !== void 0) {
		cqleditor_props.paste = /*cqlPaste*/ ctx[7];
	}

	cqleditor = new _CqlEditor_svelte__WEBPACK_IMPORTED_MODULE_7__["default"]({ props: cqleditor_props, $$inline: true });
	svelte_internal__WEBPACK_IMPORTED_MODULE_0__.binding_callbacks.push(() => (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bind)(cqleditor, 'textareaEl', cqleditor_textareaEl_binding));
	svelte_internal__WEBPACK_IMPORTED_MODULE_0__.binding_callbacks.push(() => (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bind)(cqleditor, 'selected', cqleditor_selected_binding));
	svelte_internal__WEBPACK_IMPORTED_MODULE_0__.binding_callbacks.push(() => (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bind)(cqleditor, 'paste', cqleditor_paste_binding));

	function slider0_ratio_binding(value) {
		/*slider0_ratio_binding*/ ctx[21](value);
	}

	let slider0_props = {};

	if (/*cqlRatio*/ ctx[2] !== void 0) {
		slider0_props.ratio = /*cqlRatio*/ ctx[2];
	}

	slider0 = new _Slider_svelte__WEBPACK_IMPORTED_MODULE_17__["default"]({ props: slider0_props, $$inline: true });
	svelte_internal__WEBPACK_IMPORTED_MODULE_0__.binding_callbacks.push(() => (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bind)(slider0, 'ratio', slider0_ratio_binding));
	subjectlookup = new _SubjectLookup_svelte__WEBPACK_IMPORTED_MODULE_14__["default"]({ $$inline: true });
	aliaslookup = new _AliasLookup_svelte__WEBPACK_IMPORTED_MODULE_15__["default"]({ $$inline: true });
	aliaslookup.$on("alias", /*alias_handler*/ ctx[22]);
	cqllist = new _v2_CqlList_svelte__WEBPACK_IMPORTED_MODULE_19__["default"]({ $$inline: true });

	function csleditor_textareaEl_binding(value) {
		/*csleditor_textareaEl_binding*/ ctx[23](value);
	}

	function csleditor_selected_binding(value) {
		/*csleditor_selected_binding*/ ctx[24](value);
	}

	let csleditor_props = {};

	if (/*cslTextElement*/ ctx[8] !== void 0) {
		csleditor_props.textareaEl = /*cslTextElement*/ ctx[8];
	}

	if (/*cslSelected*/ ctx[9] !== void 0) {
		csleditor_props.selected = /*cslSelected*/ ctx[9];
	}

	csleditor = new _CslEditor_svelte__WEBPACK_IMPORTED_MODULE_8__["default"]({ props: csleditor_props, $$inline: true });
	svelte_internal__WEBPACK_IMPORTED_MODULE_0__.binding_callbacks.push(() => (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bind)(csleditor, 'textareaEl', csleditor_textareaEl_binding));
	svelte_internal__WEBPACK_IMPORTED_MODULE_0__.binding_callbacks.push(() => (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bind)(csleditor, 'selected', csleditor_selected_binding));

	function slider1_ratio_binding(value) {
		/*slider1_ratio_binding*/ ctx[25](value);
	}

	let slider1_props = {};

	if (/*cslRatio*/ ctx[3] !== void 0) {
		slider1_props.ratio = /*cslRatio*/ ctx[3];
	}

	slider1 = new _Slider_svelte__WEBPACK_IMPORTED_MODULE_17__["default"]({ props: slider1_props, $$inline: true });
	svelte_internal__WEBPACK_IMPORTED_MODULE_0__.binding_callbacks.push(() => (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bind)(slider1, 'ratio', slider1_ratio_binding));
	csllist = new _v2_CslList_svelte__WEBPACK_IMPORTED_MODULE_20__["default"]({ $$inline: true });

	function cmdeditor_textareaEl_binding(value) {
		/*cmdeditor_textareaEl_binding*/ ctx[26](value);
	}

	function cmdeditor_selected_binding(value) {
		/*cmdeditor_selected_binding*/ ctx[27](value);
	}

	let cmdeditor_props = {};

	if (/*cmdTextElement*/ ctx[10] !== void 0) {
		cmdeditor_props.textareaEl = /*cmdTextElement*/ ctx[10];
	}

	if (/*cmdSelected*/ ctx[11] !== void 0) {
		cmdeditor_props.selected = /*cmdSelected*/ ctx[11];
	}

	cmdeditor = new _CmdEditor_svelte__WEBPACK_IMPORTED_MODULE_9__["default"]({ props: cmdeditor_props, $$inline: true });
	svelte_internal__WEBPACK_IMPORTED_MODULE_0__.binding_callbacks.push(() => (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bind)(cmdeditor, 'textareaEl', cmdeditor_textareaEl_binding));
	svelte_internal__WEBPACK_IMPORTED_MODULE_0__.binding_callbacks.push(() => (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bind)(cmdeditor, 'selected', cmdeditor_selected_binding));

	function slider2_ratio_binding(value) {
		/*slider2_ratio_binding*/ ctx[28](value);
	}

	let slider2_props = {};

	if (/*cmdRatio*/ ctx[4] !== void 0) {
		slider2_props.ratio = /*cmdRatio*/ ctx[4];
	}

	slider2 = new _Slider_svelte__WEBPACK_IMPORTED_MODULE_17__["default"]({ props: slider2_props, $$inline: true });
	svelte_internal__WEBPACK_IMPORTED_MODULE_0__.binding_callbacks.push(() => (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bind)(slider2, 'ratio', slider2_ratio_binding));
	cmdlist = new _v2_CmdList_svelte__WEBPACK_IMPORTED_MODULE_18__["default"]({ $$inline: true });

	const block = {
		c: function create() {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(header.$$.fragment);
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			main = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("main");
			div3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(cqleditor.$$.fragment);
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(slider0.$$.fragment);
			t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(subjectlookup.$$.fragment);
			t3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(aliaslookup.$$.fragment);
			t4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(cqllist.$$.fragment);
			t5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(csleditor.$$.fragment);
			t6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(slider1.$$.fragment);
			t7 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(csllist.$$.fragment);
			t8 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div9 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div7 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(cmdeditor.$$.fragment);
			t9 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(slider2.$$.fragment);
			t10 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div8 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(cmdlist.$$.fragment);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div0, "class", "text-green-400");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(div0, "height", "calc(" + /*cqlRatio*/ ctx[2] + "vh - 20px)");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div0, file, 112, 6, 2803);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div1, "class", "flex flex-row items-center");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div1, file, 124, 8, 3197);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div2, "class", "mt-6");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(div2, "height", "calc(100vh * " + (1 - /*cqlRatio*/ ctx[2] / 100) + " - 80px)");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div2, file, 120, 6, 3084);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div3, "class", "fixed w-full");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div3, "hidden", /*currentTab*/ ctx[13] !== 0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div3, file, 111, 4, 2737);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div4, "class", "text-green-400");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(div4, "height", "calc(" + /*cslRatio*/ ctx[3] + "vh - 20px)");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div4, file, 132, 6, 3472);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div5, "class", "mt-6");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(div5, "height", "calc(100vh * " + (1 - /*cslRatio*/ ctx[3] / 100) + " - 50px)");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div5, file, 139, 6, 3720);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div6, "class", "fixed w-full");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div6, "hidden", /*currentTab*/ ctx[13] !== 1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div6, file, 131, 4, 3406);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div7, "class", "text-green-400");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(div7, "height", "calc(" + /*cmdRatio*/ ctx[4] + "vh - 20px)");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div7, file, 147, 6, 3942);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div8, "class", "mt-6 overflow-hidden");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(div8, "height", "calc(100vh * " + (1 - /*cmdRatio*/ ctx[4] / 100) + " - 44px)");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div8, file, 154, 6, 4190);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div9, "class", "fixed w-full");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div9, "hidden", /*currentTab*/ ctx[13] !== 2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div9, file, 146, 4, 3876);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(main, "class", "relative");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(main, file, 110, 2, 2692);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(header, target, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, t0, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, main, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(main, div3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, div0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(cqleditor, div0, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, t1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(slider0, div3, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, t2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, div2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, div1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(subjectlookup, div1, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, t3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(aliaslookup, div1, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, t4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(cqllist, div2, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(main, t5);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(main, div6);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, div4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(csleditor, div4, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, t6);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(slider1, div6, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, t7);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, div5);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(csllist, div5, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(main, t8);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(main, div9);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div9, div7);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(cmdeditor, div7, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div9, t9);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(slider2, div9, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div9, t10);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div9, div8);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(cmdlist, div8, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const header_changes = {};
			if (dirty[0] & /*version*/ 1) header_changes.version = /*version*/ ctx[0];
			if (dirty[0] & /*currentTab*/ 8192) header_changes.currentTab = /*currentTab*/ ctx[13];
			if (dirty[0] & /*currentTab*/ 8192) header_changes.setTab = /*func*/ ctx[16];

			if (!updating_openMenu && dirty[0] & /*openMenu*/ 4096) {
				updating_openMenu = true;
				header_changes.openMenu = /*openMenu*/ ctx[12];
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_flush_callback)(() => updating_openMenu = false);
			}

			header.$set(header_changes);
			const cqleditor_changes = {};

			if (!updating_textareaEl && dirty[0] & /*cqlTextElement*/ 32) {
				updating_textareaEl = true;
				cqleditor_changes.textareaEl = /*cqlTextElement*/ ctx[5];
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_flush_callback)(() => updating_textareaEl = false);
			}

			if (!updating_selected && dirty[0] & /*cqlSelected*/ 64) {
				updating_selected = true;
				cqleditor_changes.selected = /*cqlSelected*/ ctx[6];
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_flush_callback)(() => updating_selected = false);
			}

			if (!updating_paste && dirty[0] & /*cqlPaste*/ 128) {
				updating_paste = true;
				cqleditor_changes.paste = /*cqlPaste*/ ctx[7];
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_flush_callback)(() => updating_paste = false);
			}

			cqleditor.$set(cqleditor_changes);

			if (!current || dirty[0] & /*cqlRatio*/ 4) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(div0, "height", "calc(" + /*cqlRatio*/ ctx[2] + "vh - 20px)");
			}

			const slider0_changes = {};

			if (!updating_ratio && dirty[0] & /*cqlRatio*/ 4) {
				updating_ratio = true;
				slider0_changes.ratio = /*cqlRatio*/ ctx[2];
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_flush_callback)(() => updating_ratio = false);
			}

			slider0.$set(slider0_changes);

			if (!current || dirty[0] & /*cqlRatio*/ 4) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(div2, "height", "calc(100vh * " + (1 - /*cqlRatio*/ ctx[2] / 100) + " - 80px)");
			}

			if (!current || dirty[0] & /*currentTab*/ 8192) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div3, "hidden", /*currentTab*/ ctx[13] !== 0);
			}

			const csleditor_changes = {};

			if (!updating_textareaEl_1 && dirty[0] & /*cslTextElement*/ 256) {
				updating_textareaEl_1 = true;
				csleditor_changes.textareaEl = /*cslTextElement*/ ctx[8];
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_flush_callback)(() => updating_textareaEl_1 = false);
			}

			if (!updating_selected_1 && dirty[0] & /*cslSelected*/ 512) {
				updating_selected_1 = true;
				csleditor_changes.selected = /*cslSelected*/ ctx[9];
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_flush_callback)(() => updating_selected_1 = false);
			}

			csleditor.$set(csleditor_changes);

			if (!current || dirty[0] & /*cslRatio*/ 8) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(div4, "height", "calc(" + /*cslRatio*/ ctx[3] + "vh - 20px)");
			}

			const slider1_changes = {};

			if (!updating_ratio_1 && dirty[0] & /*cslRatio*/ 8) {
				updating_ratio_1 = true;
				slider1_changes.ratio = /*cslRatio*/ ctx[3];
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_flush_callback)(() => updating_ratio_1 = false);
			}

			slider1.$set(slider1_changes);

			if (!current || dirty[0] & /*cslRatio*/ 8) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(div5, "height", "calc(100vh * " + (1 - /*cslRatio*/ ctx[3] / 100) + " - 50px)");
			}

			if (!current || dirty[0] & /*currentTab*/ 8192) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div6, "hidden", /*currentTab*/ ctx[13] !== 1);
			}

			const cmdeditor_changes = {};

			if (!updating_textareaEl_2 && dirty[0] & /*cmdTextElement*/ 1024) {
				updating_textareaEl_2 = true;
				cmdeditor_changes.textareaEl = /*cmdTextElement*/ ctx[10];
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_flush_callback)(() => updating_textareaEl_2 = false);
			}

			if (!updating_selected_2 && dirty[0] & /*cmdSelected*/ 2048) {
				updating_selected_2 = true;
				cmdeditor_changes.selected = /*cmdSelected*/ ctx[11];
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_flush_callback)(() => updating_selected_2 = false);
			}

			cmdeditor.$set(cmdeditor_changes);

			if (!current || dirty[0] & /*cmdRatio*/ 16) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(div7, "height", "calc(" + /*cmdRatio*/ ctx[4] + "vh - 20px)");
			}

			const slider2_changes = {};

			if (!updating_ratio_2 && dirty[0] & /*cmdRatio*/ 16) {
				updating_ratio_2 = true;
				slider2_changes.ratio = /*cmdRatio*/ ctx[4];
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_flush_callback)(() => updating_ratio_2 = false);
			}

			slider2.$set(slider2_changes);

			if (!current || dirty[0] & /*cmdRatio*/ 16) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(div8, "height", "calc(100vh * " + (1 - /*cmdRatio*/ ctx[4] / 100) + " - 44px)");
			}

			if (!current || dirty[0] & /*currentTab*/ 8192) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div9, "hidden", /*currentTab*/ ctx[13] !== 2);
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(header.$$.fragment, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(cqleditor.$$.fragment, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(slider0.$$.fragment, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(subjectlookup.$$.fragment, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(aliaslookup.$$.fragment, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(cqllist.$$.fragment, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(csleditor.$$.fragment, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(slider1.$$.fragment, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(csllist.$$.fragment, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(cmdeditor.$$.fragment, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(slider2.$$.fragment, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(cmdlist.$$.fragment, local);

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_render_callback)(() => {
				if (!current) return;
				if (!main_transition) main_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(main, svelte_transition__WEBPACK_IMPORTED_MODULE_2__.fade, {}, true);
				main_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(header.$$.fragment, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(cqleditor.$$.fragment, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(slider0.$$.fragment, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(subjectlookup.$$.fragment, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(aliaslookup.$$.fragment, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(cqllist.$$.fragment, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(csleditor.$$.fragment, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(slider1.$$.fragment, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(csllist.$$.fragment, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(cmdeditor.$$.fragment, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(slider2.$$.fragment, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(cmdlist.$$.fragment, local);
			if (!main_transition) main_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(main, svelte_transition__WEBPACK_IMPORTED_MODULE_2__.fade, {}, false);
			main_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(header, detaching);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(t0);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(main);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(cqleditor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(slider0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(subjectlookup);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(aliaslookup);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(cqllist);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(csleditor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(slider1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(csllist);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(cmdeditor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(slider2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(cmdlist);
			if (detaching && main_transition) main_transition.end();
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(103:0) {#if ready}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let notification;
	let t0;
	let promise;
	let t1;
	let server;
	let t2;
	let if_block_anchor;
	let current;
	let mounted;
	let dispose;
	notification = new _Notification_svelte__WEBPACK_IMPORTED_MODULE_16__["default"]({ $$inline: true });

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: false,
		pending: create_pending_block,
		then: create_then_block,
		catch: create_catch_block,
		value: 32,
		blocks: [,,,]
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.handle_promise)(promise = _persist__WEBPACK_IMPORTED_MODULE_3__.isExcel, info);
	server = new _Server_svelte__WEBPACK_IMPORTED_MODULE_10__["default"]({ $$inline: true });
	let if_block = /*ready*/ ctx[1] && create_if_block(ctx);

	const block = {
		c: function create() {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(notification.$$.fragment);
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			info.block.c();
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(server.$$.fragment);
			t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			if (if_block) if_block.c();
			if_block_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(notification, target, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, t0, anchor);
			info.block.m(target, info.anchor = anchor);
			info.mount = () => t1.parentNode;
			info.anchor = t1;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, t1, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(server, target, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, t2, anchor);
			if (if_block) if_block.m(target, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, if_block_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(window, "keydown", /*handleKeydown*/ ctx[15], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_await_block_branch)(info, ctx, dirty);

			if (/*ready*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*ready*/ 2) {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block, 1, 1, () => {
					if_block = null;
				});

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(notification.$$.fragment, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(info.block);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(server.$$.fragment, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(notification.$$.fragment, local);

			for (let i = 0; i < 3; i += 1) {
				const block = info.blocks[i];
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(block);
			}

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(server.$$.fragment, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(notification, detaching);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(t0);
			info.block.d(detaching);
			info.token = null;
			info = null;
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(t1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(server, detaching);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(t2);
			if (if_block) if_block.d(detaching);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)('EditorApp', slots, []);
	let { version = "" } = $$props;
	let ready = false;
	let cqlRatio = 50;
	let cslRatio = 50;
	let cmdRatio = 50;
	let cqlTextElement;
	let cqlSelected;
	let cqlPaste;
	let cslTextElement;
	let cslSelected;
	let cmdTextElement;
	let cmdSelected;
	let openMenu;
	let currentTab = 0;

	const cqlMenu = {
		KeyR: () => (0,_submit__WEBPACK_IMPORTED_MODULE_5__.submitQuery)(cqlSelected.snippet)
	};

	const cslMenu = {
		KeyR: () => (0,_submit__WEBPACK_IMPORTED_MODULE_5__.submitScript)(cslSelected.snippet, false),
		KeyB: () => (0,_submit__WEBPACK_IMPORTED_MODULE_5__.submitScript)(cslSelected.snippet, true)
	};

	const cmdMenu = {
		KeyB: () => (0,_submit__WEBPACK_IMPORTED_MODULE_5__.parseCmd)(cmdSelected.snippet),
		KeyM: () => (0,_menus__WEBPACK_IMPORTED_MODULE_6__.createMenu)(),
		KeyR: () => (0,_menus__WEBPACK_IMPORTED_MODULE_6__.initMenus)()
	};

	const menu = option => {
		switch (currentTab) {
			case 0:
				cqlMenu[option] ? cqlMenu[option]() : null;
				break;
			case 1:
				cslMenu[option] ? cslMenu[option]() : null;
				break;
			case 2:
				cmdMenu[option] ? cmdMenu[option]() : null;
		}
	};

	const handleKeydown = ev => {
		if (ev.altKey) {
			switch (ev.code) {
				case "KeyH":
					break;
				default:
					if (menu(ev.code)) ev.preventDefault();
			}
		}
	};

	(0,svelte__WEBPACK_IMPORTED_MODULE_1__.onMount)(async () => {
		$$invalidate(1, ready = true);
		__webpack_require__.g.ready = true;

		//serversStore.init();
		if (await _persist__WEBPACK_IMPORTED_MODULE_3__.isExcel) {
			
		} //  await initMenus();
	});

	(0,svelte__WEBPACK_IMPORTED_MODULE_1__.onDestroy)(() => unsubscribe());
	const writable_props = ['version'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EditorApp> was created with unknown prop '${key}'`);
	});

	const func = tab => $$invalidate(13, currentTab = tab);

	function header_openMenu_binding(value) {
		openMenu = value;
		$$invalidate(12, openMenu);
	}

	function cqleditor_textareaEl_binding(value) {
		cqlTextElement = value;
		$$invalidate(5, cqlTextElement);
	}

	function cqleditor_selected_binding(value) {
		cqlSelected = value;
		$$invalidate(6, cqlSelected);
	}

	function cqleditor_paste_binding(value) {
		cqlPaste = value;
		$$invalidate(7, cqlPaste);
	}

	function slider0_ratio_binding(value) {
		cqlRatio = value;
		$$invalidate(2, cqlRatio);
	}

	const alias_handler = ev => cqlPaste(ev.detail.text);

	function csleditor_textareaEl_binding(value) {
		cslTextElement = value;
		$$invalidate(8, cslTextElement);
	}

	function csleditor_selected_binding(value) {
		cslSelected = value;
		$$invalidate(9, cslSelected);
	}

	function slider1_ratio_binding(value) {
		cslRatio = value;
		$$invalidate(3, cslRatio);
	}

	function cmdeditor_textareaEl_binding(value) {
		cmdTextElement = value;
		$$invalidate(10, cmdTextElement);
	}

	function cmdeditor_selected_binding(value) {
		cmdSelected = value;
		$$invalidate(11, cmdSelected);
	}

	function slider2_ratio_binding(value) {
		cmdRatio = value;
		$$invalidate(4, cmdRatio);
	}

	$$self.$$set = $$props => {
		if ('version' in $$props) $$invalidate(0, version = $$props.version);
	};

	$$self.$capture_state = () => ({
		onDestroy: svelte__WEBPACK_IMPORTED_MODULE_1__.onDestroy,
		onMount: svelte__WEBPACK_IMPORTED_MODULE_1__.onMount,
		fade: svelte_transition__WEBPACK_IMPORTED_MODULE_2__.fade,
		isExcel: _persist__WEBPACK_IMPORTED_MODULE_3__.isExcel,
		serversStore: _stores__WEBPACK_IMPORTED_MODULE_4__.serversStore,
		parseCmd: _submit__WEBPACK_IMPORTED_MODULE_5__.parseCmd,
		submitQuery: _submit__WEBPACK_IMPORTED_MODULE_5__.submitQuery,
		submitScript: _submit__WEBPACK_IMPORTED_MODULE_5__.submitScript,
		createMenu: _menus__WEBPACK_IMPORTED_MODULE_6__.createMenu,
		initMenus: _menus__WEBPACK_IMPORTED_MODULE_6__.initMenus,
		CqlEditor: _CqlEditor_svelte__WEBPACK_IMPORTED_MODULE_7__["default"],
		CslEditor: _CslEditor_svelte__WEBPACK_IMPORTED_MODULE_8__["default"],
		CmdEditor: _CmdEditor_svelte__WEBPACK_IMPORTED_MODULE_9__["default"],
		Server: _Server_svelte__WEBPACK_IMPORTED_MODULE_10__["default"],
		Login: _Login_svelte__WEBPACK_IMPORTED_MODULE_11__["default"],
		WebLogin: _WebLogin_svelte__WEBPACK_IMPORTED_MODULE_12__["default"],
		Header: _Header_svelte__WEBPACK_IMPORTED_MODULE_13__["default"],
		SubjectLookup: _SubjectLookup_svelte__WEBPACK_IMPORTED_MODULE_14__["default"],
		AliasLookup: _AliasLookup_svelte__WEBPACK_IMPORTED_MODULE_15__["default"],
		Notification: _Notification_svelte__WEBPACK_IMPORTED_MODULE_16__["default"],
		Slider: _Slider_svelte__WEBPACK_IMPORTED_MODULE_17__["default"],
		CmdList: _v2_CmdList_svelte__WEBPACK_IMPORTED_MODULE_18__["default"],
		CqlList: _v2_CqlList_svelte__WEBPACK_IMPORTED_MODULE_19__["default"],
		CslList: _v2_CslList_svelte__WEBPACK_IMPORTED_MODULE_20__["default"],
		version,
		ready,
		cqlRatio,
		cslRatio,
		cmdRatio,
		cqlTextElement,
		cqlSelected,
		cqlPaste,
		cslTextElement,
		cslSelected,
		cmdTextElement,
		cmdSelected,
		openMenu,
		currentTab,
		cqlMenu,
		cslMenu,
		cmdMenu,
		menu,
		handleKeydown
	});

	$$self.$inject_state = $$props => {
		if ('version' in $$props) $$invalidate(0, version = $$props.version);
		if ('ready' in $$props) $$invalidate(1, ready = $$props.ready);
		if ('cqlRatio' in $$props) $$invalidate(2, cqlRatio = $$props.cqlRatio);
		if ('cslRatio' in $$props) $$invalidate(3, cslRatio = $$props.cslRatio);
		if ('cmdRatio' in $$props) $$invalidate(4, cmdRatio = $$props.cmdRatio);
		if ('cqlTextElement' in $$props) $$invalidate(5, cqlTextElement = $$props.cqlTextElement);
		if ('cqlSelected' in $$props) $$invalidate(6, cqlSelected = $$props.cqlSelected);
		if ('cqlPaste' in $$props) $$invalidate(7, cqlPaste = $$props.cqlPaste);
		if ('cslTextElement' in $$props) $$invalidate(8, cslTextElement = $$props.cslTextElement);
		if ('cslSelected' in $$props) $$invalidate(9, cslSelected = $$props.cslSelected);
		if ('cmdTextElement' in $$props) $$invalidate(10, cmdTextElement = $$props.cmdTextElement);
		if ('cmdSelected' in $$props) $$invalidate(11, cmdSelected = $$props.cmdSelected);
		if ('openMenu' in $$props) $$invalidate(12, openMenu = $$props.openMenu);
		if ('currentTab' in $$props) $$invalidate(13, currentTab = $$props.currentTab);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		version,
		ready,
		cqlRatio,
		cslRatio,
		cmdRatio,
		cqlTextElement,
		cqlSelected,
		cqlPaste,
		cslTextElement,
		cslSelected,
		cmdTextElement,
		cmdSelected,
		openMenu,
		currentTab,
		menu,
		handleKeydown,
		func,
		header_openMenu_binding,
		cqleditor_textareaEl_binding,
		cqleditor_selected_binding,
		cqleditor_paste_binding,
		slider0_ratio_binding,
		alias_handler,
		csleditor_textareaEl_binding,
		csleditor_selected_binding,
		slider1_ratio_binding,
		cmdeditor_textareaEl_binding,
		cmdeditor_selected_binding,
		slider2_ratio_binding
	];
}

class EditorApp extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {
	constructor(options) {
		super(options);
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, { version: 0 }, null, [-1, -1]);

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "EditorApp",
			options,
			id: create_fragment.name
		});
	}

	get version() {
		throw new Error("<EditorApp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set version(value) {
		throw new Error("<EditorApp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

if (module && module.hot) {}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EditorApp);



/***/ }),

/***/ "./JS/Components/Header.svelte":
/*!*************************************!*\
  !*** ./JS/Components/Header.svelte ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var svelte_transition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte/transition */ "./node_modules/svelte/transition/index.mjs");
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../stores */ "./JS/stores.ts");
/* harmony import */ var _Server_svelte__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Server.svelte */ "./JS/Components/Server.svelte");
/* harmony import */ var svelte__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! svelte */ "./node_modules/svelte/index.mjs");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_loader_lib_hot_api_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./node_modules/svelte-loader/lib/hot-api.js */ "./node_modules/svelte-loader/lib/hot-api.js");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_hmr_runtime_proxy_adapter_dom_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js */ "./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/* JS\Components\Header.svelte generated by Svelte v3.59.2 */


const { console: console_1 } = svelte_internal__WEBPACK_IMPORTED_MODULE_0__.globals;




const file = "JS\\Components\\Header.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[24] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[27] = list[i];
	return child_ctx;
}

// (33:0) {#if openMenu}
function create_if_block_1(ctx) {
	let div1;
	let div0;
	let div1_transition;
	let current;
	let mounted;
	let dispose;
	let each_value_1 = /*options*/ ctx[5][/*currentTab*/ ctx[2]];
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			div1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div0, "class", "mt-1 bg-slate-400 rounded-br-md rounded-tr-md border-slate-600 border-l-2 border-solid");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div0, file, 39, 4, 939);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div1, "class", "peer absolute top-10 z-50");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div1, file, 34, 2, 818);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div1, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div0, null);
				}
			}

			current = true;

			if (!mounted) {
				dispose = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(div1, "mouseleave", /*mouseleave_handler*/ ctx[11], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*options, currentTab, callMenu*/ 292) {
				each_value_1 = /*options*/ ctx[5][/*currentTab*/ ctx[2]];
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		i: function intro(local) {
			if (current) return;

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_render_callback)(() => {
				if (!current) return;
				if (!div1_transition) div1_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(div1, svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fade, {}, true);
				div1_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			if (!div1_transition) div1_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(div1, svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fade, {}, false);
			div1_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_each)(each_blocks, detaching);
			if (detaching && div1_transition) div1_transition.end();
			mounted = false;
			dispose();
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(33:0) {#if openMenu}",
		ctx
	});

	return block;
}

// (46:8) {:else}
function create_else_block(ctx) {
	let button;
	let span;
	let t0_value = /*m*/ ctx[27].title + "";
	let t0;
	let t1;
	let em;
	let t2;
	let t3_value = /*m*/ ctx[27].command + "";
	let t3;
	let t4;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[10](/*m*/ ctx[27]);
	}

	const block = {
		c: function create() {
			button = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			span = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t0_value);
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			em = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("em");
			t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)("Alt-");
			t3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t3_value);
			t4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(span, file, 50, 12, 1435);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(em, "class", "pl-4 text-sm");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(em, file, 51, 12, 1471);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button, "class", "flex justify-between rounded w-full text-left py-2 px-4 outline-none hover:bg-slate-300 overflow-hidden font-semibold");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button, file, 46, 10, 1212);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, button, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button, span);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(span, t0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button, t1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button, em);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(em, t2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(em, t3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button, t4);

			if (!mounted) {
				dispose = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button, "click", click_handler, false, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*options, currentTab*/ 36 && t0_value !== (t0_value = /*m*/ ctx[27].title + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t0, t0_value);
			if (dirty & /*options, currentTab*/ 36 && t3_value !== (t3_value = /*m*/ ctx[27].command + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t3, t3_value);
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(button);
			mounted = false;
			dispose();
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(46:8) {:else}",
		ctx
	});

	return block;
}

// (44:8) {#if m.command === "-"}
function create_if_block_2(ctx) {
	let hr;

	const block = {
		c: function create() {
			hr = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("hr");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(hr, "class", "border-slate-500 my-1 ml-2 mr-2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(hr, file, 44, 10, 1137);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, hr, anchor);
		},
		p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(hr);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(44:8) {#if m.command === \\\"-\\\"}",
		ctx
	});

	return block;
}

// (43:6) {#each options[currentTab] as m}
function create_each_block_1(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*m*/ ctx[27].command === "-") return create_if_block_2;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(if_block_anchor);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(43:6) {#each options[currentTab] as m}",
		ctx
	});

	return block;
}

// (108:4) {#if openServers}
function create_if_block(ctx) {
	let button;
	let div;
	let button_transition;
	let current;
	let mounted;
	let dispose;
	let each_value = (/*$serversStore*/ ctx[6] ?? []).filter(/*func*/ ctx[16]);
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			button = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div, "class", "mt-1 bg-slate-400 rounded-b-md rounded-tr-md border-slate-600 border-l-2 border-solid");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div, file, 113, 8, 3366);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button, "class", "peer fixed top-10 w-36");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button, file, 108, 6, 3227);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, button, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button, div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div, null);
				}
			}

			current = true;

			if (!mounted) {
				dispose = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button, "click", /*click_handler_6*/ ctx[18], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*global, $serversStore, $stateStore, stateStore*/ 192) {
				each_value = (/*$serversStore*/ ctx[6] ?? []).filter(/*func*/ ctx[16]);
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: function intro(local) {
			if (current) return;

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_render_callback)(() => {
				if (!current) return;
				if (!button_transition) button_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(button, svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fade, {}, true);
				button_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			if (!button_transition) button_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(button, svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fade, {}, false);
			button_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(button);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_each)(each_blocks, detaching);
			if (detaching && button_transition) button_transition.end();
			mounted = false;
			dispose();
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(108:4) {#if openServers}",
		ctx
	});

	return block;
}

// (117:10) {#each ($serversStore ?? []).filter((e) => e.id !== $stateStore.contextId) as s}
function create_each_block(ctx) {
	let button;
	let t_value = /*s*/ ctx[24].name + "";
	let t;
	let mounted;
	let dispose;

	function click_handler_5() {
		return /*click_handler_5*/ ctx[17](/*s*/ ctx[24]);
	}

	const block = {
		c: function create() {
			button = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			t = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t_value);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button, "class", "rounded block w-full text-left py-2 pl-4 pr-2 outline-none hover:bg-slate-300 overflow-hidden font-semibold");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button, file, 117, 12, 3592);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, button, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button, t);

			if (!mounted) {
				dispose = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button, "click", click_handler_5, false, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*$serversStore, $stateStore*/ 192 && t_value !== (t_value = /*s*/ ctx[24].name + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(button);
			mounted = false;
			dispose();
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(117:10) {#each ($serversStore ?? []).filter((e) => e.id !== $stateStore.contextId) as s}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let t0;
	let div4;
	let div0;
	let button0;
	let svg0;
	let path0;
	let t1;
	let div1;
	let button1;
	let t3;
	let button2;
	let t5;
	let button3;
	let t7;
	let div2;
	let t8;
	let button4;
	let svg1;
	let path1;
	let t9;
	let span;
	let t10_value = ((/*$serversStore*/ ctx[6] ?? []).find(/*func_1*/ ctx[19])?.name ?? "") + "";
	let t10;
	let t11;
	let div3;
	let t12;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*openMenu*/ ctx[0] && create_if_block_1(ctx);
	let if_block1 = /*openServers*/ ctx[4] && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			button0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			svg0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			button1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			button1.textContent = "CQL";
			t3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			button2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			button2.textContent = "CSL";
			t5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			button3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			button3.textContent = "CMD";
			t7 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			if (if_block1) if_block1.c();
			t8 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			button4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			svg1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			t9 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			span = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");
			t10 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t10_value);
			t11 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			t12 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(/*version*/ ctx[1]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "stroke-linecap", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "stroke-linejoin", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "stroke-width", "2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "d", "M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path0, file, 75, 8, 2130);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "class", "h-6 w-6");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "fill", "none");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "viewBox", "0 0 24 24");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "stroke", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg0, file, 68, 6, 1957);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button0, "class", "flex flex-row font-semibold peer-hover:bg-slate-300 hover:bg-slate-300 py-2 h-10 rounded-tr-md box-border");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(button0, "selected", /*openMenu*/ ctx[0]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button0, file, 63, 4, 1734);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div0, "class", "w-32");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div0, file, 62, 2, 1710);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button1, "class", "px-4 font-semibold py-2 rounded-t");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(button1, "active-tab", /*currentTab*/ ctx[2] === 0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(button1, "inactive-tab", /*currentTab*/ ctx[2] !== 0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button1, file, 86, 4, 2468);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button2, "class", "px-4 font-semibold py-2 rounded-t");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(button2, "active-tab", /*currentTab*/ ctx[2] === 1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(button2, "inactive-tab", /*currentTab*/ ctx[2] !== 1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button2, file, 92, 4, 2671);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button3, "class", "px-4 font-semibold py-2 rounded-t");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(button3, "active-tab", /*currentTab*/ ctx[2] === 2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(button3, "inactive-tab", /*currentTab*/ ctx[2] !== 2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button3, file, 98, 4, 2874);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div1, "class", "inline-flex");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div1, file, 85, 2, 2437);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "stroke-linecap", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "stroke-linejoin", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "stroke-width", "2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "d", "M5 12h14M5 12a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v4a2 2 0 01-2 2M5 12a2 2 0 00-2 2v4a2 2 0 002 2h14a2 2 0 002-2v-4a2 2 0 00-2-2m-2-4h.01M17 16h.01");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path1, file, 141, 8, 4428);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "class", "h-6 w-6");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "fill", "none");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "viewBox", "0 0 24 24");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "stroke", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg1, file, 134, 6, 4255);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(span, "class", "text-nowrap ml-1");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(span, file, 148, 6, 4732);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button4, "class", "flex flex-row font-semibold peer-hover:bg-slate-300 hover:bg-slate-300 w-auto p-2 h-10 rounded-tr-md box-border");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(button4, "selected", /*openServers*/ ctx[4]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button4, file, 129, 4, 4017);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div2, file, 106, 2, 3147);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div3, "class", "w-full font-thin mr-6 text-right");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div3, file, 154, 2, 4907);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div4, "class", "sticky top-0 z-40 flex flex-row items-center text-teal-900 bg-slate-400 overflow-hidden");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div4, file, 59, 0, 1600);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, t0, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div4, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, div0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div0, button0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button0, svg0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg0, path0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, t1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, div1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, button1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, t3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, button2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, t5);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, button3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, t7);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, div2);
			if (if_block1) if_block1.m(div2, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, t8);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, button4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button4, svg1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg1, path1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button4, t9);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button4, span);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(span, t10);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, t11);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, div3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, t12);
			current = true;

			if (!mounted) {
				dispose = [
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button0, "click", /*click_handler_1*/ ctx[12], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button1, "click", /*click_handler_2*/ ctx[13], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button2, "click", /*click_handler_3*/ ctx[14], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button3, "click", /*click_handler_4*/ ctx[15], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button4, "click", /*click_handler_7*/ ctx[20], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(div2, "mouseleave", /*mouseleave_handler_1*/ ctx[21], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*openMenu*/ ctx[0]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*openMenu*/ 1) {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
			}

			if (!current || dirty & /*openMenu*/ 1) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(button0, "selected", /*openMenu*/ ctx[0]);
			}

			if (!current || dirty & /*currentTab*/ 4) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(button1, "active-tab", /*currentTab*/ ctx[2] === 0);
			}

			if (!current || dirty & /*currentTab*/ 4) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(button1, "inactive-tab", /*currentTab*/ ctx[2] !== 0);
			}

			if (!current || dirty & /*currentTab*/ 4) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(button2, "active-tab", /*currentTab*/ ctx[2] === 1);
			}

			if (!current || dirty & /*currentTab*/ 4) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(button2, "inactive-tab", /*currentTab*/ ctx[2] !== 1);
			}

			if (!current || dirty & /*currentTab*/ 4) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(button3, "active-tab", /*currentTab*/ ctx[2] === 2);
			}

			if (!current || dirty & /*currentTab*/ 4) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(button3, "inactive-tab", /*currentTab*/ ctx[2] !== 2);
			}

			if (/*openServers*/ ctx[4]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*openServers*/ 16) {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block1, 1);
					if_block1.m(div2, t8);
				}
			} else if (if_block1) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
			}

			if ((!current || dirty & /*$serversStore, $stateStore*/ 192) && t10_value !== (t10_value = ((/*$serversStore*/ ctx[6] ?? []).find(/*func_1*/ ctx[19])?.name ?? "") + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t10, t10_value);

			if (!current || dirty & /*openServers*/ 16) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(button4, "selected", /*openServers*/ ctx[4]);
			}

			if (!current || dirty & /*version*/ 2) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t12, /*version*/ ctx[1]);
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block1);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(t0);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div4);
			if (if_block1) if_block1.d();
			mounted = false;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.run_all)(dispose);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $serversStore;
	let $stateStore;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_store)(_stores__WEBPACK_IMPORTED_MODULE_2__.serversStore, 'serversStore');
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, _stores__WEBPACK_IMPORTED_MODULE_2__.serversStore, $$value => $$invalidate(6, $serversStore = $$value));
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_store)(_stores__WEBPACK_IMPORTED_MODULE_2__.stateStore, 'stateStore');
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, _stores__WEBPACK_IMPORTED_MODULE_2__.stateStore, $$value => $$invalidate(7, $stateStore = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)('Header', slots, []);
	let { version } = $$props;
	let { menu } = $$props;
	let { openMenu = false } = $$props;
	let { currentTab } = $$props;
	let { setTab } = $$props;
	let openServers = false;
	let serverOption = 0;
	let options = [];
	fetch("./assets/data/menu.json").then(response => response.json()).then(json => $$invalidate(5, options = json));

	const callMenu = option => {
		$$invalidate(0, openMenu = false);
		menu(option);
	};

	const unsubscibe = _stores__WEBPACK_IMPORTED_MODULE_2__.stateStore.subscribe(state => console.log(state));

	(0,svelte__WEBPACK_IMPORTED_MODULE_4__.onDestroy)(() => {
		unsubscibe();
	});

	$$self.$$.on_mount.push(function () {
		if (version === undefined && !('version' in $$props || $$self.$$.bound[$$self.$$.props['version']])) {
			console_1.warn("<Header> was created without expected prop 'version'");
		}

		if (menu === undefined && !('menu' in $$props || $$self.$$.bound[$$self.$$.props['menu']])) {
			console_1.warn("<Header> was created without expected prop 'menu'");
		}

		if (currentTab === undefined && !('currentTab' in $$props || $$self.$$.bound[$$self.$$.props['currentTab']])) {
			console_1.warn("<Header> was created without expected prop 'currentTab'");
		}

		if (setTab === undefined && !('setTab' in $$props || $$self.$$.bound[$$self.$$.props['setTab']])) {
			console_1.warn("<Header> was created without expected prop 'setTab'");
		}
	});

	const writable_props = ['version', 'menu', 'openMenu', 'currentTab', 'setTab'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Header> was created with unknown prop '${key}'`);
	});

	const click_handler = m => callMenu(m.command);
	const mouseleave_handler = () => $$invalidate(0, openMenu = false);
	const click_handler_1 = () => $$invalidate(0, openMenu = !openMenu);
	const click_handler_2 = () => setTab(0);
	const click_handler_3 = () => setTab(1);
	const click_handler_4 = () => setTab(2);
	const func = e => e.id !== $stateStore.contextId;

	const click_handler_5 = s => {
		__webpack_require__.g.blazorLib.invokeMethodAsync("SelectContext", s.id);
		_stores__WEBPACK_IMPORTED_MODULE_2__.stateStore.context(s.id);
	};

	const click_handler_6 = () => $$invalidate(4, openServers = false);
	const func_1 = s => s.id === $stateStore.contextId;
	const click_handler_7 = () => $$invalidate(4, openServers = !openServers);
	const mouseleave_handler_1 = () => $$invalidate(4, openServers = false);

	$$self.$$set = $$props => {
		if ('version' in $$props) $$invalidate(1, version = $$props.version);
		if ('menu' in $$props) $$invalidate(9, menu = $$props.menu);
		if ('openMenu' in $$props) $$invalidate(0, openMenu = $$props.openMenu);
		if ('currentTab' in $$props) $$invalidate(2, currentTab = $$props.currentTab);
		if ('setTab' in $$props) $$invalidate(3, setTab = $$props.setTab);
	};

	$$self.$capture_state = () => ({
		fade: svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fade,
		serversStore: _stores__WEBPACK_IMPORTED_MODULE_2__.serversStore,
		stateStore: _stores__WEBPACK_IMPORTED_MODULE_2__.stateStore,
		Server: _Server_svelte__WEBPACK_IMPORTED_MODULE_3__["default"],
		onDestroy: svelte__WEBPACK_IMPORTED_MODULE_4__.onDestroy,
		version,
		menu,
		openMenu,
		currentTab,
		setTab,
		openServers,
		serverOption,
		options,
		callMenu,
		unsubscibe,
		$serversStore,
		$stateStore
	});

	$$self.$inject_state = $$props => {
		if ('version' in $$props) $$invalidate(1, version = $$props.version);
		if ('menu' in $$props) $$invalidate(9, menu = $$props.menu);
		if ('openMenu' in $$props) $$invalidate(0, openMenu = $$props.openMenu);
		if ('currentTab' in $$props) $$invalidate(2, currentTab = $$props.currentTab);
		if ('setTab' in $$props) $$invalidate(3, setTab = $$props.setTab);
		if ('openServers' in $$props) $$invalidate(4, openServers = $$props.openServers);
		if ('serverOption' in $$props) serverOption = $$props.serverOption;
		if ('options' in $$props) $$invalidate(5, options = $$props.options);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		openMenu,
		version,
		currentTab,
		setTab,
		openServers,
		options,
		$serversStore,
		$stateStore,
		callMenu,
		menu,
		click_handler,
		mouseleave_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		func,
		click_handler_5,
		click_handler_6,
		func_1,
		click_handler_7,
		mouseleave_handler_1
	];
}

class Header extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {
	constructor(options) {
		super(options);

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {
			version: 1,
			menu: 9,
			openMenu: 0,
			currentTab: 2,
			setTab: 3
		});

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "Header",
			options,
			id: create_fragment.name
		});
	}

	get version() {
		throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set version(value) {
		throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get menu() {
		throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set menu(value) {
		throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get openMenu() {
		throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set openMenu(value) {
		throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get currentTab() {
		throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set currentTab(value) {
		throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setTab() {
		throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set setTab(value) {
		throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

if (module && module.hot) {}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Header);



/***/ }),

/***/ "./JS/Components/Login.svelte":
/*!************************************!*\
  !*** ./JS/Components/Login.svelte ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var svelte__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte */ "./node_modules/svelte/index.mjs");
/* harmony import */ var svelte_transition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! svelte/transition */ "./node_modules/svelte/transition/index.mjs");
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../stores */ "./JS/stores.ts");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_loader_lib_hot_api_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node_modules/svelte-loader/lib/hot-api.js */ "./node_modules/svelte-loader/lib/hot-api.js");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_hmr_runtime_proxy_adapter_dom_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js */ "./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/* JS\Components\Login.svelte generated by Svelte v3.59.2 */


const { console: console_1 } = svelte_internal__WEBPACK_IMPORTED_MODULE_0__.globals;



const file = "JS\\Components\\Login.svelte";

// (89:0) {#if $stateStore.login}
function create_if_block(ctx) {
	let div;
	let div_transition;
	let current;

	const block = {
		c: function create() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div, "class", "bg-opacity-70 bg-slate-900 z-40 fixed top-0 h-full w-full");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div, file, 89, 2, 2595);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_render_callback)(() => {
				if (!current) return;
				if (!div_transition) div_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(div, svelte_transition__WEBPACK_IMPORTED_MODULE_2__.fade, {}, true);
				div_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			if (!div_transition) div_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(div, svelte_transition__WEBPACK_IMPORTED_MODULE_2__.fade, {}, false);
			div_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div);
			if (detaching && div_transition) div_transition.end();
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(89:0) {#if $stateStore.login}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*$stateStore*/ ctx[0].login && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*$stateStore*/ ctx[0].login) {
				if (if_block) {
					if (dirty & /*$stateStore*/ 1) {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block, 1, 1, () => {
					if_block = null;
				});

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(if_block_anchor);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $serversStore;
	let $stateStore;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_store)(_stores__WEBPACK_IMPORTED_MODULE_3__.serversStore, 'serversStore');
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, _stores__WEBPACK_IMPORTED_MODULE_3__.serversStore, $$value => $$invalidate(3, $serversStore = $$value));
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_store)(_stores__WEBPACK_IMPORTED_MODULE_3__.stateStore, 'stateStore');
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, _stores__WEBPACK_IMPORTED_MODULE_3__.stateStore, $$value => $$invalidate(0, $stateStore = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)('Login', slots, []);
	const url = location.protocol + "//" + location.hostname + (location.port ? ":" + location.port : "") + "/assets/login.html";
	let username;
	let dialog = false;

	const lastUser = _stores__WEBPACK_IMPORTED_MODULE_3__.stateStore.subscribe(state => {
		username = _stores__WEBPACK_IMPORTED_MODULE_3__.serversStore[state.contextId]?.authResponse?.username;
	});

	const prompt = _stores__WEBPACK_IMPORTED_MODULE_3__.stateStore.subscribe(state => {
		if (dialog) {
			if (!state.login) {
				dialog.close();
				dialog = false;
			} else if (state.loginMsg) {
				dialog.messageChild(JSON.stringify({ notice: state.loginMsg }));
				_stores__WEBPACK_IMPORTED_MODULE_3__.stateStore.loginMsg(null);
			}
		} else if (state.login) {
			dialog = true;

			Office.context.ui.displayDialogAsync(
				url,
				{
					height: 28,
					width: 15,
					displayInIframe: true
				},
				result => {
					if (result.status === Office.AsyncResultStatus.Failed) {
						console.error(`${result.error.code} ${result.error.message}`);
					} else {
						dialog = result.value;

						dialog.addEventHandler(Office.EventType.DialogMessageReceived, ev => {
							const msg = JSON.parse(ev.message);

							switch (true) {
								case msg.loaded:
									dialog.messageChild(JSON.stringify({
										username,
										title: $serversStore[state.contextId]?.name
									}));
									break;
								case msg.ok:
									_stores__WEBPACK_IMPORTED_MODULE_3__.stateStore.busy(true);
									__webpack_require__.g.blazorLib.invokeMethodAsync("Authenticate", msg.username, msg.password);
									break;
								case msg.cancel:
									_stores__WEBPACK_IMPORTED_MODULE_3__.stateStore.login(false);
									break;
							}
						});

						dialog.addEventHandler(Office.EventType.DialogEventReceived, ev => {
							if (ev.error === 12006) {
								_stores__WEBPACK_IMPORTED_MODULE_3__.stateStore.login(false);
							}
						});
					}
				}
			);
		}
	});

	(0,svelte__WEBPACK_IMPORTED_MODULE_1__.onDestroy)(() => {
		lastUser();
		prompt();
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Login> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		onDestroy: svelte__WEBPACK_IMPORTED_MODULE_1__.onDestroy,
		fade: svelte_transition__WEBPACK_IMPORTED_MODULE_2__.fade,
		stateStore: _stores__WEBPACK_IMPORTED_MODULE_3__.stateStore,
		serversStore: _stores__WEBPACK_IMPORTED_MODULE_3__.serversStore,
		url,
		username,
		dialog,
		lastUser,
		prompt,
		$serversStore,
		$stateStore
	});

	$$self.$inject_state = $$props => {
		if ('username' in $$props) username = $$props.username;
		if ('dialog' in $$props) dialog = $$props.dialog;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [$stateStore];
}

class Login extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {
	constructor(options) {
		super(options);
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {});

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "Login",
			options,
			id: create_fragment.name
		});
	}
}

if (module && module.hot) {}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Login);



/***/ }),

/***/ "./JS/Components/Notification.svelte":
/*!*******************************************!*\
  !*** ./JS/Components/Notification.svelte ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var svelte__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte */ "./node_modules/svelte/index.mjs");
/* harmony import */ var svelte_transition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! svelte/transition */ "./node_modules/svelte/transition/index.mjs");
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../stores */ "./JS/stores.ts");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_loader_lib_hot_api_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node_modules/svelte-loader/lib/hot-api.js */ "./node_modules/svelte-loader/lib/hot-api.js");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_hmr_runtime_proxy_adapter_dom_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js */ "./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/* JS\Components\Notification.svelte generated by Svelte v3.59.2 */





const file = "JS\\Components\\Notification.svelte";

// (16:0) {#if $stateStore.notify}
function create_if_block(ctx) {
	let div2;
	let button;
	let svg0;
	let path0;
	let line0;
	let line1;
	let t0;
	let div0;
	let svg1;
	let path1;
	let t1;
	let div1;
	let h1;
	let t2_value = /*$stateStore*/ ctx[0].notify.title + "";
	let t2;
	let t3;
	let p;
	let t4_value = /*$stateStore*/ ctx[0].notify.details + "";
	let t4;
	let div2_transition;
	let current;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			button = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			svg0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			line0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("line");
			line1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("line");
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			svg1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			h1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("h1");
			t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t2_value);
			t3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			p = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("p");
			t4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t4_value);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "stroke", "none");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "d", "M0 0h24v24H0z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path0, file, 36, 8, 1241);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(line0, "x1", "18");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(line0, "y1", "6");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(line0, "x2", "6");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(line0, "y2", "18");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(line0, file, 37, 8, 1291);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(line1, "x1", "6");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(line1, "y1", "6");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(line1, "x2", "18");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(line1, "y2", "18");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(line1, file, 38, 8, 1339);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "class", "icon icon-tabler icon-tabler-x");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "width", "20");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "height", "20");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "viewBox", "0 0 24 24");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "stroke-width", "2.5");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "stroke", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "fill", "none");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "stroke-linecap", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "stroke-linejoin", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg0, file, 24, 6, 911);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button, "class", "absolute top-1 right-1 border-0 text-gray-500 dark:text-gray-100 dark:hover:text-gray-400 hover:text-gray-600 transition duration-150 ease-in-out cursor-pointer focus:ring-2 focus:outline-none focus:ring-gray-500 rounded");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button, file, 20, 4, 610);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "fill-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "d", "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "clip-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path1, file, 50, 8, 1691);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "class", "h-6 w-6");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "viewBox", "0 0 20 20");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "fill", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg1, file, 44, 6, 1541);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div0, "class", "p-2 flex items-center justify-center bg-red-600 rounded-tl rounded-bl h-auto w-auto text-white");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div0, file, 41, 4, 1412);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(h1, "class", "text-lg text-gray-800 dark:text-gray-100 font-semibold pb-1");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(h1, file, 58, 6, 1985);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(p, "class", "text-sm text-gray-600 dark:text-gray-400 font-normal");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(p, file, 61, 6, 2114);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div1, "class", "flex-col justify-center p-2 mr-6");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div1, file, 57, 4, 1931);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div2, "class", "absolute flex z-40 max-w-md top-1/3 left-auto right-0 mr-4 justify-between bg-white dark:bg-gray-800 shadow-lg rounded");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div2, file, 16, 2, 442);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div2, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, button);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button, svg0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg0, path0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg0, line0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg0, line1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, t0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, div0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div0, svg1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg1, path1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, t1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, div1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, h1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(h1, t2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, t3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, p);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(p, t4);
			current = true;

			if (!mounted) {
				dispose = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button, "click", /*click_handler*/ ctx[1], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*$stateStore*/ 1) && t2_value !== (t2_value = /*$stateStore*/ ctx[0].notify.title + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t2, t2_value);
			if ((!current || dirty & /*$stateStore*/ 1) && t4_value !== (t4_value = /*$stateStore*/ ctx[0].notify.details + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t4, t4_value);
		},
		i: function intro(local) {
			if (current) return;

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_render_callback)(() => {
				if (!current) return;
				if (!div2_transition) div2_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(div2, svelte_transition__WEBPACK_IMPORTED_MODULE_2__.fade, {}, true);
				div2_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			if (!div2_transition) div2_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(div2, svelte_transition__WEBPACK_IMPORTED_MODULE_2__.fade, {}, false);
			div2_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div2);
			if (detaching && div2_transition) div2_transition.end();
			mounted = false;
			dispose();
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(16:0) {#if $stateStore.notify}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*$stateStore*/ ctx[0].notify && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*$stateStore*/ ctx[0].notify) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*$stateStore*/ 1) {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block, 1, 1, () => {
					if_block = null;
				});

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(if_block_anchor);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $stateStore;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_store)(_stores__WEBPACK_IMPORTED_MODULE_3__.stateStore, 'stateStore');
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, _stores__WEBPACK_IMPORTED_MODULE_3__.stateStore, $$value => $$invalidate(0, $stateStore = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)('Notification', slots, []);
	let timeout;

	const unsubscribe = _stores__WEBPACK_IMPORTED_MODULE_3__.stateStore.subscribe(state => {
		clearTimeout(timeout);

		if (state.notify) {
			timeout = setTimeout(
				() => {
					_stores__WEBPACK_IMPORTED_MODULE_3__.stateStore.clear();
				},
				state.timeout ?? 10000
			);
		}
	});

	(0,svelte__WEBPACK_IMPORTED_MODULE_1__.onDestroy)(() => unsubscribe());
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Notification> was created with unknown prop '${key}'`);
	});

	const click_handler = () => _stores__WEBPACK_IMPORTED_MODULE_3__.stateStore.clear();

	$$self.$capture_state = () => ({
		onDestroy: svelte__WEBPACK_IMPORTED_MODULE_1__.onDestroy,
		fade: svelte_transition__WEBPACK_IMPORTED_MODULE_2__.fade,
		stateStore: _stores__WEBPACK_IMPORTED_MODULE_3__.stateStore,
		timeout,
		unsubscribe,
		$stateStore
	});

	$$self.$inject_state = $$props => {
		if ('timeout' in $$props) timeout = $$props.timeout;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [$stateStore, click_handler];
}

class Notification extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {
	constructor(options) {
		super(options);
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {});

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "Notification",
			options,
			id: create_fragment.name
		});
	}
}

if (module && module.hot) {}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Notification);



/***/ }),

/***/ "./JS/Components/Server.svelte":
/*!*************************************!*\
  !*** ./JS/Components/Server.svelte ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../stores */ "./JS/stores.ts");
/* harmony import */ var svelte_transition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! svelte/transition */ "./node_modules/svelte/transition/index.mjs");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_loader_lib_hot_api_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/svelte-loader/lib/hot-api.js */ "./node_modules/svelte-loader/lib/hot-api.js");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_hmr_runtime_proxy_adapter_dom_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js */ "./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/* JS\Components\Server.svelte generated by Svelte v3.59.2 */




const file = "JS\\Components\\Server.svelte";

// (27:0) {#if $stateStore.server}
function create_if_block(ctx) {
	let div2;
	let form;
	let div1;
	let p0;
	let t1;
	let p1;
	let t3;
	let p2;
	let t5;
	let input;
	let input_disabled_value;
	let t6;
	let p3;
	let t8;
	let div0;
	let button;
	let svg;
	let path;
	let button_disabled_value;
	let div2_transition;
	let current;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			form = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("form");
			div1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			p0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("p");
			p0.textContent = "Welcome to CelinXL Add-Ins";
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			p1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("p");
			p1.textContent = "To start using the Add-Ins, enter your AIS Server Url.";
			t3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			p2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("p");
			p2.textContent = "AIS Server:";
			t5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			input = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("input");
			t6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			p3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("p");
			p3.textContent = "Try demo.steltix.com for testing";
			t8 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			button = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(p0, "class", "text-lg text-center font-semibold py-2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(p0, file, 36, 8, 1032);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(p1, "class", "py-2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(p1, file, 37, 8, 1122);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(p2, "class", "font-thin");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(p2, file, 40, 8, 1228);
			input.required = true;
			input.disabled = input_disabled_value = /*$stateStore*/ ctx[1].busy;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(input, "class", "border rounded w-full py-2 px-3 text-slate-700");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(input, "type", "text");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(input, "placeholder", "<host><optional :port>");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(input, file, 43, 8, 1296);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(p3, "class", "text-sm");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(p3, file, 51, 8, 1551);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "stroke-linecap", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "stroke-linejoin", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "stroke-width", "2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "d", "M5 12h14M5 12a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v4a2 2 0 01-2 2M5 12a2 2 0 00-2 2v4a2 2 0 002 2h14a2 2 0 002-2v-4a2 2 0 00-2-2m-2-4h.01M17 16h.01");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path, file, 65, 14, 2079);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "class", "h-6 w-6");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "fill", "none");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "viewBox", "0 0 24 24");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "stroke", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg, file, 58, 12, 1864);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button, "class", "transform active:scale-95 hover:ring py-2 px-4 bg-green-100");
			button.disabled = button_disabled_value = /*$stateStore*/ ctx[1].busy;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button, "type", "submit");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button, file, 53, 10, 1681);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div0, "class", "flex flex-row place-content-center py-6");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div0, file, 52, 8, 1616);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div1, "class", "flex flex-col px-8 text-slate-300");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div1, file, 35, 6, 975);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(form, "class", "relative top-1/4 mx-auto max-w-md border-4 border-l-slate-600 border-t-slate-600 border-r-slate-400 border-b-slate-400");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(form, file, 31, 4, 771);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div2, "class", "bg-opacity-70 bg-slate-900 z-30 fixed top-0 h-full w-full");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div2, file, 27, 2, 664);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div2, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, form);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(form, div1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, p0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, t1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, p1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, t3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, p2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, t5);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, input);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_input_value)(input, /*server*/ ctx[0]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, t6);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, p3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, t8);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, div0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div0, button);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button, svg);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path);
			current = true;

			if (!mounted) {
				dispose = [
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(input, "input", /*input_input_handler*/ ctx[3]),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(form, "submit", (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.prevent_default)(/*submit_handler*/ ctx[4]), false, true, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (!current || dirty & /*$stateStore*/ 2 && input_disabled_value !== (input_disabled_value = /*$stateStore*/ ctx[1].busy)) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.prop_dev)(input, "disabled", input_disabled_value);
			}

			if (dirty & /*server*/ 1 && input.value !== /*server*/ ctx[0]) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_input_value)(input, /*server*/ ctx[0]);
			}

			if (!current || dirty & /*$stateStore*/ 2 && button_disabled_value !== (button_disabled_value = /*$stateStore*/ ctx[1].busy)) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.prop_dev)(button, "disabled", button_disabled_value);
			}
		},
		i: function intro(local) {
			if (current) return;

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_render_callback)(() => {
				if (!current) return;
				if (!div2_transition) div2_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(div2, svelte_transition__WEBPACK_IMPORTED_MODULE_2__.fade, {}, true);
				div2_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			if (!div2_transition) div2_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(div2, svelte_transition__WEBPACK_IMPORTED_MODULE_2__.fade, {}, false);
			div2_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div2);
			if (detaching && div2_transition) div2_transition.end();
			mounted = false;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.run_all)(dispose);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(27:0) {#if $stateStore.server}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*$stateStore*/ ctx[1].server && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*$stateStore*/ ctx[1].server) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*$stateStore*/ 2) {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block, 1, 1, () => {
					if_block = null;
				});

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(if_block_anchor);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $stateStore;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_store)(_stores__WEBPACK_IMPORTED_MODULE_1__.stateStore, 'stateStore');
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, _stores__WEBPACK_IMPORTED_MODULE_1__.stateStore, $$value => $$invalidate(1, $stateStore = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)('Server', slots, []);
	let server;

	const connect = async () => {
		_stores__WEBPACK_IMPORTED_MODULE_1__.stateStore.busy(true);
		_stores__WEBPACK_IMPORTED_MODULE_1__.stateStore.clear();
		const baseUrl = `${location.protocol}//${server}/jderest/v2/`;

		try {
			const rs = await fetch(`${baseUrl}defaultconfig`);
			const json = await rs.json();

			_stores__WEBPACK_IMPORTED_MODULE_1__.serversStore.set([
				{
					id: 0,
					name: json.defaultEnvironment,
					baseUrl
				}
			]);
		} catch(ex) {
			_stores__WEBPACK_IMPORTED_MODULE_1__.stateStore.error("Connection failed!", ex.message);
		}
	};

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Server> was created with unknown prop '${key}'`);
	});

	function input_input_handler() {
		server = this.value;
		$$invalidate(0, server);
	}

	const submit_handler = () => connect();

	$$self.$capture_state = () => ({
		stateStore: _stores__WEBPACK_IMPORTED_MODULE_1__.stateStore,
		serversStore: _stores__WEBPACK_IMPORTED_MODULE_1__.serversStore,
		fade: svelte_transition__WEBPACK_IMPORTED_MODULE_2__.fade,
		server,
		connect,
		$stateStore
	});

	$$self.$inject_state = $$props => {
		if ('server' in $$props) $$invalidate(0, server = $$props.server);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [server, $stateStore, connect, input_input_handler, submit_handler];
}

class Server extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {
	constructor(options) {
		super(options);
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {});

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "Server",
			options,
			id: create_fragment.name
		});
	}
}

if (module && module.hot) {}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Server);



/***/ }),

/***/ "./JS/Components/Slider.svelte":
/*!*************************************!*\
  !*** ./JS/Components/Slider.svelte ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_loader_lib_hot_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/svelte-loader/lib/hot-api.js */ "./node_modules/svelte-loader/lib/hot-api.js");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_hmr_runtime_proxy_adapter_dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js */ "./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/* JS\Components\Slider.svelte generated by Svelte v3.59.2 */


const { window: window_1 } = svelte_internal__WEBPACK_IMPORTED_MODULE_0__.globals;
const file = "JS\\Components\\Slider.svelte";

function create_fragment(ctx) {
	let div;
	let button;
	let svg;
	let path;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			button = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "stroke-linecap", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "stroke-linejoin", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "stroke-width", "2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "d", "M8 9l4-4 4 4m0 6l-4 4-4-4");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path, file, 26, 6, 768);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "class", "absolute h-5 w-5 bg-slate-400 rounded-md hover:bg-gray-200 -top-2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "fill", "none");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "viewBox", "0 0 24 24");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "stroke", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg, file, 19, 5, 551);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(button, "cursor-ns-resize", /*dragging*/ ctx[1]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button, file, 17, 2, 459);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div, "class", "absolute flex flex-row justify-center border-b border-b-slate-400");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(div, "top", "calc(" + /*ratio*/ ctx[0] + "vh - 10px)");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(div, "width", "94vw");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(div, "margin-left", "3vw");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div, file, 13, 0, 298);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div, button);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button, svg);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path);

			if (!mounted) {
				dispose = [
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(window_1, "mouseup", /*mouseup_handler*/ ctx[3], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(window_1, "mousemove", /*drag*/ ctx[2], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button, "mousedown", /*mousedown_handler*/ ctx[4], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*dragging*/ 2) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(button, "cursor-ns-resize", /*dragging*/ ctx[1]);
			}

			if (dirty & /*ratio*/ 1) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(div, "top", "calc(" + /*ratio*/ ctx[0] + "vh - 10px)");
			}
		},
		i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div);
			mounted = false;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.run_all)(dispose);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)('Slider', slots, []);
	let { ratio } = $$props;
	let dragging = false;

	const drag = ev => {
		if (dragging) {
			$$invalidate(0, ratio = Math.min(Math.max((ev.clientY - 40) / window.innerHeight * 100, 2), 95));
		}
	};

	$$self.$$.on_mount.push(function () {
		if (ratio === undefined && !('ratio' in $$props || $$self.$$.bound[$$self.$$.props['ratio']])) {
			console.warn("<Slider> was created without expected prop 'ratio'");
		}
	});

	const writable_props = ['ratio'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Slider> was created with unknown prop '${key}'`);
	});

	const mouseup_handler = () => $$invalidate(1, dragging = false);
	const mousedown_handler = () => $$invalidate(1, dragging = true);

	$$self.$$set = $$props => {
		if ('ratio' in $$props) $$invalidate(0, ratio = $$props.ratio);
	};

	$$self.$capture_state = () => ({ ratio, dragging, drag });

	$$self.$inject_state = $$props => {
		if ('ratio' in $$props) $$invalidate(0, ratio = $$props.ratio);
		if ('dragging' in $$props) $$invalidate(1, dragging = $$props.dragging);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [ratio, dragging, drag, mouseup_handler, mousedown_handler];
}

class Slider extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {
	constructor(options) {
		super(options);
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, { ratio: 0 });

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "Slider",
			options,
			id: create_fragment.name
		});
	}

	get ratio() {
		throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ratio(value) {
		throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

if (module && module.hot) {}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Slider);



/***/ }),

/***/ "./JS/Components/SubjectLookup.svelte":
/*!********************************************!*\
  !*** ./JS/Components/SubjectLookup.svelte ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var svelte_select__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte-select */ "./node_modules/svelte-select/index.js");
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../stores */ "./JS/stores.ts");
/* harmony import */ var _loadSubjects__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../loadSubjects */ "./JS/loadSubjects.ts");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_loader_lib_hot_api_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node_modules/svelte-loader/lib/hot-api.js */ "./node_modules/svelte-loader/lib/hot-api.js");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_hmr_runtime_proxy_adapter_dom_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js */ "./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/* JS\Components\SubjectLookup.svelte generated by Svelte v3.59.2 */





const file = "JS\\Components\\SubjectLookup.svelte";

function add_css(target) {
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_styles)(target, "svelte-z0j8es", ".style.svelte-z0j8es{--listMaxHeight:320px;--background:rgb(226 232 240);--listBackground:rgb(226 232 240);--border:0px;--margin:2px;--height:34px;--clearSelectBottom:6px;--clearSelectTop:6px;--spinnerLeft:4px;color:rgb(15 23 42);font-family:monospace}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3ViamVjdExvb2t1cC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBa0JFLG9CQUFPLENBQ0wsZUFBZSxDQUFFLEtBQUssQ0FDdEIsWUFBWSxDQUFFLGdCQUFnQixDQUM5QixnQkFBZ0IsQ0FBRSxnQkFBZ0IsQ0FDbEMsUUFBUSxDQUFFLEdBQUcsQ0FDYixRQUFRLENBQUUsR0FBRyxDQUNiLFFBQVEsQ0FBRSxJQUFJLENBQ2QsbUJBQW1CLENBQUUsR0FBRyxDQUN4QixnQkFBZ0IsQ0FBRSxHQUFHLENBQ3JCLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLEtBQUssQ0FBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQ3BCLFdBQVcsQ0FBRSxTQUNmIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlN1YmplY3RMb29rdXAuc3ZlbHRlIl19 */");
}

function create_fragment(ctx) {
	let div;
	let select;
	let current;

	select = new svelte_select__WEBPACK_IMPORTED_MODULE_1__["default"]({
			props: {
				loadOptions: _loadSubjects__WEBPACK_IMPORTED_MODULE_3__["default"],
				placeholder: "Search by Table or View and then Description..."
			},
			$$inline: true
		});

	select.$on("select", /*select_handler*/ ctx[0]);

	const block = {
		c: function create() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(select.$$.fragment);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div, "class", "style pl-2 w-3/5 svelte-z0j8es");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div, file, 6, 0, 157);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(select, div, null);
			current = true;
		},
		p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(select.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(select.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(select);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)('SubjectLookup', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SubjectLookup> was created with unknown prop '${key}'`);
	});

	const select_handler = ev => {
		_stores__WEBPACK_IMPORTED_MODULE_2__.subjectDemoStore.subject(ev.detail);
		__webpack_require__.g.blazorLib.invokeMethodAsync('SubjectDemoLookupRequest', ev.detail.value);
	};

	$$self.$capture_state = () => ({ Select: svelte_select__WEBPACK_IMPORTED_MODULE_1__["default"], subjectDemoStore: _stores__WEBPACK_IMPORTED_MODULE_2__.subjectDemoStore, loadOptions: _loadSubjects__WEBPACK_IMPORTED_MODULE_3__["default"] });
	return [select_handler];
}

class SubjectLookup extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {
	constructor(options) {
		super(options);
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {}, add_css);

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "SubjectLookup",
			options,
			id: create_fragment.name
		});
	}
}

if (module && module.hot) {}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SubjectLookup);



/***/ }),

/***/ "./JS/Components/WebLogin.svelte":
/*!***************************************!*\
  !*** ./JS/Components/WebLogin.svelte ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var svelte__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte */ "./node_modules/svelte/index.mjs");
/* harmony import */ var svelte_transition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! svelte/transition */ "./node_modules/svelte/transition/index.mjs");
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../stores */ "./JS/stores.ts");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_loader_lib_hot_api_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node_modules/svelte-loader/lib/hot-api.js */ "./node_modules/svelte-loader/lib/hot-api.js");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_hmr_runtime_proxy_adapter_dom_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js */ "./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/* JS\Components\WebLogin.svelte generated by Svelte v3.59.2 */





const file = "JS\\Components\\WebLogin.svelte";

// (28:0) {#if $stateStore.login}
function create_if_block(ctx) {
	let div6;
	let form;
	let div3;
	let div0;
	let p;
	let t0_value = /*$serversStore*/ ctx[3][/*$stateStore*/ ctx[2].contextId]?.name + "";
	let t0;
	let t1;
	let div1;
	let input0;
	let input0_disabled_value;
	let t2;
	let div2;
	let input1;
	let input1_disabled_value;
	let t3;
	let div5;
	let div4;
	let button0;
	let svg0;
	let path0;
	let button0_disabled_value;
	let t4;
	let button1;
	let svg1;
	let path1;
	let button1_disable_value;
	let div6_transition;
	let current;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			form = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("form");
			div3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			p = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("p");
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t0_value);
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			input0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("input");
			t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			input1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("input");
			t3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			button0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			svg0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			t4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			button1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			svg1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(p, "class", "text-xl font-semibold");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(p, file, 38, 10, 1085);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div0, "class", "flex place-content-center py-4 text-slate-300");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div0, file, 37, 8, 1014);
			input0.autofocus = true;
			input0.required = true;
			input0.disabled = input0_disabled_value = /*$stateStore*/ ctx[2].busy;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(input0, "class", "border rounded w-full py-2 px-3");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(input0, "type", "text");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(input0, "placeholder", "User Name");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(input0, file, 44, 10, 1297);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div1, "class", "pb-4");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div1, file, 42, 8, 1218);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(input1, "class", "border border-red rounded w-full py-2 px-3");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(input1, "type", "password");
			input1.required = true;
			input1.disabled = input1_disabled_value = /*$stateStore*/ ctx[2].busy;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(input1, "placeholder", "Password");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(input1, file, 55, 10, 1609);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div2, "class", "mb-2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div2, file, 54, 8, 1579);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div3, "class", "px-8");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div3, file, 36, 6, 986);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "fill-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "d", "M3 3a1 1 0 011 1v12a1 1 0 11-2 0V4a1 1 0 011-1zm7.707 3.293a1 1 0 010 1.414L9.414 9H17a1 1 0 110 2H9.414l1.293 1.293a1 1 0 01-1.414 1.414l-3-3a1 1 0 010-1.414l3-3a1 1 0 011.414 0z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "clip-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path0, file, 78, 14, 2361);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "class", "h-5 w-5");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "viewBox", "0 0 20 20");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "fill", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg0, file, 72, 12, 2175);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button0, "class", "transform active:scale-95 hover:ring py-2 px-4 bg-green-100");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button0, "type", "submit");
			button0.disabled = button0_disabled_value = /*$stateStore*/ ctx[2].busy;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button0, file, 67, 10, 1992);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "fill-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "d", "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "clip-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path1, file, 97, 14, 3117);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "class", "h-5 w-5");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "viewBox", "0 0 20 20");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "fill", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg1, file, 91, 12, 2931);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button1, "class", "transform active:scale-95 hover:ring py-2 px-4 bg-red-100");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button1, "type", "button");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button1, "disable", button1_disable_value = /*$stateStore*/ ctx[2].busy);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button1, file, 85, 10, 2712);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div4, "class", "flex items-center place-content-between");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div4, file, 66, 8, 1927);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div5, "class", "px-8 py-5");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div5, file, 65, 6, 1894);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(form, "class", "relative top-1/4 mx-auto max-w-xs border-4 border-l-slate-600 border-t-slate-600 border-r-slate-400 border-b-slate-400");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(form, file, 32, 4, 787);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div6, "class", "bg-opacity-70 bg-slate-900 z-40 fixed top-0 h-full w-full");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div6, file, 28, 2, 680);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div6, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, form);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(form, div3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, div0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div0, p);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(p, t0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, t1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, div1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, input0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_input_value)(input0, /*username*/ ctx[0]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, t2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, div2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, input1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_input_value)(input1, /*password*/ ctx[1]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(form, t3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(form, div5);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, div4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, button0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button0, svg0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg0, path0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, t4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, button1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button1, svg1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg1, path1);
			current = true;
			input0.focus();

			if (!mounted) {
				dispose = [
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(input0, "input", /*input0_input_handler*/ ctx[6]),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(input1, "input", /*input1_input_handler*/ ctx[7]),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button1, "click", /*click_handler*/ ctx[8], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(form, "submit", (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.prevent_default)(/*submit_handler*/ ctx[9]), false, true, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*$serversStore, $stateStore*/ 12) && t0_value !== (t0_value = /*$serversStore*/ ctx[3][/*$stateStore*/ ctx[2].contextId]?.name + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t0, t0_value);

			if (!current || dirty & /*$stateStore*/ 4 && input0_disabled_value !== (input0_disabled_value = /*$stateStore*/ ctx[2].busy)) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.prop_dev)(input0, "disabled", input0_disabled_value);
			}

			if (dirty & /*username*/ 1 && input0.value !== /*username*/ ctx[0]) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_input_value)(input0, /*username*/ ctx[0]);
			}

			if (!current || dirty & /*$stateStore*/ 4 && input1_disabled_value !== (input1_disabled_value = /*$stateStore*/ ctx[2].busy)) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.prop_dev)(input1, "disabled", input1_disabled_value);
			}

			if (dirty & /*password*/ 2 && input1.value !== /*password*/ ctx[1]) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_input_value)(input1, /*password*/ ctx[1]);
			}

			if (!current || dirty & /*$stateStore*/ 4 && button0_disabled_value !== (button0_disabled_value = /*$stateStore*/ ctx[2].busy)) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.prop_dev)(button0, "disabled", button0_disabled_value);
			}

			if (!current || dirty & /*$stateStore*/ 4 && button1_disable_value !== (button1_disable_value = /*$stateStore*/ ctx[2].busy)) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button1, "disable", button1_disable_value);
			}
		},
		i: function intro(local) {
			if (current) return;

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_render_callback)(() => {
				if (!current) return;
				if (!div6_transition) div6_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(div6, svelte_transition__WEBPACK_IMPORTED_MODULE_2__.fade, {}, true);
				div6_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			if (!div6_transition) div6_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(div6, svelte_transition__WEBPACK_IMPORTED_MODULE_2__.fade, {}, false);
			div6_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div6);
			if (detaching && div6_transition) div6_transition.end();
			mounted = false;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.run_all)(dispose);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(28:0) {#if $stateStore.login}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*$stateStore*/ ctx[2].login && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*$stateStore*/ ctx[2].login) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*$stateStore*/ 4) {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block, 1, 1, () => {
					if_block = null;
				});

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(if_block_anchor);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $stateStore;
	let $serversStore;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_store)(_stores__WEBPACK_IMPORTED_MODULE_3__.stateStore, 'stateStore');
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, _stores__WEBPACK_IMPORTED_MODULE_3__.stateStore, $$value => $$invalidate(2, $stateStore = $$value));
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_store)(_stores__WEBPACK_IMPORTED_MODULE_3__.serversStore, 'serversStore');
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, _stores__WEBPACK_IMPORTED_MODULE_3__.serversStore, $$value => $$invalidate(3, $serversStore = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)('WebLogin', slots, []);
	let username = "";
	let password = "";

	const unsubscibe = _stores__WEBPACK_IMPORTED_MODULE_3__.serversStore.subscribe(servers => $$invalidate(0, username = servers?.length > 0
	? servers[_stores__WEBPACK_IMPORTED_MODULE_3__.serversStore.server]?.authResponse?.username
	: username));

	const ok = () => {
		_stores__WEBPACK_IMPORTED_MODULE_3__.stateStore.busy(true);
		__webpack_require__.g.blazorLib.invokeMethodAsync("Authenticate", username, password);
	};

	const cancel = () => _stores__WEBPACK_IMPORTED_MODULE_3__.stateStore.login(false);

	(0,svelte__WEBPACK_IMPORTED_MODULE_1__.onDestroy)(() => {
		unsubscibe();
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<WebLogin> was created with unknown prop '${key}'`);
	});

	function input0_input_handler() {
		username = this.value;
		$$invalidate(0, username);
	}

	function input1_input_handler() {
		password = this.value;
		$$invalidate(1, password);
	}

	const click_handler = () => cancel();
	const submit_handler = () => ok();

	$$self.$capture_state = () => ({
		onDestroy: svelte__WEBPACK_IMPORTED_MODULE_1__.onDestroy,
		fade: svelte_transition__WEBPACK_IMPORTED_MODULE_2__.fade,
		stateStore: _stores__WEBPACK_IMPORTED_MODULE_3__.stateStore,
		serversStore: _stores__WEBPACK_IMPORTED_MODULE_3__.serversStore,
		username,
		password,
		unsubscibe,
		ok,
		cancel,
		$stateStore,
		$serversStore
	});

	$$self.$inject_state = $$props => {
		if ('username' in $$props) $$invalidate(0, username = $$props.username);
		if ('password' in $$props) $$invalidate(1, password = $$props.password);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		username,
		password,
		$stateStore,
		$serversStore,
		ok,
		cancel,
		input0_input_handler,
		input1_input_handler,
		click_handler,
		submit_handler
	];
}

class WebLogin extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {
	constructor(options) {
		super(options);
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {});

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "WebLogin",
			options,
			id: create_fragment.name
		});
	}
}

if (module && module.hot) {}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WebLogin);



/***/ }),

/***/ "./JS/Components/v2/CmdDetail.svelte":
/*!*******************************************!*\
  !*** ./JS/Components/v2/CmdDetail.svelte ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var prismjs_prism__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prismjs/prism */ "./node_modules/prismjs/prism.js");
/* harmony import */ var prismjs_prism__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prismjs_prism__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _prism_celincm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../prism-celincm */ "./JS/prism-celincm.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../types */ "./JS/types.ts");
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../stores */ "./JS/stores.ts");
/* harmony import */ var _submit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../submit */ "./JS/submit.ts");
/* harmony import */ var svelte__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! svelte */ "./node_modules/svelte/index.mjs");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_loader_lib_hot_api_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./node_modules/svelte-loader/lib/hot-api.js */ "./node_modules/svelte-loader/lib/hot-api.js");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_hmr_runtime_proxy_adapter_dom_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js */ "./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/* JS\Components\v2\CmdDetail.svelte generated by Svelte v3.59.2 */








const file = "JS\\Components\\v2\\CmdDetail.svelte";

// (21:0) {#if detail}
function create_if_block(ctx) {
	let div7;
	let div3;
	let div0;
	let button0;
	let svg0;
	let path0;
	let t0;
	let button1;
	let t1;
	let div1;
	let t2_value = /*detail*/ ctx[0].id + "";
	let t2;
	let t3;
	let div2;
	let button2;
	let svg1;
	let path1;
	let t4;
	let div5;
	let div4;
	let t5_value = (/*detail*/ ctx[0].error ?? "") + "";
	let t5;
	let t6;
	let div6;
	let pre;
	let code;
	let raw_value = prismjs_prism__WEBPACK_IMPORTED_MODULE_1___default().highlight(/*detail*/ ctx[0].source, _prism_celincm__WEBPACK_IMPORTED_MODULE_2__.celincm, "CelinSL") + "";
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*detail*/ ctx[0].unsub) return create_if_block_1;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			div7 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			button0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			svg0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			button1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			if_block.c();
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t2_value);
			t3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			button2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			svg1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			t4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			t5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t5_value);
			t6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			pre = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("pre");
			code = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("code");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "fill-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "d", "M7.793 2.232a.75.75 0 01-.025 1.06L3.622 7.25h10.003a5.375 5.375 0 010 10.75H10.75a.75.75 0 010-1.5h2.875a3.875 3.875 0 000-7.75H3.622l4.146 3.957a.75.75 0 01-1.036 1.085l-5.5-5.25a.75.75 0 010-1.085l5.5-5.25a.75.75 0 011.06.025z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "clip-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path0, file, 40, 12, 1206);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "viewBox", "0 0 20 20");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "fill", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "class", "w-5 h-5 text-slate-200");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg0, file, 34, 10, 1017);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button0, "class", "p-1.5 rounded-tl-md bg-amber-700 hover:bg-amber-600 active:scale-90");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button0, "data-bs-target", "tooltip");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button0, "title", "Back");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button0, file, 26, 8, 776);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button1, "class", "p-1.5 hover:bg-slate-100 active:scale-90");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button1, "data-bs-target", "tooltip");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button1, "title", "Run");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button1, file, 47, 8, 1593);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div0, "class", "flex");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div0, file, 25, 6, 748);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div1, "class", "text-center font-semibold");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div1, file, 99, 6, 3424);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "fill-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "d", "M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "clip-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path1, file, 116, 12, 3989);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "class", "h-5 w-5 text-red-800");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "viewBox", "0 0 20 20");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "fill", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg1, file, 110, 10, 3802);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button2, "class", "rounded-tr-md p-1.5 hover:bg-slate-100 active:scale-90");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button2, "data-bs-target", "tooltip");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button2, "title", "Delete");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button2, file, 101, 8, 3531);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div2, "class", "has-tooltip ml-auto");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div2, file, 100, 6, 3488);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div3, "class", "grid grid-cols-3 items-center border-b border-solid border-amber-900");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div3, file, 22, 4, 645);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div4, "class", "bg-red-500 text-slate-200");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div4, file, 126, 6, 4416);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div5, "class", "flex flex-col mx-6 p-2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div5, file, 125, 4, 4372);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(code, "class", "whitespace-pre-wrap");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(code, file, 129, 42, 4612);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(pre, "class", "max-h-36 overflow-auto");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(pre, file, 129, 6, 4576);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div6, "class", "flex flex-col mx-6 my-2 p-2 bg-slate-900 text-green-400");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div6, file, 128, 4, 4499);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div7, "class", "rounded-md bg-slate-200 text-slate-900 shadow-lg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div7, file, 21, 2, 577);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div7, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div7, div3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, div0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div0, button0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button0, svg0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg0, path0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div0, t0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div0, button1);
			if_block.m(button1, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, t1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, div1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, t2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, t3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, div2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, button2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button2, svg1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg1, path1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div7, t4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div7, div5);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, div4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, t5);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div7, t6);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div7, div6);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, pre);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(pre, code);
			code.innerHTML = raw_value;

			if (!mounted) {
				dispose = [
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button0, "click", /*click_handler*/ ctx[2], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button1, "click", /*click_handler_1*/ ctx[3], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button2, "click", /*click_handler_2*/ ctx[4], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (current_block_type !== (current_block_type = select_block_type(ctx, dirty))) {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(button1, null);
				}
			}

			if (dirty & /*detail*/ 1 && t2_value !== (t2_value = /*detail*/ ctx[0].id + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t2, t2_value);
			if (dirty & /*detail*/ 1 && t5_value !== (t5_value = (/*detail*/ ctx[0].error ?? "") + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t5, t5_value);
			if (dirty & /*detail*/ 1 && raw_value !== (raw_value = prismjs_prism__WEBPACK_IMPORTED_MODULE_1___default().highlight(/*detail*/ ctx[0].source, _prism_celincm__WEBPACK_IMPORTED_MODULE_2__.celincm, "CelinSL") + "")) code.innerHTML = raw_value;;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div7);
			if_block.d();
			mounted = false;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.run_all)(dispose);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(21:0) {#if detail}",
		ctx
	});

	return block;
}

// (77:10) {:else}
function create_else_block(ctx) {
	let svg;
	let path0;
	let path1;

	const block = {
		c: function create() {
			svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			path1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "stroke-linecap", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "stroke-linejoin", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "d", "M21 12a9 9 0 11-18 0 9 9 0 0118 0z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path0, file, 85, 14, 2930);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "stroke-linecap", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "stroke-linejoin", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "d", "M15.91 11.672a.375.375 0 010 .656l-5.603 3.113a.375.375 0 01-.557-.328V8.887c0-.286.307-.466.557-.327l5.603 3.112z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path1, file, 90, 14, 3106);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "fill", "none");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "viewBox", "0 0 24 24");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "stroke-width", "1.5");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "stroke", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "class", "w-6 h-6 text-green-600");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg, file, 77, 12, 2666);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, svg, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path1);
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(svg);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(77:10) {:else}",
		ctx
	});

	return block;
}

// (57:10) {#if detail.unsub}
function create_if_block_1(ctx) {
	let svg;
	let path0;
	let path1;

	const block = {
		c: function create() {
			svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			path1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "stroke-linecap", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "stroke-linejoin", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "d", "M21 12a9 9 0 11-18 0 9 9 0 0118 0z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path0, file, 65, 14, 2183);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "stroke-linecap", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "stroke-linejoin", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "d", "M9 9.563C9 9.252 9.252 9 9.563 9h4.874c.311 0 .563.252.563.563v4.874c0 .311-.252.563-.563.563H9.564A.562.562 0 019 14.437V9.564z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path1, file, 70, 14, 2359);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "fill", "none");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "viewBox", "0 0 24 24");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "stroke-width", "1.5");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "stroke", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "class", "w-6 h-6 text-red-600");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg, file, 57, 12, 1921);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, svg, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path1);
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(svg);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(57:10) {#if detail.unsub}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let if_block_anchor;
	let if_block = /*detail*/ ctx[0] && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, if_block_anchor, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (/*detail*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(if_block_anchor);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)('CmdDetail', slots, []);
	let { detail = null } = $$props;
	let { back } = $$props;

	const unsubscribe = _stores__WEBPACK_IMPORTED_MODULE_4__.cmdStateStore.subscribe(data => {
		if (data && detail && data.id === detail.id) {
			$$invalidate(0, detail = { ...detail, ...data });
		}
	});

	(0,svelte__WEBPACK_IMPORTED_MODULE_6__.onDestroy)(() => unsubscribe);

	$$self.$$.on_mount.push(function () {
		if (back === undefined && !('back' in $$props || $$self.$$.bound[$$self.$$.props['back']])) {
			console.warn("<CmdDetail> was created without expected prop 'back'");
		}
	});

	const writable_props = ['detail', 'back'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CmdDetail> was created with unknown prop '${key}'`);
	});

	const click_handler = () => {
		back();
	};

	const click_handler_1 = () => detail.type === _types__WEBPACK_IMPORTED_MODULE_3__.CommandType.func
	? (0,_submit__WEBPACK_IMPORTED_MODULE_5__.runCmd)(detail, null)
	: (0,_submit__WEBPACK_IMPORTED_MODULE_5__.toggleCmd)(detail);

	const click_handler_2 = () => {
		_stores__WEBPACK_IMPORTED_MODULE_4__.cmdStore.delete(detail.id);
		back();
	};

	$$self.$$set = $$props => {
		if ('detail' in $$props) $$invalidate(0, detail = $$props.detail);
		if ('back' in $$props) $$invalidate(1, back = $$props.back);
	};

	$$self.$capture_state = () => ({
		Prism: (prismjs_prism__WEBPACK_IMPORTED_MODULE_1___default()),
		celincm: _prism_celincm__WEBPACK_IMPORTED_MODULE_2__.celincm,
		CommandType: _types__WEBPACK_IMPORTED_MODULE_3__.CommandType,
		cmdStore: _stores__WEBPACK_IMPORTED_MODULE_4__.cmdStore,
		cmdStateStore: _stores__WEBPACK_IMPORTED_MODULE_4__.cmdStateStore,
		runCmd: _submit__WEBPACK_IMPORTED_MODULE_5__.runCmd,
		toggleCmd: _submit__WEBPACK_IMPORTED_MODULE_5__.toggleCmd,
		onDestroy: svelte__WEBPACK_IMPORTED_MODULE_6__.onDestroy,
		detail,
		back,
		unsubscribe
	});

	$$self.$inject_state = $$props => {
		if ('detail' in $$props) $$invalidate(0, detail = $$props.detail);
		if ('back' in $$props) $$invalidate(1, back = $$props.back);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [detail, back, click_handler, click_handler_1, click_handler_2];
}

class CmdDetail extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {
	constructor(options) {
		super(options);
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, { detail: 0, back: 1 });

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "CmdDetail",
			options,
			id: create_fragment.name
		});
	}

	get detail() {
		throw new Error("<CmdDetail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set detail(value) {
		throw new Error("<CmdDetail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get back() {
		throw new Error("<CmdDetail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set back(value) {
		throw new Error("<CmdDetail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

if (module && module.hot) {}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CmdDetail);



/***/ }),

/***/ "./JS/Components/v2/CmdList.svelte":
/*!*****************************************!*\
  !*** ./JS/Components/v2/CmdList.svelte ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var svelte_transition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte/transition */ "./node_modules/svelte/transition/index.mjs");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../types */ "./JS/types.ts");
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../stores */ "./JS/stores.ts");
/* harmony import */ var _submit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../submit */ "./JS/submit.ts");
/* harmony import */ var _CmdDetail_svelte__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CmdDetail.svelte */ "./JS/Components/v2/CmdDetail.svelte");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_loader_lib_hot_api_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./node_modules/svelte-loader/lib/hot-api.js */ "./node_modules/svelte-loader/lib/hot-api.js");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_hmr_runtime_proxy_adapter_dom_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js */ "./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/* JS\Components\v2\CmdList.svelte generated by Svelte v3.59.2 */







const file = "JS\\Components\\v2\\CmdList.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	child_ctx[7] = i;
	return child_ctx;
}

// (16:0) {:else}
function create_else_block(ctx) {
	let div1;
	let div0;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let div1_intro;
	let each_value = /*$cmdStore*/ ctx[1];
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value);
	const get_key = ctx => /*i*/ ctx[7];
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_keys)(ctx, each_value, get_each_context, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	const block = {
		c: function create() {
			div1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div0, "class", "mt-2 grid gap-2 grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div0, file, 17, 4, 546);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div1, "class", "flex flex-col h-full w-full px-4 pb-2 overflow-auto");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div1, file, 16, 2, 467);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div1, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div0, null);
				}
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$cmdStore, CommandType, runCmd, toggleCmd, detail*/ 3) {
				each_value = /*$cmdStore*/ ctx[1];
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value);
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_keys)(ctx, each_value, get_each_context, get_key);
				each_blocks = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_keyed_each)(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div0, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_block, create_each_block, null, get_each_context);
			}
		},
		i: function intro(local) {
			if (!div1_intro) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_render_callback)(() => {
					div1_intro = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_in_transition)(div1, svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fade, {});
					div1_intro.start();
				});
			}
		},
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(16:0) {:else}",
		ctx
	});

	return block;
}

// (12:0) {#if detail}
function create_if_block(ctx) {
	let div;
	let cmddetail;
	let div_intro;
	let current;

	cmddetail = new _CmdDetail_svelte__WEBPACK_IMPORTED_MODULE_5__["default"]({
			props: {
				detail: /*detail*/ ctx[0],
				back: /*back*/ ctx[2]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(cmddetail.$$.fragment);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div, "class", "flex flex-col h-full w-full px-4 pb-2 overflow-auto");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div, file, 12, 2, 336);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(cmddetail, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cmddetail_changes = {};
			if (dirty & /*detail*/ 1) cmddetail_changes.detail = /*detail*/ ctx[0];
			cmddetail.$set(cmddetail_changes);
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(cmddetail.$$.fragment, local);

			if (!div_intro) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_render_callback)(() => {
					div_intro = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_in_transition)(div, svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fade, {});
					div_intro.start();
				});
			}

			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(cmddetail.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(cmddetail);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(12:0) {#if detail}",
		ctx
	});

	return block;
}

// (79:16) {:else}
function create_else_block_1(ctx) {
	let svg;
	let path0;
	let path1;

	const block = {
		c: function create() {
			svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			path1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "stroke-linecap", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "stroke-linejoin", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "d", "M21 12a9 9 0 11-18 0 9 9 0 0118 0z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path0, file, 87, 20, 3601);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "stroke-linecap", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "stroke-linejoin", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "d", "M15.91 11.672a.375.375 0 010 .656l-5.603 3.113a.375.375 0 01-.557-.328V8.887c0-.286.307-.466.557-.327l5.603 3.112z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path1, file, 92, 20, 3807);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "fill", "none");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "viewBox", "0 0 24 24");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "stroke-width", "1.5");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "stroke", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "class", "w-6 h-6 text-green-600");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg, file, 79, 18, 3289);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, svg, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path1);
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(svg);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(79:16) {:else}",
		ctx
	});

	return block;
}

// (59:16) {#if cmd.unsub}
function create_if_block_1(ctx) {
	let svg;
	let path0;
	let path1;

	const block = {
		c: function create() {
			svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			path1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "stroke-linecap", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "stroke-linejoin", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "d", "M21 12a9 9 0 11-18 0 9 9 0 0118 0z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path0, file, 67, 20, 2734);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "stroke-linecap", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "stroke-linejoin", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "d", "M9 9.563C9 9.252 9.252 9 9.563 9h4.874c.311 0 .563.252.563.563v4.874c0 .311-.252.563-.563.563H9.564A.562.562 0 019 14.437V9.564z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path1, file, 72, 20, 2940);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "fill", "none");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "viewBox", "0 0 24 24");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "stroke-width", "1.5");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "stroke", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "class", "w-6 h-6 text-red-600");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg, file, 59, 18, 2424);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, svg, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path1);
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(svg);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(59:16) {#if cmd.unsub}",
		ctx
	});

	return block;
}

// (21:6) {#each $cmdStore as cmd, i (i)}
function create_each_block(key_1, ctx) {
	let div6;
	let div5;
	let div0;
	let button0;
	let svg;
	let path;
	let t0;
	let div3;
	let div1;
	let t1_value = /*cmd*/ ctx[5].id + "";
	let t1;
	let t2;
	let div2;
	let t3_value = (/*cmd*/ ctx[5].error ?? "") + "";
	let t3;
	let t4;
	let div4;
	let button1;
	let t5;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[3](/*cmd*/ ctx[5]);
	}

	function select_block_type_1(ctx, dirty) {
		if (/*cmd*/ ctx[5].unsub) return create_if_block_1;
		return create_else_block_1;
	}

	let current_block_type = select_block_type_1(ctx, -1);
	let if_block = current_block_type(ctx);

	function click_handler_1() {
		return /*click_handler_1*/ ctx[4](/*cmd*/ ctx[5]);
	}

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			div6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			button0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t1_value);
			t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			t3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t3_value);
			t4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			button1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			if_block.c();
			t5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "stroke-linecap", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "stroke-linejoin", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "d", "M13.5 6H5.25A2.25 2.25 0 003 8.25v10.5A2.25 2.25 0 005.25 21h10.5A2.25 2.25 0 0018 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path, file, 36, 18, 1386);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "fill", "none");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "viewBox", "0 0 24 24");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "stroke-width", "1.5");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "stroke", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "class", "w-6 h-6 text-slate-200");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg, file, 28, 16, 1090);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button0, "class", "h-full rounded-tl-md rounded-bl-md p-1 bg-amber-700 hover:bg-amber-600 active:scale-90");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button0, file, 24, 14, 887);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div0, "class", "flex h-full flex-col justify-between");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div0, file, 23, 12, 821);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div1, "class", "font-semibold");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div1, file, 45, 14, 1799);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div2, "class", "bg-red-500 text-slate-200");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div2, file, 46, 14, 1856);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div3, "class", "flex flex-col w-full text-center");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div3, file, 44, 12, 1737);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button1, "class", "h-full rounded-tr-md rounded-br-md bg-slate-200 p-1 hover:bg-slate-100 active:scale-90");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button1, "data-bs-target", "tooltip");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button1, "title", "Run");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button1, file, 49, 14, 2002);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div4, "class", "flex h-full flex-col");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div4, file, 48, 12, 1952);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div5, "class", "flex h-full items-center justify-between");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div5, file, 22, 10, 753);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div6, "class", "rounded-md bg-slate-200 shadow-lg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div6, file, 21, 8, 694);
			this.first = div6;
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div6, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, div5);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, div0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div0, button0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button0, svg);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, t0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, div3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, div1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, t1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, t2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, div2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, t3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, t4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, div4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, button1);
			if_block.m(button1, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, t5);

			if (!mounted) {
				dispose = [
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button0, "click", click_handler, false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button1, "click", click_handler_1, false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*$cmdStore*/ 2 && t1_value !== (t1_value = /*cmd*/ ctx[5].id + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t1, t1_value);
			if (dirty & /*$cmdStore*/ 2 && t3_value !== (t3_value = (/*cmd*/ ctx[5].error ?? "") + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t3, t3_value);

			if (current_block_type !== (current_block_type = select_block_type_1(ctx, dirty))) {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(button1, null);
				}
			}
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div6);
			if_block.d();
			mounted = false;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.run_all)(dispose);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(21:6) {#each $cmdStore as cmd, i (i)}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*detail*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(if_block_anchor);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $cmdStore;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_store)(_stores__WEBPACK_IMPORTED_MODULE_3__.cmdStore, 'cmdStore');
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, _stores__WEBPACK_IMPORTED_MODULE_3__.cmdStore, $$value => $$invalidate(1, $cmdStore = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)('CmdList', slots, []);
	let detail = null;
	const back = () => $$invalidate(0, detail = null);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CmdList> was created with unknown prop '${key}'`);
	});

	const click_handler = cmd => $$invalidate(0, detail = cmd);

	const click_handler_1 = cmd => cmd.type === _types__WEBPACK_IMPORTED_MODULE_2__.CommandType.func
	? (0,_submit__WEBPACK_IMPORTED_MODULE_4__.runCmd)(cmd, null)
	: (0,_submit__WEBPACK_IMPORTED_MODULE_4__.toggleCmd)(cmd);

	$$self.$capture_state = () => ({
		fade: svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fade,
		CommandType: _types__WEBPACK_IMPORTED_MODULE_2__.CommandType,
		cmdStore: _stores__WEBPACK_IMPORTED_MODULE_3__.cmdStore,
		runCmd: _submit__WEBPACK_IMPORTED_MODULE_4__.runCmd,
		toggleCmd: _submit__WEBPACK_IMPORTED_MODULE_4__.toggleCmd,
		CmdDetail: _CmdDetail_svelte__WEBPACK_IMPORTED_MODULE_5__["default"],
		detail,
		back,
		$cmdStore
	});

	$$self.$inject_state = $$props => {
		if ('detail' in $$props) $$invalidate(0, detail = $$props.detail);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [detail, $cmdStore, back, click_handler, click_handler_1];
}

class CmdList extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {
	constructor(options) {
		super(options);
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {});

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "CmdList",
			options,
			id: create_fragment.name
		});
	}
}

if (module && module.hot) {}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CmdList);



/***/ }),

/***/ "./JS/Components/v2/CqlDetail.svelte":
/*!*******************************************!*\
  !*** ./JS/Components/v2/CqlDetail.svelte ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var svelte_transition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte/transition */ "./node_modules/svelte/transition/index.mjs");
/* harmony import */ var prismjs_prism__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prismjs/prism */ "./node_modules/prismjs/prism.js");
/* harmony import */ var prismjs_prism__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prismjs_prism__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _prism_celinql__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../prism-celinql */ "./JS/prism-celinql.js");
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../stores */ "./JS/stores.ts");
/* harmony import */ var _excel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../excel */ "./JS/excel.ts");
/* harmony import */ var _submit__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../submit */ "./JS/submit.ts");
/* harmony import */ var svelte__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! svelte */ "./node_modules/svelte/index.mjs");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_loader_lib_hot_api_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./node_modules/svelte-loader/lib/hot-api.js */ "./node_modules/svelte-loader/lib/hot-api.js");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_hmr_runtime_proxy_adapter_dom_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js */ "./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/* JS\Components\v2\CqlDetail.svelte generated by Svelte v3.59.2 */









const file = "JS\\Components\\v2\\CqlDetail.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[19] = list[i];
	child_ctx[21] = i;
	return child_ctx;
}

// (49:0) {#if detail}
function create_if_block(ctx) {
	let div13;
	let div2;
	let div0;
	let button0;
	let svg0;
	let path0;
	let t0;
	let button1;
	let t1;
	let div1;
	let t2_value = /*detail*/ ctx[0].id + "";
	let t2;
	let t3;
	let button2;
	let svg1;
	let path1;
	let t4;
	let div12;
	let div3;
	let t6;
	let div7;
	let div4;
	let button3;
	let svg2;
	let path2;
	let path3;
	let t7;
	let button4;
	let svg3;
	let path4;
	let t8;
	let button5;
	let svg4;
	let path5;
	let t9;
	let div5;
	let label0;
	let input0;
	let t10;
	let t11;
	let label1;
	let input1;
	let t12;
	let t13;
	let div6;
	let label2;
	let input2;
	let t14;
	let t15;
	let t16;
	let div8;
	let t18;
	let div9;
	let table;
	let tbody;
	let t19;
	let tr0;
	let td0;
	let t21;
	let td1;
	let t22_value = /*detail*/ ctx[0].title + "";
	let t22;
	let t23;
	let tr1;
	let td2;
	let t25;
	let td3;
	let t26_value = /*detail*/ ctx[0].user + "";
	let t26;
	let t27;
	let tr2;
	let td4;
	let t29;
	let td5;
	let t30_value = /*detail*/ ctx[0].environment + "";
	let t30;
	let t31;
	let tr3;
	let td6;
	let t33;
	let td7;
	let t34_value = (/*timeSince*/ ctx[2] ?? /*since*/ ctx[4](new Date(/*detail*/ ctx[0].submitted))) + "";
	let t34;
	let t35;
	let tr4;
	let td8;
	let t37;
	let td9;
	let t38_value = ((/*detail*/ ctx[0].summary?.moreRecords) ? "first " : "") + "";
	let t38;
	let t39_value = /*summary*/ ctx[5](/*detail*/ ctx[0].summary?.records) + "";
	let t39;
	let t40;
	let div10;
	let t42;
	let div11;
	let pre;
	let code;
	let raw_value = prismjs_prism__WEBPACK_IMPORTED_MODULE_2___default().highlight(/*detail*/ ctx[0].query ?? /*detail*/ ctx[0].template, _prism_celinql__WEBPACK_IMPORTED_MODULE_3__.celinql, "CelinQL") + "";
	let div13_intro;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*detail*/ ctx[0].busy) return create_if_block_2;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block0 = current_block_type(ctx);
	let each_value = /*insertOptions*/ ctx[3];
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	let if_block1 = /*detail*/ ctx[0].error && create_if_block_1(ctx);

	const block = {
		c: function create() {
			div13 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			button0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			svg0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			button1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			if_block0.c();
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t2_value);
			t3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			button2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			svg1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			t4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div12 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div3.textContent = "Table Options";
			t6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div7 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			button3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			svg2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			path3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			t7 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			button4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			svg3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			t8 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			button5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			svg4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			t9 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			label0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("label");
			input0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("input");
			t10 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)("\r\n            With Menu Column");
			t11 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			label1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("label");
			input1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("input");
			t12 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)("\r\n            Alias Column Header");
			t13 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			label2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("label");
			input2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("input");
			t14 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)("\r\n            Auto Update");
			t15 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t16 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div8 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div8.textContent = "Info";
			t18 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div9 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			table = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("table");
			tbody = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("tbody");
			if (if_block1) if_block1.c();
			t19 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			tr0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("tr");
			td0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("td");
			td0.textContent = "Title";
			t21 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			td1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("td");
			t22 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t22_value);
			t23 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			tr1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("tr");
			td2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("td");
			td2.textContent = "User";
			t25 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			td3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("td");
			t26 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t26_value);
			t27 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			tr2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("tr");
			td4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("td");
			td4.textContent = "Environment";
			t29 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			td5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("td");
			t30 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t30_value);
			t31 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			tr3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("tr");
			td6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("td");
			td6.textContent = "Submitted";
			t33 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			td7 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("td");
			t34 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t34_value);
			t35 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			tr4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("tr");
			td8 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("td");
			td8.textContent = "Summary";
			t37 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			td9 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("td");
			t38 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t38_value);
			t39 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t39_value);
			t40 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div10 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div10.textContent = "Source";
			t42 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div11 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			pre = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("pre");
			code = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("code");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "fill-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "d", "M7.793 2.232a.75.75 0 01-.025 1.06L3.622 7.25h10.003a5.375 5.375 0 010 10.75H10.75a.75.75 0 010-1.5h2.875a3.875 3.875 0 000-7.75H3.622l4.146 3.957a.75.75 0 01-1.036 1.085l-5.5-5.25a.75.75 0 010-1.085l5.5-5.25a.75.75 0 011.06.025z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "clip-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path0, file, 69, 12, 2080);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "viewBox", "0 0 20 20");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "fill", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "class", "w-5 h-5 text-slate-200");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg0, file, 63, 10, 1891);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button0, "class", "p-1.5 rounded-tl-md bg-blue-700 hover:bg-blue-600 active:scale-90");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button0, "data-bs-target", "tooltip");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button0, "title", "Back");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button0, file, 54, 8, 1616);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button1, "class", "p-1.5 hover:bg-slate-100 active:scale-90");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button1, "data-bs-target", "tooltip");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button1, "title", "Refresh");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button1, file, 76, 8, 2467);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div0, "class", "flex");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div0, file, 53, 6, 1588);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div1, "class", "text-center font-semibold");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div1, file, 114, 6, 4787);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "fill-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "d", "M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "clip-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path1, file, 130, 10, 5287);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "class", "h-5 w-5 text-red-800");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "viewBox", "0 0 20 20");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "fill", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg1, file, 124, 8, 5112);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button2, "class", "rounded-tr-md ml-auto p-1.5 hover:bg-slate-100 active:scale-90");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button2, "data-bs-target", "tooltip");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button2, "title", "Delete");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button2, file, 115, 6, 4851);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div2, "class", "grid grid-cols-3 items-center border-b border-solid border-teal-900");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div2, file, 50, 4, 1486);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div3, "class", "w-full py-2 text-center text-lg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div3, file, 139, 6, 5673);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path2, "fill-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path2, "d", "M3 4.25A2.25 2.25 0 015.25 2h5.5A2.25 2.25 0 0113 4.25v2a.75.75 0 01-1.5 0v-2a.75.75 0 00-.75-.75h-5.5a.75.75 0 00-.75.75v11.5c0 .414.336.75.75.75h5.5a.75.75 0 00.75-.75v-2a.75.75 0 011.5 0v2A2.25 2.25 0 0110.75 18h-5.5A2.25 2.25 0 013 15.75V4.25z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path2, "clip-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path2, file, 154, 14, 6292);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path3, "fill-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path3, "d", "M19 10a.75.75 0 00-.75-.75H8.704l1.048-.943a.75.75 0 10-1.004-1.114l-2.5 2.25a.75.75 0 000 1.114l2.5 2.25a.75.75 0 101.004-1.114l-1.048-.943h9.546A.75.75 0 0019 10z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path3, "clip-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path3, file, 159, 14, 6674);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg2, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg2, "viewBox", "0 0 20 20");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg2, "fill", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg2, "class", "w-5 h-5");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg2, file, 148, 12, 6106);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button3, "class", "p-1.5 rounded-md hover:bg-slate-100 active:scale-90");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button3, "data-bs-target", "tooltip");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button3, "title", "Update Table");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button3, file, 142, 10, 5878);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path4, "d", "M64 32C28.7 32 0 60.7 0 96V416c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V96c0-35.3-28.7-64-64-64H64zm88 64v64H64V96h88zm56 0h88v64H208V96zm240 0v64H360V96h88zM64 224h88v64H64V224zm232 0v64H208V224h88zm64 0h88v64H360V224zM152 352v64H64V352h88zm56 0h88v64H208V352zm240 0v64H360V352h88z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path4, file, 176, 183, 7546);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg3, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg3, "class", "h-5 w-5");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg3, "viewBox", "0 0 512 512");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg3, file, 172, 12, 7239);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button4, "class", "p-1.5 rounded-md hover:bg-slate-100 active:scale-90");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button4, "data-bs-target", "tooltip");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button4, "title", "Create Table");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button4, file, 166, 10, 7010);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path5, "d", "M135.2 17.7L128 32H32C14.3 32 0 46.3 0 64S14.3 96 32 96H416c17.7 0 32-14.3 32-32s-14.3-32-32-32H320l-7.2-14.3C307.4 6.8 296.3 0 284.2 0H163.8c-12.1 0-23.2 6.8-28.6 17.7zM416 128H32L53.2 467c1.6 25.3 22.6 45 47.9 45H346.9c25.3 0 46.3-19.7 47.9-45L416 128z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path5, file, 192, 183, 8515);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg4, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg4, "class", "h-5 w-5 text-red-800");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg4, "viewBox", "0 0 448 512");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg4, "fill", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg4, file, 187, 12, 8160);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button5, "class", "p-1.5 rounded-md hover:bg-slate-100 active:scale-90");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button5, "data-bs-target", "tooltip");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button5, "title", "Delete Table");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button5, file, 181, 10, 7931);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div4, "class", "flex flex-row items-center justify-center pt-2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div4, file, 141, 8, 5806);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(input0, "type", "checkbox");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(input0, "class", "mx-1");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(input0, file, 200, 12, 8974);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(label0, "class", "mx-2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(label0, file, 199, 10, 8940);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(input1, "type", "checkbox");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(input1, "class", "mx-1");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(input1, file, 208, 12, 9197);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(label1, "class", "mx-2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(label1, file, 207, 10, 9163);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div5, "class", "flex flex-row justify-center py-2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div5, file, 198, 8, 8881);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(input2, "type", "checkbox");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(input2, "class", "mx-1");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(input2, file, 218, 12, 9499);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(label2, "class", "mx-2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(label2, file, 217, 10, 9465);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div6, "class", "flex flex-row justify-center py-2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div6, file, 216, 8, 9406);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div7, "class", "border-b border-solid border-teal-900");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div7, file, 140, 6, 5745);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div8, "class", "w-full py-2 text-center text-lg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div8, file, 238, 6, 10033);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(td0, "class", "font-semibold text-right px-2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(td0, file, 249, 14, 10464);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(td1, file, 250, 14, 10532);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(tr0, file, 248, 12, 10444);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(td2, "class", "font-semibold text-right px-2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(td2, file, 253, 14, 10608);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(td3, file, 254, 14, 10675);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(tr1, file, 252, 12, 10588);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(td4, "class", "font-semibold text-right px-2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(td4, file, 257, 14, 10750);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(td5, file, 258, 14, 10824);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(tr2, file, 256, 12, 10730);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(td6, "class", "font-semibold text-right px-2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(td6, file, 261, 14, 10906);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(td7, file, 262, 14, 10978);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(tr3, file, 260, 12, 10886);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(td8, "class", "font-semibold text-right px-2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(td8, file, 265, 14, 11088);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(td9, file, 266, 14, 11158);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(tr4, file, 264, 12, 11068);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(tbody, "class", "p-4");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(tbody, file, 241, 10, 10189);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(table, "class", "table-auto text-sm");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(table, file, 240, 8, 10143);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div9, "class", "flex flex-col mx-6 mb-2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div9, file, 239, 6, 10096);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div10, "class", "w-full py-2 text-center text-lg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div10, file, 275, 6, 11398);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(code, "class", "whitespace-pre-wrap break-words");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(code, file, 277, 13, 11533);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(pre, file, 277, 8, 11528);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div11, "class", "mx-6 mb-2 p-2 bg-slate-900 text-green-400");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div11, file, 276, 6, 11463);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div12, "class", "text-sm");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div12, file, 138, 4, 5644);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div13, "class", "rounded-md bg-slate-200 text-slate-900 shadow-lg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div13, file, 49, 2, 1410);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div13, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div13, div2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, div0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div0, button0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button0, svg0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg0, path0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div0, t0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div0, button1);
			if_block0.m(button1, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, t1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, div1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, t2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, t3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, button2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button2, svg1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg1, path1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div13, t4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div13, div12);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div12, div3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div12, t6);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div12, div7);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div7, div4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, button3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button3, svg2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg2, path2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg2, path3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, t7);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, button4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button4, svg3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg3, path4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, t8);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, button5);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button5, svg4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg4, path5);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div7, t9);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div7, div5);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, label0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(label0, input0);
			input0.checked = /*detail*/ ctx[0].withMenu;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(label0, t10);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, t11);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, label1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(label1, input1);
			input1.checked = /*detail*/ ctx[0].aliasHeader;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(label1, t12);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div7, t13);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div7, div6);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, label2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(label2, input2);
			input2.checked = /*detail*/ ctx[0].autoUpdate;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(label2, t14);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, t15);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div6, null);
				}
			}

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div12, t16);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div12, div8);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div12, t18);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div12, div9);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div9, table);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(table, tbody);
			if (if_block1) if_block1.m(tbody, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tbody, t19);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tbody, tr0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tr0, td0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tr0, t21);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tr0, td1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(td1, t22);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tbody, t23);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tbody, tr1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tr1, td2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tr1, t25);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tr1, td3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(td3, t26);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tbody, t27);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tbody, tr2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tr2, td4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tr2, t29);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tr2, td5);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(td5, t30);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tbody, t31);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tbody, tr3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tr3, td6);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tr3, t33);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tr3, td7);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(td7, t34);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tbody, t35);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tbody, tr4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tr4, td8);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tr4, t37);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tr4, td9);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(td9, t38);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(td9, t39);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div12, t40);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div12, div10);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div12, t42);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div12, div11);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div11, pre);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(pre, code);
			code.innerHTML = raw_value;

			if (!mounted) {
				dispose = [
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button0, "click", /*click_handler*/ ctx[6], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button1, "click", /*click_handler_1*/ ctx[7], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button2, "click", /*click_handler_2*/ ctx[8], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button3, "click", /*click_handler_3*/ ctx[9], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button4, "click", /*click_handler_4*/ ctx[10], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button5, "click", /*click_handler_5*/ ctx[11], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(input0, "change", /*input0_change_handler*/ ctx[12]),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(input1, "change", /*input1_change_handler*/ ctx[13]),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(input2, "change", /*input2_change_handler*/ ctx[14])
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (current_block_type !== (current_block_type = select_block_type(ctx, dirty))) {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(button1, null);
				}
			}

			if (dirty & /*detail*/ 1 && t2_value !== (t2_value = /*detail*/ ctx[0].id + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t2, t2_value);

			if (dirty & /*detail*/ 1) {
				input0.checked = /*detail*/ ctx[0].withMenu;
			}

			if (dirty & /*detail*/ 1) {
				input1.checked = /*detail*/ ctx[0].aliasHeader;
			}

			if (dirty & /*detail*/ 1) {
				input2.checked = /*detail*/ ctx[0].autoUpdate;
			}

			if (dirty & /*insertOptions, detail*/ 9) {
				each_value = /*insertOptions*/ ctx[3];
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div6, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (/*detail*/ ctx[0].error) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					if_block1.m(tbody, t19);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty & /*detail*/ 1 && t22_value !== (t22_value = /*detail*/ ctx[0].title + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t22, t22_value);
			if (dirty & /*detail*/ 1 && t26_value !== (t26_value = /*detail*/ ctx[0].user + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t26, t26_value);
			if (dirty & /*detail*/ 1 && t30_value !== (t30_value = /*detail*/ ctx[0].environment + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t30, t30_value);
			if (dirty & /*timeSince, detail*/ 5 && t34_value !== (t34_value = (/*timeSince*/ ctx[2] ?? /*since*/ ctx[4](new Date(/*detail*/ ctx[0].submitted))) + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t34, t34_value);
			if (dirty & /*detail*/ 1 && t38_value !== (t38_value = ((/*detail*/ ctx[0].summary?.moreRecords) ? "first " : "") + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t38, t38_value);
			if (dirty & /*detail*/ 1 && t39_value !== (t39_value = /*summary*/ ctx[5](/*detail*/ ctx[0].summary?.records) + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t39, t39_value);
			if (dirty & /*detail*/ 1 && raw_value !== (raw_value = prismjs_prism__WEBPACK_IMPORTED_MODULE_2___default().highlight(/*detail*/ ctx[0].query ?? /*detail*/ ctx[0].template, _prism_celinql__WEBPACK_IMPORTED_MODULE_3__.celinql, "CelinQL") + "")) code.innerHTML = raw_value;;
		},
		i: function intro(local) {
			if (!div13_intro) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_render_callback)(() => {
					div13_intro = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_in_transition)(div13, svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fade, {});
					div13_intro.start();
				});
			}
		},
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div13);
			if_block0.d();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_each)(each_blocks, detaching);
			if (if_block1) if_block1.d();
			mounted = false;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.run_all)(dispose);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(49:0) {#if detail}",
		ctx
	});

	return block;
}

// (99:10) {:else}
function create_else_block(ctx) {
	let svg;
	let path;

	const block = {
		c: function create() {
			svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "fill-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "d", "M15.312 11.424a5.5 5.5 0 01-9.201 2.466l-.312-.311h2.433a.75.75 0 000-1.5H3.989a.75.75 0 00-.75.75v4.242a.75.75 0 001.5 0v-2.43l.31.31a7 7 0 0011.712-3.138.75.75 0 00-1.449-.39zm1.23-3.723a.75.75 0 00.219-.53V2.929a.75.75 0 00-1.5 0V5.36l-.31-.31A7 7 0 003.239 8.188a.75.75 0 101.448.389A5.5 5.5 0 0113.89 6.11l.311.31h-2.432a.75.75 0 000 1.5h4.243a.75.75 0 00.53-.219z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "clip-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path, file, 105, 14, 4221);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "viewBox", "0 0 20 20");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "fill", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "class", "h-5 w-5 text-green-700");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg, file, 99, 12, 4020);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, svg, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path);
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(svg);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(99:10) {:else}",
		ctx
	});

	return block;
}

// (86:10) {#if detail.busy}
function create_if_block_2(ctx) {
	let svg;
	let path;

	const block = {
		c: function create() {
			svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "fill-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "d", "M8.34 1.804A1 1 0 019.32 1h1.36a1 1 0 01.98.804l.295 1.473c.497.144.971.342 1.416.587l1.25-.834a1 1 0 011.262.125l.962.962a1 1 0 01.125 1.262l-.834 1.25c.245.445.443.919.587 1.416l1.473.294a1 1 0 01.804.98v1.361a1 1 0 01-.804.98l-1.473.295a6.95 6.95 0 01-.587 1.416l.834 1.25a1 1 0 01-.125 1.262l-.962.962a1 1 0 01-1.262.125l-1.25-.834a6.953 6.953 0 01-1.416.587l-.294 1.473a1 1 0 01-.98.804H9.32a1 1 0 01-.98-.804l-.295-1.473a6.957 6.957 0 01-1.416-.587l-1.25.834a1 1 0 01-1.262-.125l-.962-.962a1 1 0 01-.125-1.262l.834-1.25a6.957 6.957 0 01-.587-1.416l-1.473-.294A1 1 0 011 10.68V9.32a1 1 0 01.804-.98l1.473-.295c.144-.497.342-.971.587-1.416l-.834-1.25a1 1 0 01.125-1.262l.962-.962A1 1 0 015.38 3.03l1.25.834a6.957 6.957 0 011.416-.587l.294-1.473zM13 10a3 3 0 11-6 0 3 3 0 016 0z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "clip-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path, file, 92, 14, 3067);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "viewBox", "0 0 20 20");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "fill", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "class", "h-5 w-5 text-red-700 animate-spin");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg, file, 86, 12, 2855);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, svg, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path);
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(svg);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(86:10) {#if detail.busy}",
		ctx
	});

	return block;
}

// (226:10) {#each insertOptions as option, i}
function create_each_block(ctx) {
	let label;
	let input;
	let input_value_value;
	let t0;
	let t1_value = /*option*/ ctx[19] + "";
	let t1;
	let t2;
	let binding_group;
	let mounted;
	let dispose;
	binding_group = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init_binding_group)(/*$$binding_groups*/ ctx[16][0]);

	const block = {
		c: function create() {
			label = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("label");
			input = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("input");
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t1_value);
			t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(input, "type", "radio");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(input, "class", "mx-1");
			input.__value = input_value_value = /*i*/ ctx[21];
			input.value = input.__value;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(input, file, 227, 14, 9769);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(label, "class", "mx-2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(label, file, 226, 12, 9733);
			binding_group.p(input);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, label, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(label, input);
			input.checked = input.__value === /*detail*/ ctx[0].insertOption;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(label, t0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(label, t1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(label, t2);

			if (!mounted) {
				dispose = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(input, "change", /*input_change_handler*/ ctx[15]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*detail*/ 1) {
				input.checked = input.__value === /*detail*/ ctx[0].insertOption;
			}
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(label);
			binding_group.r();
			mounted = false;
			dispose();
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(226:10) {#each insertOptions as option, i}",
		ctx
	});

	return block;
}

// (243:12) {#if detail.error}
function create_if_block_1(ctx) {
	let tr;
	let td0;
	let t1;
	let td1;
	let t2_value = /*detail*/ ctx[0].error + "";
	let t2;

	const block = {
		c: function create() {
			tr = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("tr");
			td0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("td");
			td0.textContent = "Error";
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			td1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("td");
			t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t2_value);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(td0, "class", "font-semibold text-right px-2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(td0, file, 244, 16, 10297);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(td1, file, 245, 16, 10367);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(tr, "class", "bg-red-200");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(tr, file, 243, 14, 10256);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, tr, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tr, td0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tr, t1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(tr, td1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(td1, t2);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*detail*/ 1 && t2_value !== (t2_value = /*detail*/ ctx[0].error + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(tr);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(243:12) {#if detail.error}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let if_block_anchor;
	let if_block = /*detail*/ ctx[0] && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, if_block_anchor, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (/*detail*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*detail*/ 1) {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: function intro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block);
		},
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(if_block_anchor);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)('CqlDetail', slots, []);
	const insertOptions = ["Insert", "Append", "Replace"];
	let { detail = false } = $$props;
	let { back } = $$props;

	const unsubscribe = _stores__WEBPACK_IMPORTED_MODULE_4__.cqlStateStore.subscribe(data => {
		if (data && detail && data.id === detail.id) {
			$$invalidate(0, detail = { ...detail, ...data });
		}
	});

	const since = dt => {
		const m = (Date.now() - dt) / (1000 * 60);

		if (m > 60) {
			const h = m / 60;

			if (h > 24) {
				const d = h / 24;
				if (d > 30) return dt.toDateString();
				return `${Math.round(d, 0)} days ago`;
			}

			return `${Math.round(h, 0)} hours ago`;
		}

		if (m < 1) return "Just now";
		return `${Math.round(m, 0)} minute${m < 2 ? "" : "s"} ago`;
	};

	let timeSince;
	const timer = setInterval(() => $$invalidate(2, timeSince = since(new Date(detail.submitted))), 1000);

	const summary = records => records > 0
	? records > 1 ? `${records} rows` : "1 row"
	: "No data";

	(0,svelte__WEBPACK_IMPORTED_MODULE_7__.onDestroy)(() => {
		clearInterval(timer);
		unsubscribe();
	});

	$$self.$$.on_mount.push(function () {
		if (back === undefined && !('back' in $$props || $$self.$$.bound[$$self.$$.props['back']])) {
			console.warn("<CqlDetail> was created without expected prop 'back'");
		}
	});

	const writable_props = ['detail', 'back'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CqlDetail> was created with unknown prop '${key}'`);
	});

	const $$binding_groups = [[]];

	const click_handler = () => {
		_stores__WEBPACK_IMPORTED_MODULE_4__.cqlStore.edit(detail);
		back();
	};

	const click_handler_1 = () => detail.busy
	? __webpack_require__.g.blazorLib.invokeMethodAsync("CancelQuery", detail.id)
	: (0,_submit__WEBPACK_IMPORTED_MODULE_6__.submitQuery)(detail.template ?? detail.query, detail.id);

	const click_handler_2 = () => {
		_stores__WEBPACK_IMPORTED_MODULE_4__.cqlStore.delete(detail.id);
		back();
	};

	const click_handler_3 = () => (0,_excel__WEBPACK_IMPORTED_MODULE_5__.insertData)(detail);
	const click_handler_4 = () => (0,_excel__WEBPACK_IMPORTED_MODULE_5__.createTable)(detail);
	const click_handler_5 = () => (0,_excel__WEBPACK_IMPORTED_MODULE_5__.deleteTable)(detail);

	function input0_change_handler() {
		detail.withMenu = this.checked;
		$$invalidate(0, detail);
	}

	function input1_change_handler() {
		detail.aliasHeader = this.checked;
		$$invalidate(0, detail);
	}

	function input2_change_handler() {
		detail.autoUpdate = this.checked;
		$$invalidate(0, detail);
	}

	function input_change_handler() {
		detail.insertOption = this.__value;
		$$invalidate(0, detail);
	}

	$$self.$$set = $$props => {
		if ('detail' in $$props) $$invalidate(0, detail = $$props.detail);
		if ('back' in $$props) $$invalidate(1, back = $$props.back);
	};

	$$self.$capture_state = () => ({
		fade: svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fade,
		Prism: (prismjs_prism__WEBPACK_IMPORTED_MODULE_2___default()),
		celinql: _prism_celinql__WEBPACK_IMPORTED_MODULE_3__.celinql,
		cqlStore: _stores__WEBPACK_IMPORTED_MODULE_4__.cqlStore,
		cqlStateStore: _stores__WEBPACK_IMPORTED_MODULE_4__.cqlStateStore,
		createTable: _excel__WEBPACK_IMPORTED_MODULE_5__.createTable,
		deleteTable: _excel__WEBPACK_IMPORTED_MODULE_5__.deleteTable,
		insertData: _excel__WEBPACK_IMPORTED_MODULE_5__.insertData,
		submitQuery: _submit__WEBPACK_IMPORTED_MODULE_6__.submitQuery,
		onDestroy: svelte__WEBPACK_IMPORTED_MODULE_7__.onDestroy,
		insertOptions,
		detail,
		back,
		unsubscribe,
		since,
		timeSince,
		timer,
		summary
	});

	$$self.$inject_state = $$props => {
		if ('detail' in $$props) $$invalidate(0, detail = $$props.detail);
		if ('back' in $$props) $$invalidate(1, back = $$props.back);
		if ('timeSince' in $$props) $$invalidate(2, timeSince = $$props.timeSince);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		detail,
		back,
		timeSince,
		insertOptions,
		since,
		summary,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		click_handler_5,
		input0_change_handler,
		input1_change_handler,
		input2_change_handler,
		input_change_handler,
		$$binding_groups
	];
}

class CqlDetail extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {
	constructor(options) {
		super(options);
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, { detail: 0, back: 1 });

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "CqlDetail",
			options,
			id: create_fragment.name
		});
	}

	get detail() {
		throw new Error("<CqlDetail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set detail(value) {
		throw new Error("<CqlDetail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get back() {
		throw new Error("<CqlDetail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set back(value) {
		throw new Error("<CqlDetail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

if (module && module.hot) {}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CqlDetail);



/***/ }),

/***/ "./JS/Components/v2/CqlList.svelte":
/*!*****************************************!*\
  !*** ./JS/Components/v2/CqlList.svelte ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var svelte_transition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte/transition */ "./node_modules/svelte/transition/index.mjs");
/* harmony import */ var _excel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../excel */ "./JS/excel.ts");
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../stores */ "./JS/stores.ts");
/* harmony import */ var _submit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../submit */ "./JS/submit.ts");
/* harmony import */ var _CqlDetail_svelte__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CqlDetail.svelte */ "./JS/Components/v2/CqlDetail.svelte");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_loader_lib_hot_api_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./node_modules/svelte-loader/lib/hot-api.js */ "./node_modules/svelte-loader/lib/hot-api.js");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_hmr_runtime_proxy_adapter_dom_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js */ "./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/* JS\Components\v2\CqlList.svelte generated by Svelte v3.59.2 */







const file = "JS\\Components\\v2\\CqlList.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	child_ctx[8] = i;
	return child_ctx;
}

// (71:14) {:else}
function create_else_block_1(ctx) {
	let svg;
	let path;

	const block = {
		c: function create() {
			svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "fill-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "d", "M15.312 11.424a5.5 5.5 0 01-9.201 2.466l-.312-.311h2.433a.75.75 0 000-1.5H3.989a.75.75 0 00-.75.75v4.242a.75.75 0 001.5 0v-2.43l.31.31a7 7 0 0011.712-3.138.75.75 0 00-1.449-.39zm1.23-3.723a.75.75 0 00.219-.53V2.929a.75.75 0 00-1.5 0V5.36l-.31-.31A7 7 0 003.239 8.188a.75.75 0 101.448.389A5.5 5.5 0 0113.89 6.11l.311.31h-2.432a.75.75 0 000 1.5h4.243a.75.75 0 00.53-.219z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "clip-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path, file, 77, 18, 3748);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "viewBox", "0 0 20 20");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "fill", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "class", "h-5 w-5 text-green-700");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg, file, 71, 16, 3523);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, svg, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path);
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(svg);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(71:14) {:else}",
		ctx
	});

	return block;
}

// (58:14) {#if item.busy}
function create_if_block_1(ctx) {
	let svg;
	let path;

	const block = {
		c: function create() {
			svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "fill-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "d", "M8.34 1.804A1 1 0 019.32 1h1.36a1 1 0 01.98.804l.295 1.473c.497.144.971.342 1.416.587l1.25-.834a1 1 0 011.262.125l.962.962a1 1 0 01.125 1.262l-.834 1.25c.245.445.443.919.587 1.416l1.473.294a1 1 0 01.804.98v1.361a1 1 0 01-.804.98l-1.473.295a6.95 6.95 0 01-.587 1.416l.834 1.25a1 1 0 01-.125 1.262l-.962.962a1 1 0 01-1.262.125l-1.25-.834a6.953 6.953 0 01-1.416.587l-.294 1.473a1 1 0 01-.98.804H9.32a1 1 0 01-.98-.804l-.295-1.473a6.957 6.957 0 01-1.416-.587l-1.25.834a1 1 0 01-1.262-.125l-.962-.962a1 1 0 01-.125-1.262l.834-1.25a6.957 6.957 0 01-.587-1.416l-1.473-.294A1 1 0 011 10.68V9.32a1 1 0 01.804-.98l1.473-.295c.144-.497.342-.971.587-1.416l-.834-1.25a1 1 0 01.125-1.262l.962-.962A1 1 0 015.38 3.03l1.25.834a6.957 6.957 0 011.416-.587l.294-1.473zM13 10a3 3 0 11-6 0 3 3 0 016 0z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "clip-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path, file, 64, 18, 2542);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "viewBox", "0 0 20 20");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "fill", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "class", "h-5 w-5 text-red-700 animate-spin");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg, file, 58, 16, 2306);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, svg, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path);
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(svg);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(58:14) {#if item.busy}",
		ctx
	});

	return block;
}

// (110:14) {:else}
function create_else_block(ctx) {
	let svg;
	let path;

	const block = {
		c: function create() {
			svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "fill-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "d", "M13.477 14.89A6 6 0 015.11 6.524l8.367 8.368zm1.414-1.414L6.524 5.11a6 6 0 018.367 8.367zM18 10a8 8 0 11-16 0 8 8 0 0116 0z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "clip-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path, file, 117, 18, 5859);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "class", "h-5 w-5");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "viewBox", "0 0 20 20");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "fill", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(svg, "error", /*item*/ ctx[6].error != null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg, file, 110, 16, 5597);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, svg, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$cqlStore*/ 2) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(svg, "error", /*item*/ ctx[6].error != null);
			}
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(svg);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(110:14) {:else}",
		ctx
	});

	return block;
}

// (92:14) {#if item.summary.records > 0}
function create_if_block(ctx) {
	let svg;
	let path0;
	let path1;

	const block = {
		c: function create() {
			svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			path1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "fill-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "d", "M3 4.25A2.25 2.25 0 015.25 2h5.5A2.25 2.25 0 0113 4.25v2a.75.75 0 01-1.5 0v-2a.75.75 0 00-.75-.75h-5.5a.75.75 0 00-.75.75v11.5c0 .414.336.75.75.75h5.5a.75.75 0 00.75-.75v-2a.75.75 0 011.5 0v2A2.25 2.25 0 0110.75 18h-5.5A2.25 2.25 0 013 15.75V4.25z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "clip-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path0, file, 98, 18, 4831);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "fill-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "d", "M19 10a.75.75 0 00-.75-.75H8.704l1.048-.943a.75.75 0 10-1.004-1.114l-2.5 2.25a.75.75 0 000 1.114l2.5 2.25a.75.75 0 101.004-1.114l-1.048-.943h9.546A.75.75 0 0019 10z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "clip-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path1, file, 103, 18, 5233);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "viewBox", "0 0 20 20");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "fill", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "class", "w-5 h-5");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg, file, 92, 16, 4621);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, svg, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path1);
		},
		p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(svg);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(92:14) {#if item.summary.records > 0}",
		ctx
	});

	return block;
}

// (20:4) {#each $cqlStore as item, i (i)}
function create_each_block(key_1, ctx) {
	let div6;
	let div5;
	let div0;
	let button0;
	let svg;
	let path;
	let t0;
	let div3;
	let div1;
	let t1_value = /*item*/ ctx[6].id + "";
	let t1;
	let t2;
	let div2;
	let t3_value = /*item*/ ctx[6].title + "";
	let t3;
	let t4;
	let div4;
	let button1;
	let t5;
	let button2;
	let t6;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[3](/*item*/ ctx[6]);
	}

	function select_block_type(ctx, dirty) {
		if (/*item*/ ctx[6].busy) return create_if_block_1;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block0 = current_block_type(ctx);

	function click_handler_1() {
		return /*click_handler_1*/ ctx[4](/*item*/ ctx[6]);
	}

	function select_block_type_1(ctx, dirty) {
		if (/*item*/ ctx[6].summary.records > 0) return create_if_block;
		return create_else_block;
	}

	let current_block_type_1 = select_block_type_1(ctx, -1);
	let if_block1 = current_block_type_1(ctx);

	function click_handler_2() {
		return /*click_handler_2*/ ctx[5](/*item*/ ctx[6]);
	}

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			div6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			button0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t1_value);
			t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			t3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t3_value);
			t4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			button1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			if_block0.c();
			t5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			button2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			if_block1.c();
			t6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "stroke-linecap", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "stroke-linejoin", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "d", "M13.5 6H5.25A2.25 2.25 0 003 8.25v10.5A2.25 2.25 0 005.25 21h10.5A2.25 2.25 0 0018 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path, file, 35, 16, 1294);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "fill", "none");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "viewBox", "0 0 24 24");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "stroke-width", "1.5");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "stroke", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "class", "w-6 h-6 text-slate-200");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg, file, 27, 14, 1014);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button0, "class", "h-full rounded-tl-md rounded-bl-md p-1 bg-blue-700 hover:bg-blue-600 active:scale-90");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button0, file, 23, 12, 820);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div0, "class", "flex h-full flex-col justify-between");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div0, file, 22, 10, 756);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div1, "class", "font-semibold");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div1, file, 44, 12, 1689);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div2, "class", "text-sm");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div2, file, 45, 12, 1745);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div3, "class", "flex h-full flex-col text-center");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div3, file, 43, 10, 1629);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button1, "class", "rounded-tr-md p-1 hover:bg-slate-100 active:scale-90");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button1, "data-bs-target", "tooltip");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button1, "title", "Refresh");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button1, file, 48, 12, 1878);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button2, "class", "rounded-br-md p-1 hover:bg-slate-100 active:scale-90");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button2, "data-bs-target", "tooltip");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button2, "title", "Paste Results");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button2, file, 85, 12, 4334);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div4, "class", "flex h-full flex-col justify-between");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div4, file, 47, 10, 1814);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div5, "class", "flex h-full items-center justify-between");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div5, file, 21, 8, 690);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div6, "class", "rounded-md bg-slate-200 shadow-lg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div6, file, 20, 6, 633);
			this.first = div6;
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div6, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, div5);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, div0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div0, button0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button0, svg);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, t0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, div3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, div1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, t1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, t2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, div2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, t3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, t4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, div4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, button1);
			if_block0.m(button1, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, t5);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, button2);
			if_block1.m(button2, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, t6);

			if (!mounted) {
				dispose = [
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button0, "click", click_handler, false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button1, "click", click_handler_1, false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button2, "click", click_handler_2, false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*$cqlStore*/ 2 && t1_value !== (t1_value = /*item*/ ctx[6].id + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t1, t1_value);
			if (dirty & /*$cqlStore*/ 2 && t3_value !== (t3_value = /*item*/ ctx[6].title + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t3, t3_value);

			if (current_block_type !== (current_block_type = select_block_type(ctx, dirty))) {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(button1, null);
				}
			}

			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx, dirty)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type_1(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(button2, null);
				}
			}
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div6);
			if_block0.d();
			if_block1.d();
			mounted = false;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.run_all)(dispose);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(20:4) {#each $cqlStore as item, i (i)}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div1;
	let cqldetail;
	let t;
	let div0;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let div0_intro;
	let current;

	cqldetail = new _CqlDetail_svelte__WEBPACK_IMPORTED_MODULE_5__["default"]({
			props: {
				detail: /*detail*/ ctx[0],
				back: /*back*/ ctx[2]
			},
			$$inline: true
		});

	let each_value = /*$cqlStore*/ ctx[1];
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value);
	const get_key = ctx => /*i*/ ctx[8];
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_keys)(ctx, each_value, get_each_context, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	const block = {
		c: function create() {
			div1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(cqldetail.$$.fragment);
			t = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div0, "class", "mt-2 grid gap-2 grid-cols-1 xs:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "grid", !/*detail*/ ctx[0]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "hidden", /*detail*/ ctx[0]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div0, file, 13, 2, 411);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div1, "class", "flex flex-col h-full w-full p-2 overflow-auto");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div1, file, 11, 0, 315);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div1, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(cqldetail, div1, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, t);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div0, null);
				}
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			const cqldetail_changes = {};
			if (dirty & /*detail*/ 1) cqldetail_changes.detail = /*detail*/ ctx[0];
			cqldetail.$set(cqldetail_changes);

			if (dirty & /*pasteData, $cqlStore, global, submitQuery, detail*/ 3) {
				each_value = /*$cqlStore*/ ctx[1];
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value);
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_keys)(ctx, each_value, get_each_context, get_key);
				each_blocks = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_keyed_each)(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div0, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_block, create_each_block, null, get_each_context);
			}

			if (!current || dirty & /*detail*/ 1) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "grid", !/*detail*/ ctx[0]);
			}

			if (!current || dirty & /*detail*/ 1) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "hidden", /*detail*/ ctx[0]);
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(cqldetail.$$.fragment, local);

			if (!div0_intro) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_render_callback)(() => {
					div0_intro = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_in_transition)(div0, svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fade, {});
					div0_intro.start();
				});
			}

			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(cqldetail.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(cqldetail);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $cqlStore;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_store)(_stores__WEBPACK_IMPORTED_MODULE_3__.cqlStore, 'cqlStore');
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, _stores__WEBPACK_IMPORTED_MODULE_3__.cqlStore, $$value => $$invalidate(1, $cqlStore = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)('CqlList', slots, []);
	let detail = false;
	const back = () => $$invalidate(0, detail = false);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CqlList> was created with unknown prop '${key}'`);
	});

	const click_handler = item => $$invalidate(0, detail = item);

	const click_handler_1 = item => item.busy
	? __webpack_require__.g.blazorLib.invokeMethodAsync("CancelQuery", item.id)
	: (0,_submit__WEBPACK_IMPORTED_MODULE_4__.submitQuery)(item.template ?? item.query, item.id);

	const click_handler_2 = item => (0,_excel__WEBPACK_IMPORTED_MODULE_2__.pasteData)(item);

	$$self.$capture_state = () => ({
		fade: svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fade,
		pasteData: _excel__WEBPACK_IMPORTED_MODULE_2__.pasteData,
		cqlStore: _stores__WEBPACK_IMPORTED_MODULE_3__.cqlStore,
		submitQuery: _submit__WEBPACK_IMPORTED_MODULE_4__.submitQuery,
		CqlDetail: _CqlDetail_svelte__WEBPACK_IMPORTED_MODULE_5__["default"],
		detail,
		back,
		$cqlStore
	});

	$$self.$inject_state = $$props => {
		if ('detail' in $$props) $$invalidate(0, detail = $$props.detail);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [detail, $cqlStore, back, click_handler, click_handler_1, click_handler_2];
}

class CqlList extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {
	constructor(options) {
		super(options);
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {});

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "CqlList",
			options,
			id: create_fragment.name
		});
	}
}

if (module && module.hot) {}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CqlList);



/***/ }),

/***/ "./JS/Components/v2/CslDetail.svelte":
/*!*******************************************!*\
  !*** ./JS/Components/v2/CslDetail.svelte ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var svelte__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte */ "./node_modules/svelte/index.mjs");
/* harmony import */ var svelte_transition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! svelte/transition */ "./node_modules/svelte/transition/index.mjs");
/* harmony import */ var prismjs_prism__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prismjs/prism */ "./node_modules/prismjs/prism.js");
/* harmony import */ var prismjs_prism__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prismjs_prism__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _prism_celinsl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../prism-celinsl */ "./JS/prism-celinsl.js");
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../stores */ "./JS/stores.ts");
/* harmony import */ var _submit__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../submit */ "./JS/submit.ts");
/* harmony import */ var _excel__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../excel */ "./JS/excel.ts");
/* harmony import */ var _CslProgress_svelte__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./CslProgress.svelte */ "./JS/Components/v2/CslProgress.svelte");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_loader_lib_hot_api_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./node_modules/svelte-loader/lib/hot-api.js */ "./node_modules/svelte-loader/lib/hot-api.js");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_hmr_runtime_proxy_adapter_dom_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js */ "./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/* JS\Components\v2\CslDetail.svelte generated by Svelte v3.59.2 */












const file = "JS\\Components\\v2\\CslDetail.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i];
	child_ctx[12] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[13] = list[i];
	child_ctx[12] = i;
	return child_ctx;
}

// (28:0) {#if detail}
function create_if_block(ctx) {
	let div6;
	let div2;
	let div0;
	let button0;
	let svg0;
	let path0;
	let t0;
	let button1;
	let t1;
	let button2;
	let svg1;
	let path1;
	let t2;
	let div1;
	let t3_value = /*detail*/ ctx[0].id + "";
	let t3;
	let t4;
	let button3;
	let svg2;
	let path2;
	let t5;
	let div3;
	let cslprogress;
	let t6;
	let div4;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t7;
	let div5;
	let pre;
	let code;
	let raw_value = prismjs_prism__WEBPACK_IMPORTED_MODULE_3___default().highlight(/*detail*/ ctx[0].source, _prism_celinsl__WEBPACK_IMPORTED_MODULE_4__.celinsl, "CelinSL") + "";
	let div6_intro;
	let current;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*detail*/ ctx[0].busy) return create_if_block_5;
		return create_else_block_2;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block = current_block_type(ctx);

	cslprogress = new _CslProgress_svelte__WEBPACK_IMPORTED_MODULE_8__["default"]({
			props: { item: /*detail*/ ctx[0] },
			$$inline: true
		});

	let each_value = /*$cslResponseStore*/ ctx[2];
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value);
	const get_key = ctx => /*i*/ ctx[12];
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_keys)(ctx, each_value, get_each_context, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	const block = {
		c: function create() {
			div6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			button0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			svg0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			button1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			if_block.c();
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			button2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			svg1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			t3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t3_value);
			t4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			button3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			svg2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			t5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(cslprogress.$$.fragment);
			t6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t7 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			pre = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("pre");
			code = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("code");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "fill-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "d", "M7.793 2.232a.75.75 0 01-.025 1.06L3.622 7.25h10.003a5.375 5.375 0 010 10.75H10.75a.75.75 0 010-1.5h2.875a3.875 3.875 0 000-7.75H3.622l4.146 3.957a.75.75 0 01-1.036 1.085l-5.5-5.25a.75.75 0 010-1.085l5.5-5.25a.75.75 0 011.06.025z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path0, "clip-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path0, file, 50, 12, 1396);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "viewBox", "0 0 20 20");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "fill", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg0, "class", "w-5 h-5 text-slate-200");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg0, file, 44, 10, 1207);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button0, "class", "p-1.5 rounded-tl-md bg-teal-700 hover:bg-teal-600 active:scale-90");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button0, "data-bs-target", "tooltip");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button0, "title", "Back");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button0, file, 36, 8, 968);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button1, "class", "p-1.5 hover:bg-slate-100 active:scale-90");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button1, "data-bs-target", "tooltip");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button1, "title", "Run");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button1, file, 57, 8, 1783);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "stroke-linecap", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "stroke-linejoin", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path1, "d", "M6 18L18 6M6 6l12 12");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path1, file, 111, 12, 4406);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "fill", "none");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "viewBox", "0 0 24 24");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "stroke-width", "1.5");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "stroke", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg1, "class", "w-6 h-6 text-red-800");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg1, file, 103, 10, 4160);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button2, "class", "p-1.5 hover:bg-slate-100 active:scale-90");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button2, "data-bs-target", "tooltip");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button2, "title", "Clear Output Trace");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button2, file, 94, 8, 3857);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div0, "class", "flex");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div0, file, 35, 6, 940);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div1, "class", "text-center font-semibold");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div1, file, 119, 6, 4603);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path2, "fill-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path2, "d", "M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path2, "clip-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path2, file, 135, 10, 5103);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg2, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg2, "class", "h-5 w-5 text-red-800");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg2, "viewBox", "0 0 20 20");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg2, "fill", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg2, file, 129, 8, 4928);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button3, "class", "ml-auto rounded-tr-md p-1.5 hover:bg-slate-100 active:scale-90");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button3, "data-bs-target", "tooltip");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button3, "title", "Delete");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button3, file, 120, 6, 4667);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div2, "class", "grid grid-cols-3 items-center border-b border-solid border-teal-900");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div2, file, 32, 4, 838);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div3, "class", "flex flex-col mx-4 my-2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div3, file, 143, 4, 5460);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div4, "class", "mx-2 max-h-48 overflow-auto");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div4, file, 146, 4, 5552);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(code, "class", "whitespace-pre-wrap");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(code, file, 235, 42, 10154);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(pre, "class", "max-h-36 overflow-auto");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(pre, file, 235, 6, 10118);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div5, "class", "flex flex-col mx-6 my-2 p-2 bg-slate-900 text-green-400");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div5, file, 234, 4, 10041);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div6, "class", "rounded-md bg-slate-200 text-slate-900 shadow-lg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div6, file, 28, 2, 748);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div6, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, div2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, div0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div0, button0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button0, svg0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg0, path0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div0, t0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div0, button1);
			if_block.m(button1, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div0, t1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div0, button2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button2, svg1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg1, path1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, t2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, div1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, t3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, t4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, button3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button3, svg2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg2, path2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, t5);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, div3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(cslprogress, div3, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, t6);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, div4);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div4, null);
				}
			}

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, t7);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, div5);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, pre);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(pre, code);
			code.innerHTML = raw_value;
			current = true;

			if (!mounted) {
				dispose = [
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button0, "click", /*click_handler*/ ctx[3], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button1, "click", /*click_handler_1*/ ctx[4], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button2, "click", /*click_handler_2*/ ctx[5], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button3, "click", /*click_handler_3*/ ctx[6], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (current_block_type !== (current_block_type = select_block_type(ctx, dirty))) {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(button1, null);
				}
			}

			if ((!current || dirty & /*detail*/ 1) && t3_value !== (t3_value = /*detail*/ ctx[0].id + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t3, t3_value);
			const cslprogress_changes = {};
			if (dirty & /*detail*/ 1) cslprogress_changes.item = /*detail*/ ctx[0];
			cslprogress.$set(cslprogress_changes);

			if (dirty & /*$cslResponseStore, navigator, JSON, stateStore, pasteGrid, pasteSpecs, detail*/ 5) {
				each_value = /*$cslResponseStore*/ ctx[2];
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value);
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_keys)(ctx, each_value, get_each_context, get_key);
				each_blocks = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_keyed_each)(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div4, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_block, create_each_block, null, get_each_context);
			}

			if ((!current || dirty & /*detail*/ 1) && raw_value !== (raw_value = prismjs_prism__WEBPACK_IMPORTED_MODULE_3___default().highlight(/*detail*/ ctx[0].source, _prism_celinsl__WEBPACK_IMPORTED_MODULE_4__.celinsl, "CelinSL") + "")) code.innerHTML = raw_value;;
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(cslprogress.$$.fragment, local);

			if (!div6_intro) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_render_callback)(() => {
					div6_intro = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_in_transition)(div6, svelte_transition__WEBPACK_IMPORTED_MODULE_2__.fade, {});
					div6_intro.start();
				});
			}

			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(cslprogress.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div6);
			if_block.d();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(cslprogress);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			mounted = false;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.run_all)(dispose);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(28:0) {#if detail}",
		ctx
	});

	return block;
}

// (80:10) {:else}
function create_else_block_2(ctx) {
	let svg;
	let path;

	const block = {
		c: function create() {
			svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "fill-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "d", "M2 10a8 8 0 1116 0 8 8 0 01-16 0zm6.39-2.908a.75.75 0 01.766.027l3.5 2.25a.75.75 0 010 1.262l-3.5 2.25A.75.75 0 018 12.25v-4.5a.75.75 0 01.39-.658z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "clip-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path, file, 86, 14, 3525);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "viewBox", "0 0 20 20");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "fill", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "class", "h-5 w-5 text-green-700");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg, file, 80, 12, 3324);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, svg, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path);
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(svg);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_else_block_2.name,
		type: "else",
		source: "(80:10) {:else}",
		ctx
	});

	return block;
}

// (67:10) {#if detail.busy}
function create_if_block_5(ctx) {
	let svg;
	let path;

	const block = {
		c: function create() {
			svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "fill-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "d", "M8.34 1.804A1 1 0 019.32 1h1.36a1 1 0 01.98.804l.295 1.473c.497.144.971.342 1.416.587l1.25-.834a1 1 0 011.262.125l.962.962a1 1 0 01.125 1.262l-.834 1.25c.245.445.443.919.587 1.416l1.473.294a1 1 0 01.804.98v1.361a1 1 0 01-.804.98l-1.473.295a6.95 6.95 0 01-.587 1.416l.834 1.25a1 1 0 01-.125 1.262l-.962.962a1 1 0 01-1.262.125l-1.25-.834a6.953 6.953 0 01-1.416.587l-.294 1.473a1 1 0 01-.98.804H9.32a1 1 0 01-.98-.804l-.295-1.473a6.957 6.957 0 01-1.416-.587l-1.25.834a1 1 0 01-1.262-.125l-.962-.962a1 1 0 01-.125-1.262l.834-1.25a6.957 6.957 0 01-.587-1.416l-1.473-.294A1 1 0 011 10.68V9.32a1 1 0 01.804-.98l1.473-.295c.144-.497.342-.971.587-1.416l-.834-1.25a1 1 0 01.125-1.262l.962-.962A1 1 0 015.38 3.03l1.25.834a6.957 6.957 0 011.416-.587l.294-1.473zM13 10a3 3 0 11-6 0 3 3 0 016 0z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "clip-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path, file, 73, 14, 2371);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "viewBox", "0 0 20 20");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "fill", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "class", "h-5 w-5 text-red-700 animate-spin");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg, file, 67, 12, 2159);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, svg, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path);
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(svg);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(67:10) {#if detail.busy}",
		ctx
	});

	return block;
}

// (149:8) {#if rs.id === detail.id}
function create_if_block_1(ctx) {
	let div1;
	let div0;
	let t0_value = (/*rs*/ ctx[10].msg ?? "") + "";
	let t0;
	let t1;
	let t2;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t3;
	let if_block = /*rs*/ ctx[10].error && create_if_block_4(ctx);
	let each_value_1 = /*rs*/ ctx[10].data;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value_1);
	const get_key = ctx => /*i*/ ctx[12];
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_keys)(ctx, each_value_1, get_each_context_1, get_key);

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1(ctx, each_value_1, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
	}

	const block = {
		c: function create() {
			div1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t0_value);
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			if (if_block) if_block.c();
			t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div0, "class", "flex flex-row px-2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div0, file, 150, 12, 5735);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div1, "class", "flex flex-col text-sm");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div1, file, 149, 10, 5686);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div1, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, div0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div0, t0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, t1);
			if (if_block) if_block.m(div1, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, t2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div1, null);
				}
			}

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, t3);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$cslResponseStore*/ 4 && t0_value !== (t0_value = (/*rs*/ ctx[10].msg ?? "") + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t0, t0_value);

			if (/*rs*/ ctx[10].error) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_4(ctx);
					if_block.c();
					if_block.m(div1, t2);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*navigator, JSON, $cslResponseStore, stateStore, pasteGrid, pasteSpecs*/ 4) {
				each_value_1 = /*rs*/ ctx[10].data;
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value_1);
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_keys)(ctx, each_value_1, get_each_context_1, get_key);
				each_blocks = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_keyed_each)(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, div1, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_block, create_each_block_1, t3, get_each_context_1);
			}
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div1);
			if (if_block) if_block.d();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(149:8) {#if rs.id === detail.id}",
		ctx
	});

	return block;
}

// (154:12) {#if rs.error}
function create_if_block_4(ctx) {
	let div;
	let pre;
	let t_value = /*rs*/ ctx[10].error + "";
	let t;

	const block = {
		c: function create() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			pre = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("pre");
			t = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t_value);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(pre, "class", "bg-red-400 px-2 text-stone-300");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(pre, file, 155, 16, 5906);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div, "class", "flex flex-row");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div, file, 154, 14, 5861);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div, pre);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(pre, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$cslResponseStore*/ 4 && t_value !== (t_value = /*rs*/ ctx[10].error + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(154:12) {#if rs.error}",
		ctx
	});

	return block;
}

// (226:16) {:else}
function create_else_block_1(ctx) {
	let div;
	let t_value = /*d*/ ctx[13].content + "";
	let t;

	const block = {
		c: function create() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			t = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t_value);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div, file, 226, 18, 9887);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$cslResponseStore*/ 4 && t_value !== (t_value = /*d*/ ctx[13].content + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(226:16) {:else}",
		ctx
	});

	return block;
}

// (161:16) {#if d.type}
function create_if_block_2(ctx) {
	let div;
	let t0_value = /*d*/ ctx[13].type + "";
	let t0;
	let t1;
	let show_if;
	let if_block_anchor;

	function select_block_type_2(ctx, dirty) {
		if (dirty & /*$cslResponseStore*/ 4) show_if = null;
		if (show_if == null) show_if = !!["dump", "data"].includes(/*d*/ ctx[13].type);
		if (show_if) return create_if_block_3;
		return create_else_block;
	}

	let current_block_type = select_block_type_2(ctx, -1);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t0_value);
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			if_block.c();
			if_block_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div, file, 161, 18, 6160);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div, t0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, t1, anchor);
			if_block.m(target, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$cslResponseStore*/ 4 && t0_value !== (t0_value = /*d*/ ctx[13].type + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t0, t0_value);

			if (current_block_type === (current_block_type = select_block_type_2(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(t1);
			if_block.d(detaching);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(if_block_anchor);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(161:16) {#if d.type}",
		ctx
	});

	return block;
}

// (194:18) {:else}
function create_else_block(ctx) {
	let button;
	let svg;
	let path;
	let mounted;
	let dispose;

	function click_handler_5() {
		return /*click_handler_5*/ ctx[8](/*d*/ ctx[13]);
	}

	const block = {
		c: function create() {
			button = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "stroke-linecap", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "stroke-linejoin", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "d", "M8.25 7.5V6.108c0-1.135.845-2.098 1.976-2.192.373-.03.748-.057 1.123-.08M15.75 18H18a2.25 2.25 0 002.25-2.25V6.108c0-1.135-.845-2.098-1.976-2.192a48.424 48.424 0 00-1.123-.08M15.75 18.75v-1.875a3.375 3.375 0 00-3.375-3.375h-1.5a1.125 1.125 0 01-1.125-1.125v-1.5A3.375 3.375 0 006.375 7.5H5.25m11.9-3.664A2.251 2.251 0 0015 2.25h-1.5a2.251 2.251 0 00-2.15 1.586m5.8 0c.065.21.1.433.1.664v.75h-6V4.5c0-.231.035-.454.1-.664M6.75 7.5H4.875c-.621 0-1.125.504-1.125 1.125v12c0 .621.504 1.125 1.125 1.125h9.75c.621 0 1.125-.504 1.125-1.125V16.5a9 9 0 00-9-9z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path, file, 217, 24, 9039);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "fill", "none");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "viewBox", "0 0 24 24");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "stroke-width", "1.5");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "stroke", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "class", "w-6 h-6");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg, file, 209, 22, 8710);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button, "class", "mx-2 p-0.5 hover:bg-slate-100 active:scale-90");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button, "data-bs-target", "tooltip");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button, "title", "Paste into Sheet");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button, file, 194, 20, 8090);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, button, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button, svg);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path);

			if (!mounted) {
				dispose = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button, "click", click_handler_5, false, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(button);
			mounted = false;
			dispose();
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(194:18) {:else}",
		ctx
	});

	return block;
}

// (165:18) {#if ["dump", "data"].includes(d.type)}
function create_if_block_3(ctx) {
	let button;
	let svg;
	let path;
	let mounted;
	let dispose;

	function click_handler_4() {
		return /*click_handler_4*/ ctx[7](/*d*/ ctx[13]);
	}

	const block = {
		c: function create() {
			button = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "stroke-linecap", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "stroke-linejoin", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "d", "M9 12h3.75M9 15h3.75M9 18h3.75m3 .75H18a2.25 2.25 0 002.25-2.25V6.108c0-1.135-.845-2.098-1.976-2.192a48.424 48.424 0 00-1.123-.08m-5.801 0c-.065.21-.1.433-.1.664 0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75 2.25 2.25 0 00-.1-.664m-5.8 0A2.251 2.251 0 0113.5 2.25H15c1.012 0 1.867.668 2.15 1.586m-5.8 0c-.376.023-.75.05-1.124.08C9.095 4.01 8.25 4.973 8.25 6.108V8.25m0 0H4.875c-.621 0-1.125.504-1.125 1.125v11.25c0 .621.504 1.125 1.125 1.125h9.75c.621 0 1.125-.504 1.125-1.125V9.375c0-.621-.504-1.125-1.125-1.125H8.25zM6.75 12h.008v.008H6.75V12zm0 3h.008v.008H6.75V15zm0 3h.008v.008H6.75V18z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path, file, 186, 24, 7226);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "fill", "none");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "viewBox", "0 0 24 24");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "stroke-width", "1.5");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "stroke", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "class", "w-6 h-6");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg, file, 178, 22, 6897);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button, "class", "mx-2 p-0.5 hover:bg-slate-100 active:scale-90");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button, "data-bs-target", "tooltip");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button, "title", "Copy to Clipboard");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button, file, 165, 20, 6302);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, button, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button, svg);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path);

			if (!mounted) {
				dispose = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button, "click", click_handler_4, false, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(button);
			mounted = false;
			dispose();
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(165:18) {#if [\\\"dump\\\", \\\"data\\\"].includes(d.type)}",
		ctx
	});

	return block;
}

// (159:12) {#each rs.data as d, i (i)}
function create_each_block_1(key_1, ctx) {
	let div;

	function select_block_type_1(ctx, dirty) {
		if (/*d*/ ctx[13].type) return create_if_block_2;
		return create_else_block_1;
	}

	let current_block_type = select_block_type_1(ctx, -1);
	let if_block = current_block_type(ctx);

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			if_block.c();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div, "class", "flex flex-row items-center pl-14");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div, file, 159, 14, 6064);
			this.first = div;
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div, anchor);
			if_block.m(div, null);
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div);
			if_block.d();
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(159:12) {#each rs.data as d, i (i)}",
		ctx
	});

	return block;
}

// (148:6) {#each $cslResponseStore as rs, i (i)}
function create_each_block(key_1, ctx) {
	let first;
	let if_block_anchor;
	let if_block = /*rs*/ ctx[10].id === /*detail*/ ctx[0].id && create_if_block_1(ctx);

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();
			if (if_block) if_block.c();
			if_block_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();
			this.first = first;
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, first, anchor);
			if (if_block) if_block.m(target, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, if_block_anchor, anchor);
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*rs*/ ctx[10].id === /*detail*/ ctx[0].id) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(first);
			if (if_block) if_block.d(detaching);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(if_block_anchor);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(148:6) {#each $cslResponseStore as rs, i (i)}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*detail*/ ctx[0] && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*detail*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*detail*/ 1) {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block, 1, 1, () => {
					if_block = null;
				});

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(if_block_anchor);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $cslResponseStore;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_store)(_stores__WEBPACK_IMPORTED_MODULE_5__.cslResponseStore, 'cslResponseStore');
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, _stores__WEBPACK_IMPORTED_MODULE_5__.cslResponseStore, $$value => $$invalidate(2, $cslResponseStore = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)('CslDetail', slots, []);
	let { detail } = $$props;
	let { back } = $$props;

	const unsubscribe = _stores__WEBPACK_IMPORTED_MODULE_5__.cslStateStore.subscribe(data => {
		if (data && detail && data.id === detail.id) {
			$$invalidate(0, detail = { ...detail, ...data });
		}
	});

	(0,svelte__WEBPACK_IMPORTED_MODULE_1__.onDestroy)(() => unsubscribe());

	$$self.$$.on_mount.push(function () {
		if (detail === undefined && !('detail' in $$props || $$self.$$.bound[$$self.$$.props['detail']])) {
			console.warn("<CslDetail> was created without expected prop 'detail'");
		}

		if (back === undefined && !('back' in $$props || $$self.$$.bound[$$self.$$.props['back']])) {
			console.warn("<CslDetail> was created without expected prop 'back'");
		}
	});

	const writable_props = ['detail', 'back'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CslDetail> was created with unknown prop '${key}'`);
	});

	const click_handler = () => {
		back();
	};

	const click_handler_1 = () => detail.busy
	? __webpack_require__.g.blazorLib.invokeMethodAsync("CancelScript", detail.id)
	: (0,_submit__WEBPACK_IMPORTED_MODULE_6__.submitScript)(detail.template ?? detail.source);

	const click_handler_2 = () => {
		_stores__WEBPACK_IMPORTED_MODULE_5__.cslProgressStore.clear(detail.id);
		_stores__WEBPACK_IMPORTED_MODULE_5__.cslResponseStore.clear(detail.id);
	};

	const click_handler_3 = () => {
		_stores__WEBPACK_IMPORTED_MODULE_5__.cslStore.delete(detail.id);
		back();
	};

	const click_handler_4 = d => {
		navigator.clipboard.writeText(JSON.stringify(d.content)).then(() => null).catch(err => _stores__WEBPACK_IMPORTED_MODULE_5__.stateStore.error("Copy failed", err, null));
	};

	const click_handler_5 = d => {
		switch (d.type) {
			case "grid":
				(0,_excel__WEBPACK_IMPORTED_MODULE_7__.pasteGrid)(d.content);
				break;
			case "specs":
				(0,_excel__WEBPACK_IMPORTED_MODULE_7__.pasteSpecs)(d.content);
				break;
		}
	};

	$$self.$$set = $$props => {
		if ('detail' in $$props) $$invalidate(0, detail = $$props.detail);
		if ('back' in $$props) $$invalidate(1, back = $$props.back);
	};

	$$self.$capture_state = () => ({
		onDestroy: svelte__WEBPACK_IMPORTED_MODULE_1__.onDestroy,
		fade: svelte_transition__WEBPACK_IMPORTED_MODULE_2__.fade,
		Prism: (prismjs_prism__WEBPACK_IMPORTED_MODULE_3___default()),
		celinsl: _prism_celinsl__WEBPACK_IMPORTED_MODULE_4__.celinsl,
		cslResponseStore: _stores__WEBPACK_IMPORTED_MODULE_5__.cslResponseStore,
		cslStore: _stores__WEBPACK_IMPORTED_MODULE_5__.cslStore,
		cslStateStore: _stores__WEBPACK_IMPORTED_MODULE_5__.cslStateStore,
		stateStore: _stores__WEBPACK_IMPORTED_MODULE_5__.stateStore,
		cslProgressStore: _stores__WEBPACK_IMPORTED_MODULE_5__.cslProgressStore,
		submitScript: _submit__WEBPACK_IMPORTED_MODULE_6__.submitScript,
		pasteGrid: _excel__WEBPACK_IMPORTED_MODULE_7__.pasteGrid,
		pasteSpecs: _excel__WEBPACK_IMPORTED_MODULE_7__.pasteSpecs,
		CslProgress: _CslProgress_svelte__WEBPACK_IMPORTED_MODULE_8__["default"],
		detail,
		back,
		unsubscribe,
		$cslResponseStore
	});

	$$self.$inject_state = $$props => {
		if ('detail' in $$props) $$invalidate(0, detail = $$props.detail);
		if ('back' in $$props) $$invalidate(1, back = $$props.back);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		detail,
		back,
		$cslResponseStore,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		click_handler_5
	];
}

class CslDetail extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {
	constructor(options) {
		super(options);
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, { detail: 0, back: 1 });

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "CslDetail",
			options,
			id: create_fragment.name
		});
	}

	get detail() {
		throw new Error("<CslDetail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set detail(value) {
		throw new Error("<CslDetail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get back() {
		throw new Error("<CslDetail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set back(value) {
		throw new Error("<CslDetail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

if (module && module.hot) {}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CslDetail);



/***/ }),

/***/ "./JS/Components/v2/CslList.svelte":
/*!*****************************************!*\
  !*** ./JS/Components/v2/CslList.svelte ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var svelte_transition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte/transition */ "./node_modules/svelte/transition/index.mjs");
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../stores */ "./JS/stores.ts");
/* harmony import */ var _submit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../submit */ "./JS/submit.ts");
/* harmony import */ var _CslDetail_svelte__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CslDetail.svelte */ "./JS/Components/v2/CslDetail.svelte");
/* harmony import */ var _CslProgress_svelte__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CslProgress.svelte */ "./JS/Components/v2/CslProgress.svelte");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_loader_lib_hot_api_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./node_modules/svelte-loader/lib/hot-api.js */ "./node_modules/svelte-loader/lib/hot-api.js");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_hmr_runtime_proxy_adapter_dom_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js */ "./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/* JS\Components\v2\CslList.svelte generated by Svelte v3.59.2 */







const file = "JS\\Components\\v2\\CslList.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	child_ctx[7] = i;
	return child_ctx;
}

// (77:14) {:else}
function create_else_block(ctx) {
	let svg;
	let path;

	const block = {
		c: function create() {
			svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "fill-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "d", "M2 10a8 8 0 1116 0 8 8 0 01-16 0zm6.39-2.908a.75.75 0 01.766.027l3.5 2.25a.75.75 0 010 1.262l-3.5 2.25A.75.75 0 018 12.25v-4.5a.75.75 0 01.39-.658z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "clip-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path, file, 83, 18, 3856);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "viewBox", "0 0 20 20");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "fill", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "class", "h-5 w-5 text-green-700");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg, file, 77, 16, 3631);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, svg, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path);
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(svg);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(77:14) {:else}",
		ctx
	});

	return block;
}

// (64:14) {#if item.busy}
function create_if_block(ctx) {
	let svg;
	let path;

	const block = {
		c: function create() {
			svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "fill-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "d", "M8.34 1.804A1 1 0 019.32 1h1.36a1 1 0 01.98.804l.295 1.473c.497.144.971.342 1.416.587l1.25-.834a1 1 0 011.262.125l.962.962a1 1 0 01.125 1.262l-.834 1.25c.245.445.443.919.587 1.416l1.473.294a1 1 0 01.804.98v1.361a1 1 0 01-.804.98l-1.473.295a6.95 6.95 0 01-.587 1.416l.834 1.25a1 1 0 01-.125 1.262l-.962.962a1 1 0 01-1.262.125l-1.25-.834a6.953 6.953 0 01-1.416.587l-.294 1.473a1 1 0 01-.98.804H9.32a1 1 0 01-.98-.804l-.295-1.473a6.957 6.957 0 01-1.416-.587l-1.25.834a1 1 0 01-1.262-.125l-.962-.962a1 1 0 01-.125-1.262l.834-1.25a6.957 6.957 0 01-.587-1.416l-1.473-.294A1 1 0 011 10.68V9.32a1 1 0 01.804-.98l1.473-.295c.144-.497.342-.971.587-1.416l-.834-1.25a1 1 0 01.125-1.262l.962-.962A1 1 0 015.38 3.03l1.25.834a6.957 6.957 0 011.416-.587l.294-1.473zM13 10a3 3 0 11-6 0 3 3 0 016 0z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "clip-rule", "evenodd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path, file, 70, 18, 2650);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "viewBox", "0 0 20 20");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "fill", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "class", "h-5 w-5 text-red-700 animate-spin");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg, file, 64, 16, 2414);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, svg, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path);
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(svg);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(64:14) {#if item.busy}",
		ctx
	});

	return block;
}

// (23:4) {#each $cslStore as item, i (i)}
function create_each_block(key_1, ctx) {
	let div6;
	let div5;
	let div0;
	let button0;
	let svg;
	let path;
	let t0;
	let div3;
	let div1;
	let t1_value = /*item*/ ctx[5].id + "";
	let t1;
	let t2;
	let cslprogress;
	let t3;
	let div2;
	let t4_value = (/*item*/ ctx[5].error ?? "") + "";
	let t4;
	let t5;
	let div4;
	let button1;
	let t6;
	let current;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[3](/*item*/ ctx[5]);
	}

	cslprogress = new _CslProgress_svelte__WEBPACK_IMPORTED_MODULE_5__["default"]({
			props: { item: /*item*/ ctx[5] },
			$$inline: true
		});

	function select_block_type(ctx, dirty) {
		if (/*item*/ ctx[5].busy) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block = current_block_type(ctx);

	function click_handler_1() {
		return /*click_handler_1*/ ctx[4](/*item*/ ctx[5]);
	}

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			div6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			button0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t1_value);
			t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(cslprogress.$$.fragment);
			t3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			t4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t4_value);
			t5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			button1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			if_block.c();
			t6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "stroke-linecap", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "stroke-linejoin", "round");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "d", "M13.5 6H5.25A2.25 2.25 0 003 8.25v10.5A2.25 2.25 0 005.25 21h10.5A2.25 2.25 0 0018 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path, file, 40, 16, 1334);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "fill", "none");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "viewBox", "0 0 24 24");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "stroke-width", "1.5");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "stroke", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "class", "w-6 h-6 text-slate-200");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg, file, 32, 14, 1054);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button0, "class", "h-full rounded-tl-md rounded-bl-md p-1 bg-teal-700 hover:bg-teal-600 active:scale-90");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button0, file, 26, 12, 825);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div0, "class", "flex h-full flex-col justify-between");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div0, file, 25, 10, 761);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div1, "class", "font-semibold");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div1, file, 49, 12, 1729);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div2, "class", "bg-red-500 text-slate-200");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div2, file, 51, 12, 1821);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div3, "class", "flex flex-col w-full text-center");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div3, file, 48, 10, 1669);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button1, "class", "h-full rounded-tr-md rounded-br-md bg-slate-200 p-1 hover:bg-slate-100 active:scale-90");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button1, "data-bs-target", "tooltip");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button1, "title", "Run");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button1, file, 54, 12, 1962);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div4, "class", "flex h-full flex-col");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div4, file, 53, 10, 1914);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div5, "class", "flex h-full items-center justify-between");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div5, file, 24, 8, 695);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div6, "class", "rounded-md bg-slate-200 shadow-lg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div6, file, 23, 6, 638);
			this.first = div6;
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div6, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, div5);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, div0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div0, button0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button0, svg);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, t0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, div3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, div1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, t1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, t2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(cslprogress, div3, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, t3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, div2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, t4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, t5);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, div4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, button1);
			if_block.m(button1, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, t6);
			current = true;

			if (!mounted) {
				dispose = [
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button0, "click", click_handler, false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button1, "click", click_handler_1, false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty & /*$cslStore*/ 2) && t1_value !== (t1_value = /*item*/ ctx[5].id + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t1, t1_value);
			const cslprogress_changes = {};
			if (dirty & /*$cslStore*/ 2) cslprogress_changes.item = /*item*/ ctx[5];
			cslprogress.$set(cslprogress_changes);
			if ((!current || dirty & /*$cslStore*/ 2) && t4_value !== (t4_value = (/*item*/ ctx[5].error ?? "") + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t4, t4_value);

			if (current_block_type !== (current_block_type = select_block_type(ctx, dirty))) {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(button1, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(cslprogress.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(cslprogress.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div6);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(cslprogress);
			if_block.d();
			mounted = false;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.run_all)(dispose);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(23:4) {#each $cslStore as item, i (i)}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div1;
	let csldetail;
	let t;
	let div0;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let div0_intro;
	let current;

	csldetail = new _CslDetail_svelte__WEBPACK_IMPORTED_MODULE_4__["default"]({
			props: {
				detail: /*detail*/ ctx[0],
				back: /*back*/ ctx[2]
			},
			$$inline: true
		});

	let each_value = /*$cslStore*/ ctx[1];
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value);
	const get_key = ctx => /*i*/ ctx[7];
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_keys)(ctx, each_value, get_each_context, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	const block = {
		c: function create() {
			div1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(csldetail.$$.fragment);
			t = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div0, "class", "mt-2 gap-2 grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "grid", !/*detail*/ ctx[0]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "hidden", /*detail*/ ctx[0]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div0, file, 16, 2, 436);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div1, "class", "flex flex-col h-full w-full px-4 pb-2 overflow-auto");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div1, file, 14, 0, 334);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div1, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(csldetail, div1, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, t);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div0, null);
				}
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			const csldetail_changes = {};
			if (dirty & /*detail*/ 1) csldetail_changes.detail = /*detail*/ ctx[0];
			csldetail.$set(csldetail_changes);

			if (dirty & /*$cslStore, global, submitScript, detail*/ 3) {
				each_value = /*$cslStore*/ ctx[1];
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value);
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_keys)(ctx, each_value, get_each_context, get_key);
				each_blocks = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_keyed_each)(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div0, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.outro_and_destroy_block, create_each_block, null, get_each_context);
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
			}

			if (!current || dirty & /*detail*/ 1) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "grid", !/*detail*/ ctx[0]);
			}

			if (!current || dirty & /*detail*/ 1) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "hidden", /*detail*/ ctx[0]);
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(csldetail.$$.fragment, local);

			for (let i = 0; i < each_value.length; i += 1) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(each_blocks[i]);
			}

			if (!div0_intro) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_render_callback)(() => {
					div0_intro = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_in_transition)(div0, svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fade, {});
					div0_intro.start();
				});
			}

			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(csldetail.$$.fragment, local);

			for (let i = 0; i < each_blocks.length; i += 1) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(csldetail);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $cslStore;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_store)(_stores__WEBPACK_IMPORTED_MODULE_2__.cslStore, 'cslStore');
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, _stores__WEBPACK_IMPORTED_MODULE_2__.cslStore, $$value => $$invalidate(1, $cslStore = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)('CslList', slots, []);
	let detail = null;

	const back = () => {
		$$invalidate(0, detail = null);
	};

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CslList> was created with unknown prop '${key}'`);
	});

	const click_handler = item => {
		$$invalidate(0, detail = item);
	};

	const click_handler_1 = item => item.busy
	? __webpack_require__.g.blazorLib.invokeMethodAsync("CancelScript", item.id)
	: (0,_submit__WEBPACK_IMPORTED_MODULE_3__.submitScript)(item.template ?? item.source);

	$$self.$capture_state = () => ({
		fade: svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fade,
		cslStore: _stores__WEBPACK_IMPORTED_MODULE_2__.cslStore,
		submitScript: _submit__WEBPACK_IMPORTED_MODULE_3__.submitScript,
		CslDetail: _CslDetail_svelte__WEBPACK_IMPORTED_MODULE_4__["default"],
		CslProgress: _CslProgress_svelte__WEBPACK_IMPORTED_MODULE_5__["default"],
		detail,
		back,
		$cslStore
	});

	$$self.$inject_state = $$props => {
		if ('detail' in $$props) $$invalidate(0, detail = $$props.detail);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [detail, $cslStore, back, click_handler, click_handler_1];
}

class CslList extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {
	constructor(options) {
		super(options);
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {});

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "CslList",
			options,
			id: create_fragment.name
		});
	}
}

if (module && module.hot) {}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CslList);



/***/ }),

/***/ "./JS/Components/v2/CslProgress.svelte":
/*!*********************************************!*\
  !*** ./JS/Components/v2/CslProgress.svelte ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var svelte__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte */ "./node_modules/svelte/index.mjs");
/* harmony import */ var svelte_transition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! svelte/transition */ "./node_modules/svelte/transition/index.mjs");
/* harmony import */ var svelte_motion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! svelte/motion */ "./node_modules/svelte/motion/index.mjs");
/* harmony import */ var svelte_easing__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! svelte/easing */ "./node_modules/svelte/easing/index.mjs");
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../stores */ "./JS/stores.ts");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_loader_lib_hot_api_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./node_modules/svelte-loader/lib/hot-api.js */ "./node_modules/svelte-loader/lib/hot-api.js");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_hmr_runtime_proxy_adapter_dom_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js */ "./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/* JS\Components\v2\CslProgress.svelte generated by Svelte v3.59.2 */







const file = "JS\\Components\\v2\\CslProgress.svelte";

function add_css(target) {
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_styles)(target, "svelte-12dvmjd", "progress.svelte-12dvmjd{background-color:rgb(226 232 240 / var(--tw-bg-opacity));color:#0f766e}progress.svelte-12dvmjd::-webkit-progress-bar{background-color:rgb(226 232 240 / var(--tw-bg-opacity));width:100%}progress.svelte-12dvmjd::-webkit-progress-value{background-color:#0f766e !important}progress.svelte-12dvmjd::-moz-progress-bar{background-color:#0f766e !important}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ3NsUHJvZ3Jlc3Muc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXVDRSx1QkFBUyxDQUNQLGdCQUFnQixDQUFFLElBQUksR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksZUFBZSxDQUFDLENBQUMsQ0FDekQsS0FBSyxDQUFFLE9BQ1QsQ0FFQSx1QkFBUSxzQkFBdUIsQ0FDN0IsZ0JBQWdCLENBQUUsSUFBSSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxlQUFlLENBQUMsQ0FBQyxDQUN6RCxLQUFLLENBQUUsSUFDVCxDQUVBLHVCQUFRLHdCQUF5QixDQUMvQixnQkFBZ0IsQ0FBRSxPQUFPLENBQUMsVUFDNUIsQ0FDQSx1QkFBUSxtQkFBb0IsQ0FDMUIsZ0JBQWdCLENBQUUsT0FBTyxDQUFDLFVBQzVCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkNzbFByb2dyZXNzLnN2ZWx0ZSJdfQ== */");
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	child_ctx[7] = i;
	return child_ctx;
}

// (21:2) {#if progress}
function create_if_block_1(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let each_value = /*progress*/ ctx[0].msgs;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value);
	const get_key = ctx => /*i*/ ctx[7];
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_keys)(ctx, each_value, get_each_context, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*progress*/ 1) {
				each_value = /*progress*/ ctx[0].msgs;
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value);
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_keys)(ctx, each_value, get_each_context, get_key);
				each_blocks = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_keyed_each)(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_block, create_each_block, each_1_anchor, get_each_context);
			}
		},
		i: function intro(local) {
			for (let i = 0; i < each_value.length; i += 1) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(each_blocks[i]);
			}
		},
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		d: function destroy(detaching) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(each_1_anchor);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(21:2) {#if progress}",
		ctx
	});

	return block;
}

// (22:4) {#each progress.msgs as msg, i (i)}
function create_each_block(key_1, ctx) {
	let span;
	let t_value = /*msg*/ ctx[5] + "";
	let t;
	let span_intro;

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			span = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");
			t = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t_value);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(span, "class", "mx-2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(span, file, 22, 6, 729);
			this.first = span;
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, span, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(span, t);
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*progress*/ 1 && t_value !== (t_value = /*msg*/ ctx[5] + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t, t_value);
		},
		i: function intro(local) {
			if (!span_intro) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_render_callback)(() => {
					span_intro = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_in_transition)(span, svelte_transition__WEBPACK_IMPORTED_MODULE_2__.fade, {});
					span_intro.start();
				});
			}
		},
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(span);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(22:4) {#each progress.msgs as msg, i (i)}",
		ctx
	});

	return block;
}

// (27:0) {#if progress?.errors}
function create_if_block(ctx) {
	let div;
	let t0_value = /*progress*/ ctx[0].errors + "";
	let t0;
	let t1;
	let div_transition;
	let current;

	const block = {
		c: function create() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t0_value);
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(" Error(s)");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div, "class", "text-sm text-center font-bold bg-red-400 text-slate-200");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div, file, 27, 2, 826);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div, t0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div, t1);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*progress*/ 1) && t0_value !== (t0_value = /*progress*/ ctx[0].errors + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t0, t0_value);
		},
		i: function intro(local) {
			if (current) return;

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_render_callback)(() => {
				if (!current) return;
				if (!div_transition) div_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(div, svelte_transition__WEBPACK_IMPORTED_MODULE_2__.fade, {}, true);
				div_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			if (!div_transition) div_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(div, svelte_transition__WEBPACK_IMPORTED_MODULE_2__.fade, {}, false);
			div_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div);
			if (detaching && div_transition) div_transition.end();
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(27:0) {#if progress?.errors}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let progress_1;
	let t0;
	let div;
	let t1;
	let if_block1_anchor;
	let current;
	let if_block0 = /*progress*/ ctx[0] && create_if_block_1(ctx);
	let if_block1 = /*progress*/ ctx[0]?.errors && create_if_block(ctx);

	const block = {
		c: function create() {
			progress_1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("progress");
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			if (if_block0) if_block0.c();
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			if (if_block1) if_block1.c();
			if_block1_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(progress_1, "class", "h-1 w-full svelte-12dvmjd");
			progress_1.value = /*$rate*/ ctx[1];
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(progress_1, file, 18, 0, 561);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div, "class", "w-0 text-sm font-light whitespace-nowrap");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div, file, 19, 0, 608);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, progress_1, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, t0, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, t1, anchor);
			if (if_block1) if_block1.m(target, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, if_block1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*$rate*/ 2) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.prop_dev)(progress_1, "value", /*$rate*/ ctx[1]);
			}

			if (/*progress*/ ctx[0]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*progress*/ 1) {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0, 1);
					if_block0.m(div, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*progress*/ ctx[0]?.errors) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*progress*/ 1) {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block1);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(progress_1);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(t0);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div);
			if (if_block0) if_block0.d();
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(t1);
			if (if_block1) if_block1.d(detaching);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(if_block1_anchor);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $rate;
	let { $$slots: slots = {}, $$scope } = $$props;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)('CslProgress', slots, []);
	let { item } = $$props;
	let progress;
	const rate = (0,svelte_motion__WEBPACK_IMPORTED_MODULE_3__.tweened)(0, { duration: 400, easing: svelte_easing__WEBPACK_IMPORTED_MODULE_4__.cubicOut });
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_store)(rate, 'rate');
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, rate, value => $$invalidate(1, $rate = value));

	const unsubscribe = _stores__WEBPACK_IMPORTED_MODULE_5__.cslProgressStore.subscribe(p => {
		$$invalidate(0, progress = p.find(e => e.id === item.id));

		rate.set(progress && progress.of
		? (progress.row + 1) / progress.of
		: 0);
	});

	(0,svelte__WEBPACK_IMPORTED_MODULE_1__.onDestroy)(() => unsubscribe());

	$$self.$$.on_mount.push(function () {
		if (item === undefined && !('item' in $$props || $$self.$$.bound[$$self.$$.props['item']])) {
			console.warn("<CslProgress> was created without expected prop 'item'");
		}
	});

	const writable_props = ['item'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CslProgress> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('item' in $$props) $$invalidate(3, item = $$props.item);
	};

	$$self.$capture_state = () => ({
		onDestroy: svelte__WEBPACK_IMPORTED_MODULE_1__.onDestroy,
		fade: svelte_transition__WEBPACK_IMPORTED_MODULE_2__.fade,
		tweened: svelte_motion__WEBPACK_IMPORTED_MODULE_3__.tweened,
		cubicOut: svelte_easing__WEBPACK_IMPORTED_MODULE_4__.cubicOut,
		cslProgressStore: _stores__WEBPACK_IMPORTED_MODULE_5__.cslProgressStore,
		item,
		progress,
		rate,
		unsubscribe,
		$rate
	});

	$$self.$inject_state = $$props => {
		if ('item' in $$props) $$invalidate(3, item = $$props.item);
		if ('progress' in $$props) $$invalidate(0, progress = $$props.progress);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [progress, $rate, rate, item];
}

class CslProgress extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {
	constructor(options) {
		super(options);
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, { item: 3 }, add_css);

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "CslProgress",
			options,
			id: create_fragment.name
		});
	}

	get item() {
		throw new Error("<CslProgress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set item(value) {
		throw new Error("<CslProgress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

if (module && module.hot) {}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CslProgress);



/***/ }),

/***/ "./node_modules/svelte-select/ChevronIcon.svelte":
/*!*******************************************************!*\
  !*** ./node_modules/svelte-select/ChevronIcon.svelte ***!
  \*******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_loader_lib_hot_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/svelte-loader/lib/hot-api.js */ "./node_modules/svelte-loader/lib/hot-api.js");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_hmr_runtime_proxy_adapter_dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js */ "./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/* node_modules\svelte-select\ChevronIcon.svelte generated by Svelte v3.59.2 */


const file = "node_modules\\svelte-select\\ChevronIcon.svelte";

function add_css(target) {
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_styles)(target, "svelte-qbd276", "svg.svelte-qbd276{width:var(--chevron-icon-width, 20px);height:var(--chevron-icon-width, 20px);color:var(--chevron-icon-colour, currentColor)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2hldnJvbkljb24uc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWdCRSxpQkFBSSxDQUNBLEtBQUssQ0FBRSxJQUFJLG9CQUFvQixDQUFDLEtBQUssQ0FBQyxDQUN0QyxNQUFNLENBQUUsSUFBSSxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsQ0FDdkMsS0FBSyxDQUFFLElBQUkscUJBQXFCLENBQUMsYUFBYSxDQUNsRCIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDaGV2cm9uSWNvbi5zdmVsdGUiXX0= */");
}

function create_fragment(ctx) {
	let svg;
	let path;

	const block = {
		c: function create() {
			svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "fill", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "d", "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747\n          3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0\n          1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502\n          0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0\n          0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path, file, 6, 4, 114);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "width", "100%");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "height", "100%");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "viewBox", "0 0 20 20");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "focusable", "false");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "aria-hidden", "true");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "class", "svelte-qbd276");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg, file, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, svg, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path);
		},
		p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(svg);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)('ChevronIcon', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ChevronIcon> was created with unknown prop '${key}'`);
	});

	return [];
}

class ChevronIcon extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {
	constructor(options) {
		super(options);
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {}, add_css);

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "ChevronIcon",
			options,
			id: create_fragment.name
		});
	}
}

if (module && module.hot) {}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ChevronIcon);



/***/ }),

/***/ "./node_modules/svelte-select/ClearIcon.svelte":
/*!*****************************************************!*\
  !*** ./node_modules/svelte-select/ClearIcon.svelte ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_loader_lib_hot_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/svelte-loader/lib/hot-api.js */ "./node_modules/svelte-loader/lib/hot-api.js");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_hmr_runtime_proxy_adapter_dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js */ "./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/* node_modules\svelte-select\ClearIcon.svelte generated by Svelte v3.59.2 */


const file = "node_modules\\svelte-select\\ClearIcon.svelte";

function add_css(target) {
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_styles)(target, "svelte-whdbu1", "svg.svelte-whdbu1{width:var(--clear-icon-width, 20px);height:var(--clear-icon-width, 20px);color:var(--clear-icon-color, currentColor)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2xlYXJJY29uLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFnQkksaUJBQUksQ0FDQSxLQUFLLENBQUUsSUFBSSxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FDcEMsTUFBTSxDQUFFLElBQUksa0JBQWtCLENBQUMsS0FBSyxDQUFDLENBQ3JDLEtBQUssQ0FBRSxJQUFJLGtCQUFrQixDQUFDLGFBQWEsQ0FDL0MiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQ2xlYXJJY29uLnN2ZWx0ZSJdfQ== */");
}

function create_fragment(ctx) {
	let svg;
	let path;

	const block = {
		c: function create() {
			svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			path = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "fill", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(path, "d", "M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124\n    l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(path, file, 8, 4, 141);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "width", "100%");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "height", "100%");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "viewBox", "-2 -2 50 50");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "focusable", "false");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "aria-hidden", "true");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "role", "presentation");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "class", "svelte-whdbu1");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg, file, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, svg, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, path);
		},
		p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(svg);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)('ClearIcon', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ClearIcon> was created with unknown prop '${key}'`);
	});

	return [];
}

class ClearIcon extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {
	constructor(options) {
		super(options);
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {}, add_css);

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "ClearIcon",
			options,
			id: create_fragment.name
		});
	}
}

if (module && module.hot) {}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ClearIcon);



/***/ }),

/***/ "./node_modules/svelte-select/LoadingIcon.svelte":
/*!*******************************************************!*\
  !*** ./node_modules/svelte-select/LoadingIcon.svelte ***!
  \*******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_loader_lib_hot_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/svelte-loader/lib/hot-api.js */ "./node_modules/svelte-loader/lib/hot-api.js");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_hmr_runtime_proxy_adapter_dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js */ "./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/* node_modules\svelte-select\LoadingIcon.svelte generated by Svelte v3.59.2 */


const file = "node_modules\\svelte-select\\LoadingIcon.svelte";

function add_css(target) {
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_styles)(target, "svelte-1p3nqvd", ".loading.svelte-1p3nqvd{width:var(--spinner-width, 20px);height:var(--spinner-height, 20px);color:var(--spinner-color, var(--icons-color));animation:svelte-1p3nqvd-rotate 0.75s linear infinite;transform-origin:center center;transform:none}.circle_path.svelte-1p3nqvd{stroke-dasharray:90;stroke-linecap:round}@keyframes svelte-1p3nqvd-rotate{100%{transform:rotate(360deg)}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTG9hZGluZ0ljb24uc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWFJLHVCQUFTLENBQ0wsS0FBSyxDQUFFLElBQUksZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUNqQyxNQUFNLENBQUUsSUFBSSxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FDbkMsS0FBSyxDQUFFLElBQUksZUFBZSxDQUFDLG1CQUFtQixDQUFDLENBQy9DLFNBQVMsQ0FBRSxxQkFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUN2QyxnQkFBZ0IsQ0FBRSxNQUFNLENBQUMsTUFBTSxDQUMvQixTQUFTLENBQUUsSUFDZixDQUVBLDJCQUFhLENBQ1QsZ0JBQWdCLENBQUUsRUFBRSxDQUNwQixjQUFjLENBQUUsS0FDcEIsQ0FFQSxXQUFXLHFCQUFPLENBQ2QsSUFBSyxDQUNELFNBQVMsQ0FBRSxPQUFPLE1BQU0sQ0FDNUIsQ0FDSiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJMb2FkaW5nSWNvbi5zdmVsdGUiXX0= */");
}

function create_fragment(ctx) {
	let svg;
	let circle;

	const block = {
		c: function create() {
			svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			circle = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("circle");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(circle, "class", "circle_path svelte-1p3nqvd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(circle, "cx", "50");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(circle, "cy", "50");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(circle, "r", "20");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(circle, "fill", "none");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(circle, "stroke", "currentColor");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(circle, "stroke-width", "5");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(circle, "stroke-miterlimit", "10");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(circle, file, 1, 4, 48);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "class", "loading svelte-1p3nqvd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(svg, "viewBox", "25 25 50 50");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(svg, file, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, svg, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(svg, circle);
		},
		p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(svg);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)('LoadingIcon', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LoadingIcon> was created with unknown prop '${key}'`);
	});

	return [];
}

class LoadingIcon extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {
	constructor(options) {
		super(options);
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {}, add_css);

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "LoadingIcon",
			options,
			id: create_fragment.name
		});
	}
}

if (module && module.hot) {}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LoadingIcon);



/***/ }),

/***/ "./node_modules/svelte-select/Select.svelte":
/*!**************************************************!*\
  !*** ./node_modules/svelte-select/Select.svelte ***!
  \**************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var svelte__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte */ "./node_modules/svelte/index.mjs");
/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @floating-ui/dom */ "./node_modules/@floating-ui/dom/dist/floating-ui.dom.umd.js");
/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_floating_ui_dom__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var svelte_floating_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! svelte-floating-ui */ "./node_modules/svelte-floating-ui/index.js");
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filter */ "./node_modules/svelte-select/filter.js");
/* harmony import */ var _get_items__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./get-items */ "./node_modules/svelte-select/get-items.js");
/* harmony import */ var _ChevronIcon_svelte__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ChevronIcon.svelte */ "./node_modules/svelte-select/ChevronIcon.svelte");
/* harmony import */ var _ClearIcon_svelte__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ClearIcon.svelte */ "./node_modules/svelte-select/ClearIcon.svelte");
/* harmony import */ var _LoadingIcon_svelte__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./LoadingIcon.svelte */ "./node_modules/svelte-select/LoadingIcon.svelte");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_loader_lib_hot_api_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./node_modules/svelte-loader/lib/hot-api.js */ "./node_modules/svelte-loader/lib/hot-api.js");
/* harmony import */ var C_Users_fbrag_source_repos_Herdubreid_Celin_XL_Celin_XL_Server_node_modules_svelte_hmr_runtime_proxy_adapter_dom_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js */ "./node_modules/svelte-hmr/runtime/proxy-adapter-dom.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/* node_modules\svelte-select\Select.svelte generated by Svelte v3.59.2 */


const { Object: Object_1 } = svelte_internal__WEBPACK_IMPORTED_MODULE_0__.globals;








const file = "node_modules\\svelte-select\\Select.svelte";

function add_css(target) {
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_styles)(target, "svelte-apvs86", ".svelte-select.svelte-apvs86.svelte-apvs86.svelte-apvs86{--borderRadius:var(--border-radius);--clearSelectColor:var(--clear-select-color);--clearSelectWidth:var(--clear-select-width);--disabledBackground:var(--disabled-background);--disabledBorderColor:var(--disabled-border-color);--disabledColor:var(--disabled-color);--disabledPlaceholderColor:var(--disabled-placeholder-color);--disabledPlaceholderOpacity:var(--disabled-placeholder-opacity);--errorBackground:var(--error-background);--errorBorder:var(--error-border);--groupItemPaddingLeft:var(--group-item-padding-left);--groupTitleColor:var(--group-title-color);--groupTitleFontSize:var(--group-title-font-size);--groupTitleFontWeight:var(--group-title-font-weight);--groupTitlePadding:var(--group-title-padding);--groupTitleTextTransform:var(--group-title-text-transform);--indicatorColor:var(--chevron-color);--indicatorHeight:var(--chevron-height);--indicatorWidth:var(--chevron-width);--inputColor:var(--input-color);--inputLeft:var(--input-left);--inputLetterSpacing:var(--input-letter-spacing);--inputMargin:var(--input-margin);--inputPadding:var(--input-padding);--itemActiveBackground:var(--item-active-background);--itemColor:var(--item-color);--itemFirstBorderRadius:var(--item-first-border-radius);--itemHoverBG:var(--item-hover-bg);--itemHoverColor:var(--item-hover-color);--itemIsActiveBG:var(--item-is-active-bg);--itemIsActiveColor:var(--item-is-active-color);--itemIsNotSelectableColor:var(--item-is-not-selectable-color);--itemPadding:var(--item-padding);--listBackground:var(--list-background);--listBorder:var(--list-border);--listBorderRadius:var(--list-border-radius);--listEmptyColor:var(--list-empty-color);--listEmptyPadding:var(--list-empty-padding);--listEmptyTextAlign:var(--list-empty-text-align);--listMaxHeight:var(--list-max-height);--listPosition:var(--list-position);--listShadow:var(--list-shadow);--listZIndex:var(--list-z-index);--multiItemBG:var(--multi-item-bg);--multiItemBorderRadius:var(--multi-item-border-radius);--multiItemDisabledHoverBg:var(--multi-item-disabled-hover-bg);--multiItemDisabledHoverColor:var(--multi-item-disabled-hover-color);--multiItemHeight:var(--multi-item-height);--multiItemMargin:var(--multi-item-margin);--multiItemPadding:var(--multi-item-padding);--multiSelectInputMargin:var(--multi-select-input-margin);--multiSelectInputPadding:var(--multi-select-input-padding);--multiSelectPadding:var(--multi-select-padding);--placeholderColor:var(--placeholder-color);--placeholderOpacity:var(--placeholder-opacity);--selectedItemPadding:var(--selected-item-padding);--spinnerColor:var(--spinner-color);--spinnerHeight:var(--spinner-height);--spinnerWidth:var(--spinner-width);--internal-padding:0 0 0 16px;border:var(--border, 1px solid #d8dbdf);border-radius:var(--border-radius, 6px);min-height:var(--height, 42px);position:relative;display:flex;align-items:stretch;padding:var(--padding, var(--internal-padding));background:var(--background, #fff);margin:var(--margin, 0);width:var(--width, 100%);font-size:var(--font-size, 16px);max-height:var(--max-height)}.svelte-apvs86.svelte-apvs86.svelte-apvs86{box-sizing:var(--box-sizing, border-box)}.svelte-select.svelte-apvs86.svelte-apvs86.svelte-apvs86:hover{border:var(--border-hover, 1px solid #b2b8bf)}.value-container.svelte-apvs86.svelte-apvs86.svelte-apvs86{display:flex;flex:1 1 0%;flex-wrap:wrap;align-items:center;gap:5px 10px;padding:var(--value-container-padding, 5px 0);position:relative;overflow:var(--value-container-overflow, hidden);align-self:stretch}.prepend.svelte-apvs86.svelte-apvs86.svelte-apvs86,.indicators.svelte-apvs86.svelte-apvs86.svelte-apvs86{display:flex;flex-shrink:0;align-items:center}.indicators.svelte-apvs86.svelte-apvs86.svelte-apvs86{position:var(--indicators-position);top:var(--indicators-top);right:var(--indicators-right);bottom:var(--indicators-bottom)}input.svelte-apvs86.svelte-apvs86.svelte-apvs86{position:absolute;cursor:default;border:none;color:var(--input-color, var(--item-color));padding:var(--input-padding, 0);letter-spacing:var(--input-letter-spacing, inherit);margin:var(--input-margin, 0);min-width:10px;top:0;right:0;bottom:0;left:0;background:transparent;font-size:var(--font-size, 16px)}.svelte-apvs86:not(.multi)>.value-container.svelte-apvs86>input.svelte-apvs86{width:100%;height:100%}input.svelte-apvs86.svelte-apvs86.svelte-apvs86::placeholder{color:var(--placeholder-color, #78848f);opacity:var(--placeholder-opacity, 1)}input.svelte-apvs86.svelte-apvs86.svelte-apvs86:focus{outline:none}.svelte-select.focused.svelte-apvs86.svelte-apvs86.svelte-apvs86{border:var(--border-focused, 1px solid #006fe8);border-radius:var(--border-radius-focused, var(--border-radius, 6px))}.disabled.svelte-apvs86.svelte-apvs86.svelte-apvs86{background:var(--disabled-background, #ebedef);border-color:var(--disabled-border-color, #ebedef);color:var(--disabled-color, #c1c6cc)}.disabled.svelte-apvs86 input.svelte-apvs86.svelte-apvs86::placeholder{color:var(--disabled-placeholder-color, #c1c6cc);opacity:var(--disabled-placeholder-opacity, 1)}.selected-item.svelte-apvs86.svelte-apvs86.svelte-apvs86{position:relative;overflow:var(--selected-item-overflow, hidden);padding:var(--selected-item-padding, 0 20px 0 0);text-overflow:ellipsis;white-space:nowrap;color:var(--selected-item-color, inherit);font-size:var(--font-size, 16px)}.multi.svelte-apvs86 .selected-item.svelte-apvs86.svelte-apvs86{position:absolute;line-height:var(--height, 42px);height:var(--height, 42px)}.selected-item.svelte-apvs86.svelte-apvs86.svelte-apvs86:focus{outline:none}.hide-selected-item.svelte-apvs86.svelte-apvs86.svelte-apvs86{opacity:0}.icon.svelte-apvs86.svelte-apvs86.svelte-apvs86{display:flex;align-items:center;justify-content:center}.clear-select.svelte-apvs86.svelte-apvs86.svelte-apvs86{all:unset;display:flex;align-items:center;justify-content:center;width:var(--clear-select-width, 40px);height:var(--clear-select-height, 100%);color:var(--clear-select-color, var(--icons-color));margin:var(--clear-select-margin, 0);pointer-events:all;flex-shrink:0}.clear-select.svelte-apvs86.svelte-apvs86.svelte-apvs86:focus{outline:var(--clear-select-focus-outline, 1px solid #006fe8)}.loading.svelte-apvs86.svelte-apvs86.svelte-apvs86{width:var(--loading-width, 40px);height:var(--loading-height);color:var(--loading-color, var(--icons-color));margin:var(--loading--margin, 0);flex-shrink:0}.chevron.svelte-apvs86.svelte-apvs86.svelte-apvs86{width:var(--chevron-width, 40px);height:var(--chevron-height, 40px);background:var(--chevron-background, transparent);pointer-events:var(--chevron-pointer-events, none);color:var(--chevron-color, var(--icons-color));border:var(--chevron-border, 0 0 0 1px solid #d8dbdf);flex-shrink:0}.multi.svelte-apvs86.svelte-apvs86.svelte-apvs86{padding:var(--multi-select-padding, var(--internal-padding))}.multi.svelte-apvs86 input.svelte-apvs86.svelte-apvs86{padding:var(--multi-select-input-padding, 0);position:relative;margin:var(--multi-select-input-margin, 5px 0);flex:1 1 40px}.svelte-select.error.svelte-apvs86.svelte-apvs86.svelte-apvs86{border:var(--error-border, 1px solid #ff2d55);background:var(--error-background, #fff)}.a11y-text.svelte-apvs86.svelte-apvs86.svelte-apvs86{z-index:9999;border:0px;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0px;white-space:nowrap}.multi-item.svelte-apvs86.svelte-apvs86.svelte-apvs86{background:var(--multi-item-bg, #ebedef);margin:var(--multi-item-margin, 0);outline:var(--multi-item-outline, 1px solid #ddd);border-radius:var(--multi-item-border-radius, 4px);height:var(--multi-item-height, 25px);line-height:var(--multi-item-height, 25px);display:flex;cursor:default;padding:var(--multi-item-padding, 0 5px);overflow:hidden;gap:var(--multi-item-gap, 4px);outline-offset:-1px;max-width:var(--multi-max-width, none);color:var(--multi-item-color, var(--item-color))}.multi-item.disabled.svelte-apvs86.svelte-apvs86.svelte-apvs86:hover{background:var(--multi-item-disabled-hover-bg, #ebedef);color:var(--multi-item-disabled-hover-color, #c1c6cc)}.multi-item-text.svelte-apvs86.svelte-apvs86.svelte-apvs86{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.multi-item-clear.svelte-apvs86.svelte-apvs86.svelte-apvs86{display:flex;align-items:center;justify-content:center;--clear-icon-color:var(--multi-item-clear-icon-color, #000)}.multi-item.active.svelte-apvs86.svelte-apvs86.svelte-apvs86{outline:var(--multi-item-active-outline, 1px solid #006fe8)}.svelte-select-list.svelte-apvs86.svelte-apvs86.svelte-apvs86{box-shadow:var(--list-shadow, 0 2px 3px 0 rgba(44, 62, 80, 0.24));border-radius:var(--list-border-radius, 4px);max-height:var(--list-max-height, 252px);overflow-y:auto;background:var(--list-background, #fff);position:var(--list-position, absolute);z-index:var(--list-z-index, 2);border:var(--list-border)}.prefloat.svelte-apvs86.svelte-apvs86.svelte-apvs86{opacity:0;pointer-events:none}.list-group-title.svelte-apvs86.svelte-apvs86.svelte-apvs86{color:var(--group-title-color, #8f8f8f);cursor:default;font-size:var(--group-title-font-size, 16px);font-weight:var(--group-title-font-weight, 600);height:var(--height, 42px);line-height:var(--height, 42px);padding:var(--group-title-padding, 0 20px);text-overflow:ellipsis;overflow-x:hidden;white-space:nowrap;text-transform:var(--group-title-text-transform, uppercase)}.empty.svelte-apvs86.svelte-apvs86.svelte-apvs86{text-align:var(--list-empty-text-align, center);padding:var(--list-empty-padding, 20px 0);color:var(--list-empty-color, #78848f)}.item.svelte-apvs86.svelte-apvs86.svelte-apvs86{cursor:default;height:var(--item-height, var(--height, 42px));line-height:var(--item-line-height, var(--height, 42px));padding:var(--item-padding, 0 20px);color:var(--item-color, inherit);text-overflow:ellipsis;overflow:hidden;white-space:nowrap;transition:var(--item-transition, all 0.2s);align-items:center;width:100%}.item.group-item.svelte-apvs86.svelte-apvs86.svelte-apvs86{padding-left:var(--group-item-padding-left, 40px)}.item.svelte-apvs86.svelte-apvs86.svelte-apvs86:active{background:var(--item-active-background, #b9daff)}.item.active.svelte-apvs86.svelte-apvs86.svelte-apvs86{background:var(--item-is-active-bg, #007aff);color:var(--item-is-active-color, #fff)}.item.first.svelte-apvs86.svelte-apvs86.svelte-apvs86{border-radius:var(--item-first-border-radius, 4px 4px 0 0)}.item.hover.svelte-apvs86.svelte-apvs86.svelte-apvs86:not(.active){background:var(--item-hover-bg, #e7f2ff);color:var(--item-hover-color, inherit)}.item.not-selectable.svelte-apvs86.svelte-apvs86.svelte-apvs86,.item.hover.item.not-selectable.svelte-apvs86.svelte-apvs86.svelte-apvs86,.item.active.item.not-selectable.svelte-apvs86.svelte-apvs86.svelte-apvs86,.item.not-selectable.svelte-apvs86.svelte-apvs86.svelte-apvs86:active{color:var(--item-is-not-selectable-color, #999);background:transparent}.required.svelte-apvs86.svelte-apvs86.svelte-apvs86{opacity:0;z-index:-1;position:absolute;top:0;left:0;bottom:0;right:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VsZWN0LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUE0ekJJLHdEQUFlLENBRVgsY0FBYyxDQUFFLG9CQUFvQixDQUNwQyxrQkFBa0IsQ0FBRSx5QkFBeUIsQ0FDN0Msa0JBQWtCLENBQUUseUJBQXlCLENBQzdDLG9CQUFvQixDQUFFLDBCQUEwQixDQUNoRCxxQkFBcUIsQ0FBRSw0QkFBNEIsQ0FDbkQsZUFBZSxDQUFFLHFCQUFxQixDQUN0QywwQkFBMEIsQ0FBRSxpQ0FBaUMsQ0FDN0QsNEJBQTRCLENBQUUsbUNBQW1DLENBQ2pFLGlCQUFpQixDQUFFLHVCQUF1QixDQUMxQyxhQUFhLENBQUUsbUJBQW1CLENBQ2xDLHNCQUFzQixDQUFFLDhCQUE4QixDQUN0RCxpQkFBaUIsQ0FBRSx3QkFBd0IsQ0FDM0Msb0JBQW9CLENBQUUsNEJBQTRCLENBQ2xELHNCQUFzQixDQUFFLDhCQUE4QixDQUN0RCxtQkFBbUIsQ0FBRSwwQkFBMEIsQ0FDL0MseUJBQXlCLENBQUUsaUNBQWlDLENBQzVELGdCQUFnQixDQUFFLG9CQUFvQixDQUN0QyxpQkFBaUIsQ0FBRSxxQkFBcUIsQ0FDeEMsZ0JBQWdCLENBQUUsb0JBQW9CLENBQ3RDLFlBQVksQ0FBRSxrQkFBa0IsQ0FDaEMsV0FBVyxDQUFFLGlCQUFpQixDQUM5QixvQkFBb0IsQ0FBRSwyQkFBMkIsQ0FDakQsYUFBYSxDQUFFLG1CQUFtQixDQUNsQyxjQUFjLENBQUUsb0JBQW9CLENBQ3BDLHNCQUFzQixDQUFFLDZCQUE2QixDQUNyRCxXQUFXLENBQUUsaUJBQWlCLENBQzlCLHVCQUF1QixDQUFFLCtCQUErQixDQUN4RCxhQUFhLENBQUUsb0JBQW9CLENBQ25DLGdCQUFnQixDQUFFLHVCQUF1QixDQUN6QyxnQkFBZ0IsQ0FBRSx3QkFBd0IsQ0FDMUMsbUJBQW1CLENBQUUsMkJBQTJCLENBQ2hELDBCQUEwQixDQUFFLG1DQUFtQyxDQUMvRCxhQUFhLENBQUUsbUJBQW1CLENBQ2xDLGdCQUFnQixDQUFFLHNCQUFzQixDQUN4QyxZQUFZLENBQUUsa0JBQWtCLENBQ2hDLGtCQUFrQixDQUFFLHlCQUF5QixDQUM3QyxnQkFBZ0IsQ0FBRSx1QkFBdUIsQ0FDekMsa0JBQWtCLENBQUUseUJBQXlCLENBQzdDLG9CQUFvQixDQUFFLDRCQUE0QixDQUNsRCxlQUFlLENBQUUsc0JBQXNCLENBQ3ZDLGNBQWMsQ0FBRSxvQkFBb0IsQ0FDcEMsWUFBWSxDQUFFLGtCQUFrQixDQUNoQyxZQUFZLENBQUUsbUJBQW1CLENBQ2pDLGFBQWEsQ0FBRSxvQkFBb0IsQ0FDbkMsdUJBQXVCLENBQUUsK0JBQStCLENBQ3hELDBCQUEwQixDQUFFLG1DQUFtQyxDQUMvRCw2QkFBNkIsQ0FBRSxzQ0FBc0MsQ0FDckUsaUJBQWlCLENBQUUsd0JBQXdCLENBQzNDLGlCQUFpQixDQUFFLHdCQUF3QixDQUMzQyxrQkFBa0IsQ0FBRSx5QkFBeUIsQ0FDN0Msd0JBQXdCLENBQUUsZ0NBQWdDLENBQzFELHlCQUF5QixDQUFFLGlDQUFpQyxDQUM1RCxvQkFBb0IsQ0FBRSwyQkFBMkIsQ0FDakQsa0JBQWtCLENBQUUsd0JBQXdCLENBQzVDLG9CQUFvQixDQUFFLDBCQUEwQixDQUNoRCxxQkFBcUIsQ0FBRSw0QkFBNEIsQ0FDbkQsY0FBYyxDQUFFLG9CQUFvQixDQUNwQyxlQUFlLENBQUUscUJBQXFCLENBQ3RDLGNBQWMsQ0FBRSxvQkFBb0IsQ0FFcEMsa0JBQWtCLENBQUUsVUFBVSxDQUU5QixNQUFNLENBQUUsSUFBSSxRQUFRLENBQUMsa0JBQWtCLENBQUMsQ0FDeEMsYUFBYSxDQUFFLElBQUksZUFBZSxDQUFDLElBQUksQ0FBQyxDQUN4QyxVQUFVLENBQUUsSUFBSSxRQUFRLENBQUMsS0FBSyxDQUFDLENBQy9CLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsV0FBVyxDQUFFLE9BQU8sQ0FDcEIsT0FBTyxDQUFFLElBQUksU0FBUyxDQUFDLHdCQUF3QixDQUFDLENBQ2hELFVBQVUsQ0FBRSxJQUFJLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FDbkMsTUFBTSxDQUFFLElBQUksUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUN4QixLQUFLLENBQUUsSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLENBQ3pCLFNBQVMsQ0FBRSxJQUFJLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FDakMsVUFBVSxDQUFFLElBQUksWUFBWSxDQUNoQyxDQUVBLDBDQUFFLENBQ0UsVUFBVSxDQUFFLElBQUksWUFBWSxDQUFDLFdBQVcsQ0FDNUMsQ0FFQSx3REFBYyxNQUFPLENBQ2pCLE1BQU0sQ0FBRSxJQUFJLGNBQWMsQ0FBQyxrQkFBa0IsQ0FDakQsQ0FFQSwwREFBaUIsQ0FDYixPQUFPLENBQUUsSUFBSSxDQUNiLElBQUksQ0FBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FDWixTQUFTLENBQUUsSUFBSSxDQUNmLFdBQVcsQ0FBRSxNQUFNLENBQ25CLEdBQUcsQ0FBRSxHQUFHLENBQUMsSUFBSSxDQUNiLE9BQU8sQ0FBRSxJQUFJLHlCQUF5QixDQUFDLE1BQU0sQ0FBQyxDQUM5QyxRQUFRLENBQUUsUUFBUSxDQUNsQixRQUFRLENBQUUsSUFBSSwwQkFBMEIsQ0FBQyxPQUFPLENBQUMsQ0FDakQsVUFBVSxDQUFFLE9BQ2hCLENBRUEsa0RBQVEsQ0FDUixxREFBWSxDQUNSLE9BQU8sQ0FBRSxJQUFJLENBQ2IsV0FBVyxDQUFFLENBQUMsQ0FDZCxXQUFXLENBQUUsTUFDakIsQ0FFQSxxREFBWSxDQUNSLFFBQVEsQ0FBRSxJQUFJLHFCQUFxQixDQUFDLENBQ3BDLEdBQUcsQ0FBRSxJQUFJLGdCQUFnQixDQUFDLENBQzFCLEtBQUssQ0FBRSxJQUFJLGtCQUFrQixDQUFDLENBQzlCLE1BQU0sQ0FBRSxJQUFJLG1CQUFtQixDQUNuQyxDQUVBLCtDQUFNLENBQ0YsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsTUFBTSxDQUFFLE9BQU8sQ0FDZixNQUFNLENBQUUsSUFBSSxDQUNaLEtBQUssQ0FBRSxJQUFJLGFBQWEsQ0FBQyxrQkFBa0IsQ0FBQyxDQUM1QyxPQUFPLENBQUUsSUFBSSxlQUFlLENBQUMsRUFBRSxDQUFDLENBQ2hDLGNBQWMsQ0FBRSxJQUFJLHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxDQUNwRCxNQUFNLENBQUUsSUFBSSxjQUFjLENBQUMsRUFBRSxDQUFDLENBQzlCLFNBQVMsQ0FBRSxJQUFJLENBQ2YsR0FBRyxDQUFFLENBQUMsQ0FDTixLQUFLLENBQUUsQ0FBQyxDQUNSLE1BQU0sQ0FBRSxDQUFDLENBQ1QsSUFBSSxDQUFFLENBQUMsQ0FDUCxVQUFVLENBQUUsV0FBVyxDQUN2QixTQUFTLENBQUUsSUFBSSxXQUFXLENBQUMsS0FBSyxDQUNwQyxlQUVBLEtBQUssTUFBTSxDQUFDLENBQUcsOEJBQWdCLENBQUcsbUJBQU0sQ0FDcEMsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFDWixDQUVBLCtDQUFLLGFBQWMsQ0FDZixLQUFLLENBQUUsSUFBSSxtQkFBbUIsQ0FBQyxRQUFRLENBQUMsQ0FDeEMsT0FBTyxDQUFFLElBQUkscUJBQXFCLENBQUMsRUFBRSxDQUN6QyxDQUVBLCtDQUFLLE1BQU8sQ0FDUixPQUFPLENBQUUsSUFDYixDQUVBLGNBQWMsa0RBQVMsQ0FDbkIsTUFBTSxDQUFFLElBQUksZ0JBQWdCLENBQUMsa0JBQWtCLENBQUMsQ0FDaEQsYUFBYSxDQUFFLElBQUksdUJBQXVCLENBQUMsMEJBQTBCLENBQ3pFLENBRUEsbURBQVUsQ0FDTixVQUFVLENBQUUsSUFBSSxxQkFBcUIsQ0FBQyxRQUFRLENBQUMsQ0FDL0MsWUFBWSxDQUFFLElBQUksdUJBQXVCLENBQUMsUUFBUSxDQUFDLENBQ25ELEtBQUssQ0FBRSxJQUFJLGdCQUFnQixDQUFDLFFBQVEsQ0FDeEMsQ0FFQSx1QkFBUyxDQUFDLGlDQUFLLGFBQWMsQ0FDekIsS0FBSyxDQUFFLElBQUksNEJBQTRCLENBQUMsUUFBUSxDQUFDLENBQ2pELE9BQU8sQ0FBRSxJQUFJLDhCQUE4QixDQUFDLEVBQUUsQ0FDbEQsQ0FFQSx3REFBZSxDQUNYLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLFFBQVEsQ0FBRSxJQUFJLHdCQUF3QixDQUFDLE9BQU8sQ0FBQyxDQUMvQyxPQUFPLENBQUUsSUFBSSx1QkFBdUIsQ0FBQyxXQUFXLENBQUMsQ0FDakQsYUFBYSxDQUFFLFFBQVEsQ0FDdkIsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsS0FBSyxDQUFFLElBQUkscUJBQXFCLENBQUMsUUFBUSxDQUFDLENBQzFDLFNBQVMsQ0FBRSxJQUFJLFdBQVcsQ0FBQyxLQUFLLENBQ3BDLENBRUEsb0JBQU0sQ0FBQywwQ0FBZSxDQUNsQixRQUFRLENBQUUsUUFBUSxDQUNsQixXQUFXLENBQUUsSUFBSSxRQUFRLENBQUMsS0FBSyxDQUFDLENBQ2hDLE1BQU0sQ0FBRSxJQUFJLFFBQVEsQ0FBQyxLQUFLLENBQzlCLENBRUEsd0RBQWMsTUFBTyxDQUNqQixPQUFPLENBQUUsSUFDYixDQUVBLDZEQUFvQixDQUNoQixPQUFPLENBQUUsQ0FDYixDQUVBLCtDQUFNLENBQ0YsT0FBTyxDQUFFLElBQUksQ0FDYixXQUFXLENBQUUsTUFBTSxDQUNuQixlQUFlLENBQUUsTUFDckIsQ0FFQSx1REFBYyxDQUNWLEdBQUcsQ0FBRSxLQUFLLENBQ1YsT0FBTyxDQUFFLElBQUksQ0FDYixXQUFXLENBQUUsTUFBTSxDQUNuQixlQUFlLENBQUUsTUFBTSxDQUN2QixLQUFLLENBQUUsSUFBSSxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsQ0FDdEMsTUFBTSxDQUFFLElBQUkscUJBQXFCLENBQUMsS0FBSyxDQUFDLENBQ3hDLEtBQUssQ0FBRSxJQUFJLG9CQUFvQixDQUFDLG1CQUFtQixDQUFDLENBQ3BELE1BQU0sQ0FBRSxJQUFJLHFCQUFxQixDQUFDLEVBQUUsQ0FBQyxDQUNyQyxjQUFjLENBQUUsR0FBRyxDQUNuQixXQUFXLENBQUUsQ0FDakIsQ0FFQSx1REFBYSxNQUFPLENBQ2hCLE9BQU8sQ0FBRSxJQUFJLDRCQUE0QixDQUFDLGtCQUFrQixDQUNoRSxDQUVBLGtEQUFTLENBQ0wsS0FBSyxDQUFFLElBQUksZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUNqQyxNQUFNLENBQUUsSUFBSSxnQkFBZ0IsQ0FBQyxDQUM3QixLQUFLLENBQUUsSUFBSSxlQUFlLENBQUMsbUJBQW1CLENBQUMsQ0FDL0MsTUFBTSxDQUFFLElBQUksaUJBQWlCLENBQUMsRUFBRSxDQUFDLENBQ2pDLFdBQVcsQ0FBRSxDQUNqQixDQUVBLGtEQUFTLENBQ0wsS0FBSyxDQUFFLElBQUksZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUNqQyxNQUFNLENBQUUsSUFBSSxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FDbkMsVUFBVSxDQUFFLElBQUksb0JBQW9CLENBQUMsWUFBWSxDQUFDLENBQ2xELGNBQWMsQ0FBRSxJQUFJLHdCQUF3QixDQUFDLEtBQUssQ0FBQyxDQUNuRCxLQUFLLENBQUUsSUFBSSxlQUFlLENBQUMsbUJBQW1CLENBQUMsQ0FDL0MsTUFBTSxDQUFFLElBQUksZ0JBQWdCLENBQUMsd0JBQXdCLENBQUMsQ0FDdEQsV0FBVyxDQUFFLENBQ2pCLENBRUEsZ0RBQU8sQ0FDSCxPQUFPLENBQUUsSUFBSSxzQkFBc0IsQ0FBQyx3QkFBd0IsQ0FDaEUsQ0FFQSxvQkFBTSxDQUFDLGlDQUFNLENBQ1QsT0FBTyxDQUFFLElBQUksNEJBQTRCLENBQUMsRUFBRSxDQUFDLENBQzdDLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLE1BQU0sQ0FBRSxJQUFJLDJCQUEyQixDQUFDLE1BQU0sQ0FBQyxDQUMvQyxJQUFJLENBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUNkLENBRUEsY0FBYyxnREFBTyxDQUNqQixNQUFNLENBQUUsSUFBSSxjQUFjLENBQUMsa0JBQWtCLENBQUMsQ0FDOUMsVUFBVSxDQUFFLElBQUksa0JBQWtCLENBQUMsS0FBSyxDQUM1QyxDQUVBLG9EQUFXLENBQ1AsT0FBTyxDQUFFLElBQUksQ0FDYixNQUFNLENBQUUsR0FBRyxDQUNYLElBQUksQ0FBRSxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUM5QixNQUFNLENBQUUsR0FBRyxDQUNYLEtBQUssQ0FBRSxHQUFHLENBQ1YsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsUUFBUSxDQUFFLE1BQU0sQ0FDaEIsT0FBTyxDQUFFLEdBQUcsQ0FDWixXQUFXLENBQUUsTUFDakIsQ0FFQSxxREFBWSxDQUNSLFVBQVUsQ0FBRSxJQUFJLGVBQWUsQ0FBQyxRQUFRLENBQUMsQ0FDekMsTUFBTSxDQUFFLElBQUksbUJBQW1CLENBQUMsRUFBRSxDQUFDLENBQ25DLE9BQU8sQ0FBRSxJQUFJLG9CQUFvQixDQUFDLGVBQWUsQ0FBQyxDQUNsRCxhQUFhLENBQUUsSUFBSSwwQkFBMEIsQ0FBQyxJQUFJLENBQUMsQ0FDbkQsTUFBTSxDQUFFLElBQUksbUJBQW1CLENBQUMsS0FBSyxDQUFDLENBQ3RDLFdBQVcsQ0FBRSxJQUFJLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxDQUMzQyxPQUFPLENBQUUsSUFBSSxDQUNiLE1BQU0sQ0FBRSxPQUFPLENBQ2YsT0FBTyxDQUFFLElBQUksb0JBQW9CLENBQUMsTUFBTSxDQUFDLENBQ3pDLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLEdBQUcsQ0FBRSxJQUFJLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUMvQixjQUFjLENBQUUsSUFBSSxDQUNwQixTQUFTLENBQUUsSUFBSSxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsQ0FDdkMsS0FBSyxDQUFFLElBQUksa0JBQWtCLENBQUMsa0JBQWtCLENBQ3BELENBRUEsV0FBVyxtREFBUyxNQUFPLENBQ3ZCLFVBQVUsQ0FBRSxJQUFJLDhCQUE4QixDQUFDLFFBQVEsQ0FBQyxDQUN4RCxLQUFLLENBQUUsSUFBSSxpQ0FBaUMsQ0FBQyxRQUFRLENBQ3pELENBRUEsMERBQWlCLENBQ2IsUUFBUSxDQUFFLE1BQU0sQ0FDaEIsYUFBYSxDQUFFLFFBQVEsQ0FDdkIsV0FBVyxDQUFFLE1BQ2pCLENBRUEsMkRBQWtCLENBQ2QsT0FBTyxDQUFFLElBQUksQ0FDYixXQUFXLENBQUUsTUFBTSxDQUNuQixlQUFlLENBQUUsTUFBTSxDQUN2QixrQkFBa0IsQ0FBRSx3Q0FDeEIsQ0FFQSxXQUFXLGlEQUFRLENBQ2YsT0FBTyxDQUFFLElBQUksMkJBQTJCLENBQUMsa0JBQWtCLENBQy9ELENBRUEsNkRBQW9CLENBQ2hCLFVBQVUsQ0FBRSxJQUFJLGFBQWEsQ0FBQyxtQ0FBbUMsQ0FBQyxDQUNsRSxhQUFhLENBQUUsSUFBSSxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsQ0FDN0MsVUFBVSxDQUFFLElBQUksaUJBQWlCLENBQUMsTUFBTSxDQUFDLENBQ3pDLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLFVBQVUsQ0FBRSxJQUFJLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxDQUN4QyxRQUFRLENBQUUsSUFBSSxlQUFlLENBQUMsU0FBUyxDQUFDLENBQ3hDLE9BQU8sQ0FBRSxJQUFJLGNBQWMsQ0FBQyxFQUFFLENBQUMsQ0FDL0IsTUFBTSxDQUFFLElBQUksYUFBYSxDQUM3QixDQUVBLG1EQUFVLENBQ04sT0FBTyxDQUFFLENBQUMsQ0FDVixjQUFjLENBQUUsSUFDcEIsQ0FFQSwyREFBa0IsQ0FDZCxLQUFLLENBQUUsSUFBSSxtQkFBbUIsQ0FBQyxRQUFRLENBQUMsQ0FDeEMsTUFBTSxDQUFFLE9BQU8sQ0FDZixTQUFTLENBQUUsSUFBSSx1QkFBdUIsQ0FBQyxLQUFLLENBQUMsQ0FDN0MsV0FBVyxDQUFFLElBQUkseUJBQXlCLENBQUMsSUFBSSxDQUFDLENBQ2hELE1BQU0sQ0FBRSxJQUFJLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FDM0IsV0FBVyxDQUFFLElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUNoQyxPQUFPLENBQUUsSUFBSSxxQkFBcUIsQ0FBQyxPQUFPLENBQUMsQ0FDM0MsYUFBYSxDQUFFLFFBQVEsQ0FDdkIsVUFBVSxDQUFFLE1BQU0sQ0FDbEIsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsY0FBYyxDQUFFLElBQUksNEJBQTRCLENBQUMsVUFBVSxDQUMvRCxDQUVBLGdEQUFPLENBQ0gsVUFBVSxDQUFFLElBQUksdUJBQXVCLENBQUMsT0FBTyxDQUFDLENBQ2hELE9BQU8sQ0FBRSxJQUFJLG9CQUFvQixDQUFDLE9BQU8sQ0FBQyxDQUMxQyxLQUFLLENBQUUsSUFBSSxrQkFBa0IsQ0FBQyxRQUFRLENBQzFDLENBRUEsK0NBQU0sQ0FDRixNQUFNLENBQUUsT0FBTyxDQUNmLE1BQU0sQ0FBRSxJQUFJLGFBQWEsQ0FBQyxvQkFBb0IsQ0FBQyxDQUMvQyxXQUFXLENBQUUsSUFBSSxrQkFBa0IsQ0FBQyxvQkFBb0IsQ0FBQyxDQUN6RCxPQUFPLENBQUUsSUFBSSxjQUFjLENBQUMsT0FBTyxDQUFDLENBQ3BDLEtBQUssQ0FBRSxJQUFJLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FDakMsYUFBYSxDQUFFLFFBQVEsQ0FDdkIsUUFBUSxDQUFFLE1BQU0sQ0FDaEIsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsVUFBVSxDQUFFLElBQUksaUJBQWlCLENBQUMsU0FBUyxDQUFDLENBQzVDLFdBQVcsQ0FBRSxNQUFNLENBQ25CLEtBQUssQ0FBRSxJQUNYLENBRUEsS0FBSyxxREFBWSxDQUNiLFlBQVksQ0FBRSxJQUFJLHlCQUF5QixDQUFDLEtBQUssQ0FDckQsQ0FFQSwrQ0FBSyxPQUFRLENBQ1QsVUFBVSxDQUFFLElBQUksd0JBQXdCLENBQUMsUUFBUSxDQUNyRCxDQUVBLEtBQUssaURBQVEsQ0FDVCxVQUFVLENBQUUsSUFBSSxtQkFBbUIsQ0FBQyxRQUFRLENBQUMsQ0FDN0MsS0FBSyxDQUFFLElBQUksc0JBQXNCLENBQUMsS0FBSyxDQUMzQyxDQUVBLEtBQUssZ0RBQU8sQ0FDUixhQUFhLENBQUUsSUFBSSwwQkFBMEIsQ0FBQyxZQUFZLENBQzlELENBRUEsS0FBSyxnREFBTSxLQUFLLE9BQU8sQ0FBRSxDQUNyQixVQUFVLENBQUUsSUFBSSxlQUFlLENBQUMsUUFBUSxDQUFDLENBQ3pDLEtBQUssQ0FBRSxJQUFJLGtCQUFrQixDQUFDLFFBQVEsQ0FDMUMsQ0FFQSxLQUFLLHlEQUFlLENBQ3BCLEtBQUssTUFBTSxLQUFLLHlEQUFlLENBQy9CLEtBQUssT0FBTyxLQUFLLHlEQUFlLENBQ2hDLEtBQUsseURBQWUsT0FBUSxDQUN4QixLQUFLLENBQUUsSUFBSSw4QkFBOEIsQ0FBQyxLQUFLLENBQUMsQ0FDaEQsVUFBVSxDQUFFLFdBQ2hCLENBRUEsbURBQVUsQ0FDTixPQUFPLENBQUUsQ0FBQyxDQUNWLE9BQU8sQ0FBRSxFQUFFLENBQ1gsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsR0FBRyxDQUFFLENBQUMsQ0FDTixJQUFJLENBQUUsQ0FBQyxDQUNQLE1BQU0sQ0FBRSxDQUFDLENBQ1QsS0FBSyxDQUFFLENBQ1giLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiU2VsZWN0LnN2ZWx0ZSJdfQ== */");
}

const get_required_slot_changes = dirty => ({ value: dirty[0] & /*value*/ 8 });
const get_required_slot_context = ctx => ({ value: /*value*/ ctx[3] });
const get_chevron_icon_slot_changes = dirty => ({ listOpen: dirty[0] & /*listOpen*/ 64 });
const get_chevron_icon_slot_context = ctx => ({ listOpen: /*listOpen*/ ctx[6] });
const get_clear_icon_slot_changes = dirty => ({});
const get_clear_icon_slot_context = ctx => ({});
const get_loading_icon_slot_changes = dirty => ({});
const get_loading_icon_slot_context = ctx => ({});
const get_selection_slot_changes_1 = dirty => ({ selection: dirty[0] & /*value*/ 8 });
const get_selection_slot_context_1 = ctx => ({ selection: /*value*/ ctx[3] });

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[127] = list[i];
	child_ctx[129] = i;
	return child_ctx;
}

const get_multi_clear_icon_slot_changes = dirty => ({});
const get_multi_clear_icon_slot_context = ctx => ({});
const get_selection_slot_changes = dirty => ({ selection: dirty[0] & /*value*/ 8 });

const get_selection_slot_context = ctx => ({
	selection: /*item*/ ctx[127],
	index: /*i*/ ctx[129]
});

const get_prepend_slot_changes = dirty => ({});
const get_prepend_slot_context = ctx => ({});
const get_empty_slot_changes = dirty => ({});
const get_empty_slot_context = ctx => ({});

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[127] = list[i];
	child_ctx[129] = i;
	return child_ctx;
}

const get_item_slot_changes = dirty => ({
	item: dirty[0] & /*filteredItems*/ 16777216
});

const get_item_slot_context = ctx => ({
	item: /*item*/ ctx[127],
	index: /*i*/ ctx[129]
});

const get_list_slot_changes = dirty => ({
	filteredItems: dirty[0] & /*filteredItems*/ 16777216
});

const get_list_slot_context = ctx => ({ filteredItems: /*filteredItems*/ ctx[24] });

// (688:4) {#if listOpen}
function create_if_block_8(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let floatingContent_action;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_9, create_if_block_10, create_if_block_11];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*$$slots*/ ctx[51].list) return 0;
		if (/*filteredItems*/ ctx[24].length > 0) return 1;
		if (!/*hideEmptyState*/ ctx[19]) return 2;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx, [-1, -1, -1, -1, -1]))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			if (if_block) if_block.c();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div, "class", "svelte-select-list svelte-apvs86");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div, "prefloat", /*prefloat*/ ctx[28]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div, file, 688, 8, 21034);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(div, null);
			}

			/*div_binding*/ ctx[91](div);
			current = true;

			if (!mounted) {
				dispose = [
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.action_destroyer)(floatingContent_action = /*floatingContent*/ ctx[49].call(null, div)),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(div, "scroll", /*handleListScroll*/ ctx[41], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(div, "pointerdown", (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.prevent_default)(/*handlePointerDown*/ ctx[50]), false, true, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(div, "pointerup", (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.stop_propagation)((0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.prevent_default)(/*pointerup_handler*/ ctx[86])), false, true, true, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
					if_block.m(div, null);
				} else {
					if_block = null;
				}
			}

			if (!current || dirty[0] & /*prefloat*/ 268435456) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div, "prefloat", /*prefloat*/ ctx[28]);
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			/*div_binding*/ ctx[91](null);
			mounted = false;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.run_all)(dispose);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block_8.name,
		type: "if",
		source: "(688:4) {#if listOpen}",
		ctx
	});

	return block;
}

// (723:38) 
function create_if_block_11(ctx) {
	let current;
	const empty_slot_template = /*#slots*/ ctx[83].empty;
	const empty_slot = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_slot)(empty_slot_template, ctx, /*$$scope*/ ctx[82], get_empty_slot_context);
	const empty_slot_or_fallback = empty_slot || fallback_block_8(ctx);

	const block = {
		c: function create() {
			if (empty_slot_or_fallback) empty_slot_or_fallback.c();
		},
		m: function mount(target, anchor) {
			if (empty_slot_or_fallback) {
				empty_slot_or_fallback.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (empty_slot) {
				if (empty_slot.p && (!current || dirty[2] & /*$$scope*/ 1048576)) {
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_slot_base)(
						empty_slot,
						empty_slot_template,
						ctx,
						/*$$scope*/ ctx[82],
						!current
						? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_all_dirty_from_scope)(/*$$scope*/ ctx[82])
						: (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_slot_changes)(empty_slot_template, /*$$scope*/ ctx[82], dirty, get_empty_slot_changes),
						get_empty_slot_context
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(empty_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(empty_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (empty_slot_or_fallback) empty_slot_or_fallback.d(detaching);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block_11.name,
		type: "if",
		source: "(723:38) ",
		ctx
	});

	return block;
}

// (698:47) 
function create_if_block_10(ctx) {
	let each_1_anchor;
	let current;
	let each_value_1 = /*filteredItems*/ ctx[24];
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const out = i => (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*filteredItems, value, itemId, listDom, scrollToHoverItem, hoverItemIndex, label*/ 1627402376 | dirty[1] & /*handleHover, handleItemClick, isItemActive*/ 28672 | dirty[2] & /*$$scope*/ 1048576) {
				each_value_1 = /*filteredItems*/ ctx[24];
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_each)(each_blocks, detaching);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(each_1_anchor);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block_10.name,
		type: "if",
		source: "(698:47) ",
		ctx
	});

	return block;
}

// (697:12) {#if $$slots.list}
function create_if_block_9(ctx) {
	let current;
	const list_slot_template = /*#slots*/ ctx[83].list;
	const list_slot = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_slot)(list_slot_template, ctx, /*$$scope*/ ctx[82], get_list_slot_context);

	const block = {
		c: function create() {
			if (list_slot) list_slot.c();
		},
		m: function mount(target, anchor) {
			if (list_slot) {
				list_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (list_slot) {
				if (list_slot.p && (!current || dirty[0] & /*filteredItems*/ 16777216 | dirty[2] & /*$$scope*/ 1048576)) {
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_slot_base)(
						list_slot,
						list_slot_template,
						ctx,
						/*$$scope*/ ctx[82],
						!current
						? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_all_dirty_from_scope)(/*$$scope*/ ctx[82])
						: (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_slot_changes)(list_slot_template, /*$$scope*/ ctx[82], dirty, get_list_slot_changes),
						get_list_slot_context
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(list_slot, local);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(list_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (list_slot) list_slot.d(detaching);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block_9.name,
		type: "if",
		source: "(697:12) {#if $$slots.list}",
		ctx
	});

	return block;
}

// (724:35)                      
function fallback_block_8(ctx) {
	let div;

	const block = {
		c: function create() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div.textContent = "No options";
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div, "class", "empty svelte-apvs86");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div, file, 724, 20, 22860);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div, anchor);
		},
		p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: fallback_block_8.name,
		type: "fallback",
		source: "(724:35)                      ",
		ctx
	});

	return block;
}

// (717:63)                                  
function fallback_block_7(ctx) {
	let t_value = /*item*/ ctx[127]?.[/*label*/ ctx[12]] + "";
	let t;

	const block = {
		c: function create() {
			t = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t_value);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*filteredItems, label*/ 16781312 && t_value !== (t_value = /*item*/ ctx[127]?.[/*label*/ ctx[12]] + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(t);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: fallback_block_7.name,
		type: "fallback",
		source: "(717:63)                                  ",
		ctx
	});

	return block;
}

// (699:16) {#each filteredItems as item, i}
function create_each_block_1(ctx) {
	let div1;
	let div0;
	let activeScroll_action;
	let hoverScroll_action;
	let t;
	let current;
	let mounted;
	let dispose;
	const item_slot_template = /*#slots*/ ctx[83].item;
	const item_slot = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_slot)(item_slot_template, ctx, /*$$scope*/ ctx[82], get_item_slot_context);
	const item_slot_or_fallback = item_slot || fallback_block_7(ctx);

	function mouseover_handler() {
		return /*mouseover_handler*/ ctx[88](/*i*/ ctx[129]);
	}

	function focus_handler() {
		return /*focus_handler*/ ctx[89](/*i*/ ctx[129]);
	}

	function click_handler() {
		return /*click_handler*/ ctx[90](/*item*/ ctx[127], /*i*/ ctx[129]);
	}

	const block = {
		c: function create() {
			div1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			if (item_slot_or_fallback) item_slot_or_fallback.c();
			t = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div0, "class", "item svelte-apvs86");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "list-group-title", /*item*/ ctx[127].groupHeader);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "active", /*isItemActive*/ ctx[45](/*item*/ ctx[127], /*value*/ ctx[3], /*itemId*/ ctx[13]));
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "first", isItemFirst(/*i*/ ctx[129]));
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "hover", /*hoverItemIndex*/ ctx[7] === /*i*/ ctx[129]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "group-item", /*item*/ ctx[127].groupItem);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "not-selectable", /*item*/ ctx[127]?.selectable === false);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div0, file, 706, 24, 21888);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div1, "class", "list-item svelte-apvs86");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div1, "tabindex", "-1");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div1, file, 699, 20, 21510);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div1, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, div0);

			if (item_slot_or_fallback) {
				item_slot_or_fallback.m(div0, null);
			}

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, t);
			current = true;

			if (!mounted) {
				dispose = [
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.action_destroyer)(activeScroll_action = /*activeScroll*/ ctx[46].call(null, div0, {
						scroll: /*isItemActive*/ ctx[45](/*item*/ ctx[127], /*value*/ ctx[3], /*itemId*/ ctx[13]),
						listDom: /*listDom*/ ctx[30]
					})),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.action_destroyer)(hoverScroll_action = /*hoverScroll*/ ctx[47].call(null, div0, {
						scroll: /*scrollToHoverItem*/ ctx[29] === /*i*/ ctx[129],
						listDom: /*listDom*/ ctx[30]
					})),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(div1, "mouseover", mouseover_handler, false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(div1, "focus", focus_handler, false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(div1, "click", (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.stop_propagation)(click_handler), false, false, true, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(div1, "keydown", (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.stop_propagation)((0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.prevent_default)(/*keydown_handler*/ ctx[87])), false, true, true, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (item_slot) {
				if (item_slot.p && (!current || dirty[0] & /*filteredItems*/ 16777216 | dirty[2] & /*$$scope*/ 1048576)) {
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_slot_base)(
						item_slot,
						item_slot_template,
						ctx,
						/*$$scope*/ ctx[82],
						!current
						? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_all_dirty_from_scope)(/*$$scope*/ ctx[82])
						: (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_slot_changes)(item_slot_template, /*$$scope*/ ctx[82], dirty, get_item_slot_changes),
						get_item_slot_context
					);
				}
			} else {
				if (item_slot_or_fallback && item_slot_or_fallback.p && (!current || dirty[0] & /*filteredItems, label*/ 16781312)) {
					item_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1, -1] : dirty);
				}
			}

			if (activeScroll_action && (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.is_function)(activeScroll_action.update) && dirty[0] & /*filteredItems, value, itemId, listDom*/ 1090527240) activeScroll_action.update.call(null, {
				scroll: /*isItemActive*/ ctx[45](/*item*/ ctx[127], /*value*/ ctx[3], /*itemId*/ ctx[13]),
				listDom: /*listDom*/ ctx[30]
			});

			if (hoverScroll_action && (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.is_function)(hoverScroll_action.update) && dirty[0] & /*scrollToHoverItem, listDom*/ 1610612736) hoverScroll_action.update.call(null, {
				scroll: /*scrollToHoverItem*/ ctx[29] === /*i*/ ctx[129],
				listDom: /*listDom*/ ctx[30]
			});

			if (!current || dirty[0] & /*filteredItems*/ 16777216) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "list-group-title", /*item*/ ctx[127].groupHeader);
			}

			if (!current || dirty[0] & /*filteredItems, value, itemId*/ 16785416 | dirty[1] & /*isItemActive*/ 16384) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "active", /*isItemActive*/ ctx[45](/*item*/ ctx[127], /*value*/ ctx[3], /*itemId*/ ctx[13]));
			}

			if (!current || dirty[0] & /*hoverItemIndex*/ 128) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "hover", /*hoverItemIndex*/ ctx[7] === /*i*/ ctx[129]);
			}

			if (!current || dirty[0] & /*filteredItems*/ 16777216) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "group-item", /*item*/ ctx[127].groupItem);
			}

			if (!current || dirty[0] & /*filteredItems*/ 16777216) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div0, "not-selectable", /*item*/ ctx[127]?.selectable === false);
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(item_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(item_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div1);
			if (item_slot_or_fallback) item_slot_or_fallback.d(detaching);
			mounted = false;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.run_all)(dispose);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(699:16) {#each filteredItems as item, i}",
		ctx
	});

	return block;
}

// (732:8) {#if focused}
function create_if_block_7(ctx) {
	let span0;
	let t0;
	let t1;
	let span1;
	let t2;

	const block = {
		c: function create() {
			span0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(/*ariaSelection*/ ctx[32]);
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			span1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");
			t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(/*ariaContext*/ ctx[31]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(span0, "id", "aria-selection");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(span0, "class", "svelte-apvs86");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(span0, file, 732, 12, 23097);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(span1, "id", "aria-context");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(span1, "class", "svelte-apvs86");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(span1, file, 733, 12, 23158);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, span0, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(span0, t0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, t1, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, span1, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(span1, t2);
		},
		p: function update(ctx, dirty) {
			if (dirty[1] & /*ariaSelection*/ 2) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t0, /*ariaSelection*/ ctx[32]);
			if (dirty[1] & /*ariaContext*/ 1) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t2, /*ariaContext*/ ctx[31]);
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(span0);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(t1);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(span1);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block_7.name,
		type: "if",
		source: "(732:8) {#if focused}",
		ctx
	});

	return block;
}

// (745:8) {#if hasValue}
function create_if_block_4(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_5, create_else_block];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*multiple*/ ctx[9]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx, [-1, -1, -1, -1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(if_block_anchor);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(745:8) {#if hasValue}",
		ctx
	});

	return block;
}

// (771:12) {:else}
function create_else_block(ctx) {
	let div;
	let current;
	const selection_slot_template = /*#slots*/ ctx[83].selection;
	const selection_slot = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_slot)(selection_slot_template, ctx, /*$$scope*/ ctx[82], get_selection_slot_context_1);
	const selection_slot_or_fallback = selection_slot || fallback_block_6(ctx);

	const block = {
		c: function create() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			if (selection_slot_or_fallback) selection_slot_or_fallback.c();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div, "class", "selected-item svelte-apvs86");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div, "hide-selected-item", /*hideSelectedItem*/ ctx[35]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div, file, 771, 16, 24631);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div, anchor);

			if (selection_slot_or_fallback) {
				selection_slot_or_fallback.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (selection_slot) {
				if (selection_slot.p && (!current || dirty[0] & /*value*/ 8 | dirty[2] & /*$$scope*/ 1048576)) {
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_slot_base)(
						selection_slot,
						selection_slot_template,
						ctx,
						/*$$scope*/ ctx[82],
						!current
						? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_all_dirty_from_scope)(/*$$scope*/ ctx[82])
						: (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_slot_changes)(selection_slot_template, /*$$scope*/ ctx[82], dirty, get_selection_slot_changes_1),
						get_selection_slot_context_1
					);
				}
			} else {
				if (selection_slot_or_fallback && selection_slot_or_fallback.p && (!current || dirty[0] & /*value, label*/ 4104)) {
					selection_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1, -1] : dirty);
				}
			}

			if (!current || dirty[1] & /*hideSelectedItem*/ 16) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div, "hide-selected-item", /*hideSelectedItem*/ ctx[35]);
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(selection_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(selection_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div);
			if (selection_slot_or_fallback) selection_slot_or_fallback.d(detaching);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(771:12) {:else}",
		ctx
	});

	return block;
}

// (746:12) {#if multiple}
function create_if_block_5(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*value*/ ctx[3];
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*activeValue, disabled, multiFullItemClearable, value, label*/ 67116040 | dirty[1] & /*handleMultiItemClear*/ 32 | dirty[2] & /*$$scope*/ 1048576) {
				each_value = /*value*/ ctx[3];
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_each)(each_blocks, detaching);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(each_1_anchor);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(746:12) {#if multiple}",
		ctx
	});

	return block;
}

// (773:61)                          
function fallback_block_6(ctx) {
	let t_value = /*value*/ ctx[3][/*label*/ ctx[12]] + "";
	let t;

	const block = {
		c: function create() {
			t = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t_value);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*value, label*/ 4104 && t_value !== (t_value = /*value*/ ctx[3][/*label*/ ctx[12]] + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(t);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: fallback_block_6.name,
		type: "fallback",
		source: "(773:61)                          ",
		ctx
	});

	return block;
}

// (755:78)                                  
function fallback_block_5(ctx) {
	let t_value = /*item*/ ctx[127][/*label*/ ctx[12]] + "";
	let t;

	const block = {
		c: function create() {
			t = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t_value);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*value, label*/ 4104 && t_value !== (t_value = /*item*/ ctx[127][/*label*/ ctx[12]] + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(t);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: fallback_block_5.name,
		type: "fallback",
		source: "(755:78)                                  ",
		ctx
	});

	return block;
}

// (760:24) {#if !disabled && !multiFullItemClearable && ClearIcon}
function create_if_block_6(ctx) {
	let div;
	let current;
	let mounted;
	let dispose;
	const multi_clear_icon_slot_template = /*#slots*/ ctx[83]["multi-clear-icon"];
	const multi_clear_icon_slot = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_slot)(multi_clear_icon_slot_template, ctx, /*$$scope*/ ctx[82], get_multi_clear_icon_slot_context);
	const multi_clear_icon_slot_or_fallback = multi_clear_icon_slot || fallback_block_4(ctx);

	function pointerup_handler_1() {
		return /*pointerup_handler_1*/ ctx[92](/*i*/ ctx[129]);
	}

	const block = {
		c: function create() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			if (multi_clear_icon_slot_or_fallback) multi_clear_icon_slot_or_fallback.c();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div, "class", "multi-item-clear svelte-apvs86");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div, file, 760, 28, 24155);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div, anchor);

			if (multi_clear_icon_slot_or_fallback) {
				multi_clear_icon_slot_or_fallback.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(div, "pointerup", (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.stop_propagation)((0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.prevent_default)(pointerup_handler_1)), false, true, true, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (multi_clear_icon_slot) {
				if (multi_clear_icon_slot.p && (!current || dirty[2] & /*$$scope*/ 1048576)) {
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_slot_base)(
						multi_clear_icon_slot,
						multi_clear_icon_slot_template,
						ctx,
						/*$$scope*/ ctx[82],
						!current
						? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_all_dirty_from_scope)(/*$$scope*/ ctx[82])
						: (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_slot_changes)(multi_clear_icon_slot_template, /*$$scope*/ ctx[82], dirty, get_multi_clear_icon_slot_changes),
						get_multi_clear_icon_slot_context
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(multi_clear_icon_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(multi_clear_icon_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div);
			if (multi_clear_icon_slot_or_fallback) multi_clear_icon_slot_or_fallback.d(detaching);
			mounted = false;
			dispose();
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(760:24) {#if !disabled && !multiFullItemClearable && ClearIcon}",
		ctx
	});

	return block;
}

// (764:62)                                      
function fallback_block_4(ctx) {
	let clearicon;
	let current;
	clearicon = new _ClearIcon_svelte__WEBPACK_IMPORTED_MODULE_6__["default"]({ $$inline: true });

	const block = {
		c: function create() {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(clearicon.$$.fragment);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(clearicon, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(clearicon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(clearicon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(clearicon, detaching);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: fallback_block_4.name,
		type: "fallback",
		source: "(764:62)                                      ",
		ctx
	});

	return block;
}

// (747:16) {#each value as item, i}
function create_each_block(ctx) {
	let div;
	let span;
	let t0;
	let t1;
	let current;
	let mounted;
	let dispose;
	const selection_slot_template = /*#slots*/ ctx[83].selection;
	const selection_slot = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_slot)(selection_slot_template, ctx, /*$$scope*/ ctx[82], get_selection_slot_context);
	const selection_slot_or_fallback = selection_slot || fallback_block_5(ctx);
	let if_block = !/*disabled*/ ctx[11] && !/*multiFullItemClearable*/ ctx[10] && _ClearIcon_svelte__WEBPACK_IMPORTED_MODULE_6__["default"] && create_if_block_6(ctx);

	function click_handler_1() {
		return /*click_handler_1*/ ctx[93](/*i*/ ctx[129]);
	}

	const block = {
		c: function create() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			span = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");
			if (selection_slot_or_fallback) selection_slot_or_fallback.c();
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			if (if_block) if_block.c();
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(span, "class", "multi-item-text svelte-apvs86");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(span, file, 753, 24, 23822);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div, "class", "multi-item svelte-apvs86");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div, "active", /*activeValue*/ ctx[26] === /*i*/ ctx[129]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div, "disabled", /*disabled*/ ctx[11]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div, file, 747, 20, 23475);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div, span);

			if (selection_slot_or_fallback) {
				selection_slot_or_fallback.m(span, null);
			}

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div, t0);
			if (if_block) if_block.m(div, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div, t1);
			current = true;

			if (!mounted) {
				dispose = [
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(div, "click", (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.prevent_default)(click_handler_1), false, true, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(div, "keydown", (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.stop_propagation)((0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.prevent_default)(/*keydown_handler_1*/ ctx[85])), false, true, true, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (selection_slot) {
				if (selection_slot.p && (!current || dirty[0] & /*value*/ 8 | dirty[2] & /*$$scope*/ 1048576)) {
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_slot_base)(
						selection_slot,
						selection_slot_template,
						ctx,
						/*$$scope*/ ctx[82],
						!current
						? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_all_dirty_from_scope)(/*$$scope*/ ctx[82])
						: (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_slot_changes)(selection_slot_template, /*$$scope*/ ctx[82], dirty, get_selection_slot_changes),
						get_selection_slot_context
					);
				}
			} else {
				if (selection_slot_or_fallback && selection_slot_or_fallback.p && (!current || dirty[0] & /*value, label*/ 4104)) {
					selection_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1, -1] : dirty);
				}
			}

			if (!/*disabled*/ ctx[11] && !/*multiFullItemClearable*/ ctx[10] && _ClearIcon_svelte__WEBPACK_IMPORTED_MODULE_6__["default"]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*disabled, multiFullItemClearable*/ 3072) {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
					}
				} else {
					if_block = create_if_block_6(ctx);
					if_block.c();
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
					if_block.m(div, t1);
				}
			} else if (if_block) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block, 1, 1, () => {
					if_block = null;
				});

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
			}

			if (!current || dirty[0] & /*activeValue*/ 67108864) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div, "active", /*activeValue*/ ctx[26] === /*i*/ ctx[129]);
			}

			if (!current || dirty[0] & /*disabled*/ 2048) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div, "disabled", /*disabled*/ ctx[11]);
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(selection_slot_or_fallback, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(selection_slot_or_fallback, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div);
			if (selection_slot_or_fallback) selection_slot_or_fallback.d(detaching);
			if (if_block) if_block.d();
			mounted = false;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.run_all)(dispose);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(747:16) {#each value as item, i}",
		ctx
	});

	return block;
}

// (794:8) {#if loading}
function create_if_block_3(ctx) {
	let div;
	let current;
	const loading_icon_slot_template = /*#slots*/ ctx[83]["loading-icon"];
	const loading_icon_slot = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_slot)(loading_icon_slot_template, ctx, /*$$scope*/ ctx[82], get_loading_icon_slot_context);
	const loading_icon_slot_or_fallback = loading_icon_slot || fallback_block_3(ctx);

	const block = {
		c: function create() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			if (loading_icon_slot_or_fallback) loading_icon_slot_or_fallback.c();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div, "class", "icon loading svelte-apvs86");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div, "aria-hidden", "true");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div, file, 794, 12, 25320);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div, anchor);

			if (loading_icon_slot_or_fallback) {
				loading_icon_slot_or_fallback.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (loading_icon_slot) {
				if (loading_icon_slot.p && (!current || dirty[2] & /*$$scope*/ 1048576)) {
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_slot_base)(
						loading_icon_slot,
						loading_icon_slot_template,
						ctx,
						/*$$scope*/ ctx[82],
						!current
						? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_all_dirty_from_scope)(/*$$scope*/ ctx[82])
						: (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_slot_changes)(loading_icon_slot_template, /*$$scope*/ ctx[82], dirty, get_loading_icon_slot_changes),
						get_loading_icon_slot_context
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(loading_icon_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(loading_icon_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div);
			if (loading_icon_slot_or_fallback) loading_icon_slot_or_fallback.d(detaching);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(794:8) {#if loading}",
		ctx
	});

	return block;
}

// (796:42)                      
function fallback_block_3(ctx) {
	let loadingicon;
	let current;
	loadingicon = new _LoadingIcon_svelte__WEBPACK_IMPORTED_MODULE_7__["default"]({ $$inline: true });

	const block = {
		c: function create() {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(loadingicon.$$.fragment);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(loadingicon, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(loadingicon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(loadingicon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(loadingicon, detaching);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: fallback_block_3.name,
		type: "fallback",
		source: "(796:42)                      ",
		ctx
	});

	return block;
}

// (802:8) {#if showClear}
function create_if_block_2(ctx) {
	let button;
	let current;
	let mounted;
	let dispose;
	const clear_icon_slot_template = /*#slots*/ ctx[83]["clear-icon"];
	const clear_icon_slot = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_slot)(clear_icon_slot_template, ctx, /*$$scope*/ ctx[82], get_clear_icon_slot_context);
	const clear_icon_slot_or_fallback = clear_icon_slot || fallback_block_2(ctx);

	const block = {
		c: function create() {
			button = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			if (clear_icon_slot_or_fallback) clear_icon_slot_or_fallback.c();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button, "class", "icon clear-select svelte-apvs86");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button, file, 802, 12, 25539);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, button, anchor);

			if (clear_icon_slot_or_fallback) {
				clear_icon_slot_or_fallback.m(button, null);
			}

			current = true;

			if (!mounted) {
				dispose = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button, "pointerup", (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.stop_propagation)((0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.prevent_default)(/*handleClear*/ ctx[22])), false, true, true, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (clear_icon_slot) {
				if (clear_icon_slot.p && (!current || dirty[2] & /*$$scope*/ 1048576)) {
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_slot_base)(
						clear_icon_slot,
						clear_icon_slot_template,
						ctx,
						/*$$scope*/ ctx[82],
						!current
						? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_all_dirty_from_scope)(/*$$scope*/ ctx[82])
						: (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_slot_changes)(clear_icon_slot_template, /*$$scope*/ ctx[82], dirty, get_clear_icon_slot_changes),
						get_clear_icon_slot_context
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(clear_icon_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(clear_icon_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(button);
			if (clear_icon_slot_or_fallback) clear_icon_slot_or_fallback.d(detaching);
			mounted = false;
			dispose();
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(802:8) {#if showClear}",
		ctx
	});

	return block;
}

// (804:40)                      
function fallback_block_2(ctx) {
	let clearicon;
	let current;
	clearicon = new _ClearIcon_svelte__WEBPACK_IMPORTED_MODULE_6__["default"]({ $$inline: true });

	const block = {
		c: function create() {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(clearicon.$$.fragment);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(clearicon, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(clearicon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(clearicon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(clearicon, detaching);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: fallback_block_2.name,
		type: "fallback",
		source: "(804:40)                      ",
		ctx
	});

	return block;
}

// (810:8) {#if showChevron}
function create_if_block_1(ctx) {
	let div;
	let current;
	const chevron_icon_slot_template = /*#slots*/ ctx[83]["chevron-icon"];
	const chevron_icon_slot = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_slot)(chevron_icon_slot_template, ctx, /*$$scope*/ ctx[82], get_chevron_icon_slot_context);
	const chevron_icon_slot_or_fallback = chevron_icon_slot || fallback_block_1(ctx);

	const block = {
		c: function create() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			if (chevron_icon_slot_or_fallback) chevron_icon_slot_or_fallback.c();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div, "class", "icon chevron svelte-apvs86");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div, "aria-hidden", "true");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div, file, 810, 12, 25806);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div, anchor);

			if (chevron_icon_slot_or_fallback) {
				chevron_icon_slot_or_fallback.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (chevron_icon_slot) {
				if (chevron_icon_slot.p && (!current || dirty[0] & /*listOpen*/ 64 | dirty[2] & /*$$scope*/ 1048576)) {
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_slot_base)(
						chevron_icon_slot,
						chevron_icon_slot_template,
						ctx,
						/*$$scope*/ ctx[82],
						!current
						? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_all_dirty_from_scope)(/*$$scope*/ ctx[82])
						: (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_slot_changes)(chevron_icon_slot_template, /*$$scope*/ ctx[82], dirty, get_chevron_icon_slot_changes),
						get_chevron_icon_slot_context
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(chevron_icon_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(chevron_icon_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div);
			if (chevron_icon_slot_or_fallback) chevron_icon_slot_or_fallback.d(detaching);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(810:8) {#if showChevron}",
		ctx
	});

	return block;
}

// (812:53)                      
function fallback_block_1(ctx) {
	let chevronicon;
	let current;
	chevronicon = new _ChevronIcon_svelte__WEBPACK_IMPORTED_MODULE_5__["default"]({ $$inline: true });

	const block = {
		c: function create() {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(chevronicon.$$.fragment);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(chevronicon, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(chevronicon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(chevronicon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(chevronicon, detaching);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: fallback_block_1.name,
		type: "fallback",
		source: "(812:53)                      ",
		ctx
	});

	return block;
}

// (821:4) {#if required && (!value || value.length === 0)}
function create_if_block(ctx) {
	let current;
	const required_slot_template = /*#slots*/ ctx[83].required;
	const required_slot = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_slot)(required_slot_template, ctx, /*$$scope*/ ctx[82], get_required_slot_context);
	const required_slot_or_fallback = required_slot || fallback_block(ctx);

	const block = {
		c: function create() {
			if (required_slot_or_fallback) required_slot_or_fallback.c();
		},
		m: function mount(target, anchor) {
			if (required_slot_or_fallback) {
				required_slot_or_fallback.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (required_slot) {
				if (required_slot.p && (!current || dirty[0] & /*value*/ 8 | dirty[2] & /*$$scope*/ 1048576)) {
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_slot_base)(
						required_slot,
						required_slot_template,
						ctx,
						/*$$scope*/ ctx[82],
						!current
						? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_all_dirty_from_scope)(/*$$scope*/ ctx[82])
						: (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_slot_changes)(required_slot_template, /*$$scope*/ ctx[82], dirty, get_required_slot_changes),
						get_required_slot_context
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(required_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(required_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (required_slot_or_fallback) required_slot_or_fallback.d(detaching);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(821:4) {#if required && (!value || value.length === 0)}",
		ctx
	});

	return block;
}

// (822:38)              
function fallback_block(ctx) {
	let select;

	const block = {
		c: function create() {
			select = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("select");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(select, "class", "required svelte-apvs86");
			select.required = true;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(select, file, 822, 12, 26196);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, select, anchor);
		},
		p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(select);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: fallback_block.name,
		type: "fallback",
		source: "(822:38)              ",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div3;
	let t0;
	let span;
	let t1;
	let div0;
	let t2;
	let div1;
	let t3;
	let input0;
	let input0_readonly_value;
	let t4;
	let div2;
	let t5;
	let t6;
	let t7;
	let input1;
	let input1_value_value;
	let t8;
	let div3_class_value;
	let floatingRef_action;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*listOpen*/ ctx[6] && create_if_block_8(ctx);
	let if_block1 = /*focused*/ ctx[2] && create_if_block_7(ctx);
	const prepend_slot_template = /*#slots*/ ctx[83].prepend;
	const prepend_slot = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_slot)(prepend_slot_template, ctx, /*$$scope*/ ctx[82], get_prepend_slot_context);
	let if_block2 = /*hasValue*/ ctx[25] && create_if_block_4(ctx);

	let input0_levels = [
		{
			readOnly: input0_readonly_value = !/*searchable*/ ctx[17]
		},
		/*_inputAttributes*/ ctx[27],
		{ placeholder: /*placeholderText*/ ctx[33] },
		{ style: /*inputStyles*/ ctx[18] },
		{ disabled: /*disabled*/ ctx[11] }
	];

	let input_data_1 = {};

	for (let i = 0; i < input0_levels.length; i += 1) {
		input_data_1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.assign)(input_data_1, input0_levels[i]);
	}

	let if_block3 = /*loading*/ ctx[5] && create_if_block_3(ctx);
	let if_block4 = /*showClear*/ ctx[34] && create_if_block_2(ctx);
	let if_block5 = /*showChevron*/ ctx[20] && create_if_block_1(ctx);
	let if_block6 = /*required*/ ctx[16] && (!/*value*/ ctx[3] || /*value*/ ctx[3].length === 0) && create_if_block(ctx);

	const block = {
		c: function create() {
			div3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			if (if_block0) if_block0.c();
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			span = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");
			if (if_block1) if_block1.c();
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			if (prepend_slot) prepend_slot.c();
			t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			if (if_block2) if_block2.c();
			t3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			input0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("input");
			t4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			if (if_block3) if_block3.c();
			t5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			if (if_block4) if_block4.c();
			t6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			if (if_block5) if_block5.c();
			t7 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			input1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("input");
			t8 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			if (if_block6) if_block6.c();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(span, "aria-live", "polite");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(span, "aria-atomic", "false");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(span, "aria-relevant", "additions text");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(span, "class", "a11y-text svelte-apvs86");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(span, file, 730, 4, 22968);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div0, "class", "prepend svelte-apvs86");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div0, file, 739, 4, 23264);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_attributes)(input0, input_data_1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(input0, "svelte-apvs86", true);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(input0, file, 779, 8, 24896);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div1, "class", "value-container svelte-apvs86");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div1, file, 743, 4, 23334);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div2, "class", "indicators svelte-apvs86");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div2, file, 792, 4, 25261);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(input1, "name", /*name*/ ctx[8]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(input1, "type", "hidden");

			input1.value = input1_value_value = /*value*/ ctx[3]
			? JSON.stringify(/*value*/ ctx[3])
			: null;

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(input1, "class", "svelte-apvs86");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(input1, file, 818, 4, 26015);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div3, "class", div3_class_value = "svelte-select " + /*containerClasses*/ ctx[21] + " svelte-apvs86");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div3, "style", /*containerStyles*/ ctx[14]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div3, "multi", /*multiple*/ ctx[9]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div3, "disabled", /*disabled*/ ctx[11]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div3, "focused", /*focused*/ ctx[2]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div3, "list-open", /*listOpen*/ ctx[6]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div3, "show-chevron", /*showChevron*/ ctx[20]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div3, "error", /*hasError*/ ctx[15]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div3, file, 674, 0, 20645);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div3, anchor);
			if (if_block0) if_block0.m(div3, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, t0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, span);
			if (if_block1) if_block1.m(span, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, t1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, div0);

			if (prepend_slot) {
				prepend_slot.m(div0, null);
			}

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, t2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, div1);
			if (if_block2) if_block2.m(div1, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, t3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, input0);
			if (input0.autofocus) input0.focus();
			/*input0_binding*/ ctx[94](input0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_input_value)(input0, /*filterText*/ ctx[4]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, t4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, div2);
			if (if_block3) if_block3.m(div2, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, t5);
			if (if_block4) if_block4.m(div2, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, t6);
			if (if_block5) if_block5.m(div2, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, t7);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, input1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, t8);
			if (if_block6) if_block6.m(div3, null);
			/*div3_binding*/ ctx[96](div3);
			current = true;

			if (!mounted) {
				dispose = [
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(window, "click", /*handleClickOutside*/ ctx[42], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(window, "keydown", /*handleKeyDown*/ ctx[37], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(input0, "keydown", /*handleKeyDown*/ ctx[37], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(input0, "blur", /*handleBlur*/ ctx[39], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(input0, "focus", /*handleFocus*/ ctx[38], false, false, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(input0, "input", /*input0_input_handler*/ ctx[95]),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(div3, "pointerup", (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.prevent_default)(/*handleClick*/ ctx[40]), false, true, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(div3, "mousedown", (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.prevent_default)(/*mousedown_handler*/ ctx[84]), false, true, false, false),
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.action_destroyer)(floatingRef_action = /*floatingRef*/ ctx[48].call(null, div3))
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*listOpen*/ ctx[6]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*listOpen*/ 64) {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_8(ctx);
					if_block0.c();
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0, 1);
					if_block0.m(div3, t0);
				}
			} else if (if_block0) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
			}

			if (/*focused*/ ctx[2]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_7(ctx);
					if_block1.c();
					if_block1.m(span, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (prepend_slot) {
				if (prepend_slot.p && (!current || dirty[2] & /*$$scope*/ 1048576)) {
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_slot_base)(
						prepend_slot,
						prepend_slot_template,
						ctx,
						/*$$scope*/ ctx[82],
						!current
						? (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_all_dirty_from_scope)(/*$$scope*/ ctx[82])
						: (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_slot_changes)(prepend_slot_template, /*$$scope*/ ctx[82], dirty, get_prepend_slot_changes),
						get_prepend_slot_context
					);
				}
			}

			if (/*hasValue*/ ctx[25]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*hasValue*/ 33554432) {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_4(ctx);
					if_block2.c();
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block2, 1);
					if_block2.m(div1, t3);
				}
			} else if (if_block2) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
			}

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_attributes)(input0, input_data_1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.get_spread_update)(input0_levels, [
				(!current || dirty[0] & /*searchable*/ 131072 && input0_readonly_value !== (input0_readonly_value = !/*searchable*/ ctx[17])) && { readOnly: input0_readonly_value },
				dirty[0] & /*_inputAttributes*/ 134217728 && /*_inputAttributes*/ ctx[27],
				(!current || dirty[1] & /*placeholderText*/ 4) && { placeholder: /*placeholderText*/ ctx[33] },
				(!current || dirty[0] & /*inputStyles*/ 262144) && { style: /*inputStyles*/ ctx[18] },
				(!current || dirty[0] & /*disabled*/ 2048) && { disabled: /*disabled*/ ctx[11] }
			]));

			if (dirty[0] & /*filterText*/ 16 && input0.value !== /*filterText*/ ctx[4]) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_input_value)(input0, /*filterText*/ ctx[4]);
			}

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(input0, "svelte-apvs86", true);

			if (/*loading*/ ctx[5]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[0] & /*loading*/ 32) {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_3(ctx);
					if_block3.c();
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block3, 1);
					if_block3.m(div2, t5);
				}
			} else if (if_block3) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
			}

			if (/*showClear*/ ctx[34]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[1] & /*showClear*/ 8) {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_2(ctx);
					if_block4.c();
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block4, 1);
					if_block4.m(div2, t6);
				}
			} else if (if_block4) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
			}

			if (/*showChevron*/ ctx[20]) {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty[0] & /*showChevron*/ 1048576) {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_1(ctx);
					if_block5.c();
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block5, 1);
					if_block5.m(div2, null);
				}
			} else if (if_block5) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
			}

			if (!current || dirty[0] & /*name*/ 256) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(input1, "name", /*name*/ ctx[8]);
			}

			if (!current || dirty[0] & /*value*/ 8 && input1_value_value !== (input1_value_value = /*value*/ ctx[3]
			? JSON.stringify(/*value*/ ctx[3])
			: null)) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.prop_dev)(input1, "value", input1_value_value);
			}

			if (/*required*/ ctx[16] && (!/*value*/ ctx[3] || /*value*/ ctx[3].length === 0)) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[0] & /*required, value*/ 65544) {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block(ctx);
					if_block6.c();
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block6, 1);
					if_block6.m(div3, null);
				}
			} else if (if_block6) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
			}

			if (!current || dirty[0] & /*containerClasses*/ 2097152 && div3_class_value !== (div3_class_value = "svelte-select " + /*containerClasses*/ ctx[21] + " svelte-apvs86")) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div3, "class", div3_class_value);
			}

			if (!current || dirty[0] & /*containerStyles*/ 16384) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div3, "style", /*containerStyles*/ ctx[14]);
			}

			if (!current || dirty[0] & /*containerClasses, multiple*/ 2097664) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div3, "multi", /*multiple*/ ctx[9]);
			}

			if (!current || dirty[0] & /*containerClasses, disabled*/ 2099200) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div3, "disabled", /*disabled*/ ctx[11]);
			}

			if (!current || dirty[0] & /*containerClasses, focused*/ 2097156) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div3, "focused", /*focused*/ ctx[2]);
			}

			if (!current || dirty[0] & /*containerClasses, listOpen*/ 2097216) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div3, "list-open", /*listOpen*/ ctx[6]);
			}

			if (!current || dirty[0] & /*containerClasses, showChevron*/ 3145728) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div3, "show-chevron", /*showChevron*/ ctx[20]);
			}

			if (!current || dirty[0] & /*containerClasses, hasError*/ 2129920) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(div3, "error", /*hasError*/ ctx[15]);
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(prepend_slot, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block5);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block6);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(prepend_slot, local);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block5);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block6);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div3);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (prepend_slot) prepend_slot.d(detaching);
			if (if_block2) if_block2.d();
			/*input0_binding*/ ctx[94](null);
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			if (if_block6) if_block6.d();
			/*div3_binding*/ ctx[96](null);
			mounted = false;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.run_all)(dispose);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function convertStringItemsToObjects(_items) {
	return _items.map((item, index) => {
		return { index, value: item, label: `${item}` };
	});
}

function isItemFirst(itemIndex) {
	return itemIndex === 0;
}

function isItemSelectable(item) {
	return item.groupHeader && item.selectable || item.selectable || !item.hasOwnProperty('selectable');
}

function instance($$self, $$props, $$invalidate) {
	let hasValue;
	let hideSelectedItem;
	let showClear;
	let placeholderText;
	let ariaSelection;
	let ariaContext;
	let filteredItems;
	let listDom;
	let scrollToHoverItem;
	let { $$slots: slots = {}, $$scope } = $$props;

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)('Select', slots, [
		'list','item','empty','prepend','selection','multi-clear-icon','loading-icon','clear-icon','chevron-icon','required'
	]);

	const $$slots = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.compute_slots)(slots);
	const dispatch = (0,svelte__WEBPACK_IMPORTED_MODULE_1__.createEventDispatcher)();
	let { justValue = null } = $$props;
	let { filter = _filter__WEBPACK_IMPORTED_MODULE_3__["default"] } = $$props;
	let { getItems = _get_items__WEBPACK_IMPORTED_MODULE_4__["default"] } = $$props;
	let { id = null } = $$props;
	let { name = null } = $$props;
	let { container = undefined } = $$props;
	let { input = undefined } = $$props;
	let { multiple = false } = $$props;
	let { multiFullItemClearable = false } = $$props;
	let { disabled = false } = $$props;
	let { focused = false } = $$props;
	let { value = null } = $$props;
	let { filterText = '' } = $$props;
	let { placeholder = 'Please select' } = $$props;
	let { placeholderAlwaysShow = false } = $$props;
	let { items = null } = $$props;
	let { label = 'label' } = $$props;
	let { itemFilter = (label, filterText, option) => `${label}`.toLowerCase().includes(filterText.toLowerCase()) } = $$props;
	let { groupBy = undefined } = $$props;
	let { groupFilter = groups => groups } = $$props;
	let { groupHeaderSelectable = false } = $$props;
	let { itemId = 'value' } = $$props;
	let { loadOptions = undefined } = $$props;
	let { containerStyles = '' } = $$props;
	let { hasError = false } = $$props;
	let { filterSelectedItems = true } = $$props;
	let { required = false } = $$props;
	let { closeListOnChange = true } = $$props;

	let { createGroupHeaderItem = (groupValue, item) => {
		return { value: groupValue, [label]: groupValue };
	} } = $$props;

	const getFilteredItems = () => {
		return filteredItems;
	};

	let { searchable = true } = $$props;
	let { inputStyles = '' } = $$props;
	let { clearable = true } = $$props;
	let { loading = false } = $$props;
	let { listOpen = false } = $$props;
	let timeout;

	let { debounce = (fn, wait = 1) => {
		clearTimeout(timeout);
		timeout = setTimeout(fn, wait);
	} } = $$props;

	let { debounceWait = 300 } = $$props;
	let { hideEmptyState = false } = $$props;
	let { inputAttributes = {} } = $$props;
	let { listAutoWidth = true } = $$props;
	let { showChevron = false } = $$props;
	let { listOffset = 5 } = $$props;
	let { hoverItemIndex = 0 } = $$props;
	let { floatingConfig = {} } = $$props;
	let { class: containerClasses = '' } = $$props;
	let activeValue;
	let prev_value;
	let prev_filterText;
	let prev_multiple;

	function setValue() {
		if (typeof value === 'string') {
			let item = (items || []).find(item => item[itemId] === value);
			$$invalidate(3, value = item || { [itemId]: value, label: value });
		} else if (multiple && Array.isArray(value) && value.length > 0) {
			$$invalidate(3, value = value.map(item => typeof item === 'string'
			? { value: item, label: item }
			: item));
		}
	}

	let _inputAttributes;

	function assignInputAttributes() {
		$$invalidate(27, _inputAttributes = Object.assign(
			{
				autocapitalize: 'none',
				autocomplete: 'off',
				autocorrect: 'off',
				spellcheck: false,
				tabindex: 0,
				type: 'text',
				'aria-autocomplete': 'list'
			},
			inputAttributes
		));

		if (id) {
			$$invalidate(27, _inputAttributes['id'] = id, _inputAttributes);
		}

		if (!searchable) {
			$$invalidate(27, _inputAttributes['readonly'] = true, _inputAttributes);
		}
	}

	function filterGroupedItems(_items) {
		const groupValues = [];
		const groups = {};

		_items.forEach(item => {
			const groupValue = groupBy(item);

			if (!groupValues.includes(groupValue)) {
				groupValues.push(groupValue);
				groups[groupValue] = [];

				if (groupValue) {
					groups[groupValue].push(Object.assign(createGroupHeaderItem(groupValue, item), {
						id: groupValue,
						groupHeader: true,
						selectable: groupHeaderSelectable
					}));
				}
			}

			groups[groupValue].push(Object.assign({ groupItem: !!groupValue }, item));
		});

		const sortedGroupedItems = [];

		groupFilter(groupValues).forEach(groupValue => {
			if (groups[groupValue]) sortedGroupedItems.push(...groups[groupValue]);
		});

		return sortedGroupedItems;
	}

	function dispatchSelectedItem() {
		if (multiple) {
			if (JSON.stringify(value) !== JSON.stringify(prev_value)) {
				if (checkValueForDuplicates()) {
					dispatch('input', value);
				}
			}

			return;
		}

		if (!prev_value || JSON.stringify(value[itemId]) !== JSON.stringify(prev_value[itemId])) {
			dispatch('input', value);
		}
	}

	function setupMulti() {
		if (value) {
			if (Array.isArray(value)) {
				$$invalidate(3, value = [...value]);
			} else {
				$$invalidate(3, value = [value]);
			}
		}
	}

	function setupSingle() {
		if (value) $$invalidate(3, value = null);
	}

	function setValueIndexAsHoverIndex() {
		const valueIndex = filteredItems.findIndex(i => {
			return i[itemId] === value[itemId];
		});

		checkHoverSelectable(valueIndex, true);
	}

	function dispatchHover(i) {
		dispatch('hoverItem', i);
	}

	function checkHoverSelectable(startingIndex = 0, ignoreGroup) {
		$$invalidate(7, hoverItemIndex = startingIndex < 0 ? 0 : startingIndex);

		if (!ignoreGroup && groupBy && filteredItems[hoverItemIndex] && !filteredItems[hoverItemIndex].selectable) {
			setHoverIndex(1);
		}
	}

	function setupFilterText() {
		if (!loadOptions && filterText.length === 0) return;

		if (loadOptions) {
			debounce(
				async function () {
					$$invalidate(5, loading = true);

					let res = await getItems({
						dispatch,
						loadOptions,
						convertStringItemsToObjects,
						filterText
					});

					if (res) {
						$$invalidate(5, loading = res.loading);

						$$invalidate(6, listOpen = listOpen
						? res.listOpen
						: filterText.length > 0 ? true : false);

						$$invalidate(2, focused = listOpen && res.focused);

						$$invalidate(52, items = groupBy
						? filterGroupedItems(res.filteredItems)
						: res.filteredItems);
					} else {
						$$invalidate(5, loading = false);
						$$invalidate(2, focused = true);
						$$invalidate(6, listOpen = true);
					}
				},
				debounceWait
			);
		} else {
			$$invalidate(6, listOpen = true);

			if (multiple) {
				$$invalidate(26, activeValue = undefined);
			}
		}
	}

	function handleFilterEvent(items) {
		if (listOpen) dispatch('filter', items);
	}

	(0,svelte__WEBPACK_IMPORTED_MODULE_1__.beforeUpdate)(async () => {
		$$invalidate(78, prev_value = value);
		$$invalidate(79, prev_filterText = filterText);
		$$invalidate(80, prev_multiple = multiple);
	});

	function computeJustValue() {
		if (multiple) return value ? value.map(item => item[itemId]) : null;
		return value ? value[itemId] : value;
	}

	function checkValueForDuplicates() {
		let noDuplicates = true;

		if (value) {
			const ids = [];
			const uniqueValues = [];

			value.forEach(val => {
				if (!ids.includes(val[itemId])) {
					ids.push(val[itemId]);
					uniqueValues.push(val);
				} else {
					noDuplicates = false;
				}
			});

			if (!noDuplicates) $$invalidate(3, value = uniqueValues);
		}

		return noDuplicates;
	}

	function findItem(selection) {
		let matchTo = selection ? selection[itemId] : value[itemId];
		return items.find(item => item[itemId] === matchTo);
	}

	function updateValueDisplay(items) {
		if (!items || items.length === 0 || items.some(item => typeof item !== 'object')) return;

		if (!value || (multiple
		? value.some(selection => !selection || !selection[itemId])
		: !value[itemId])) return;

		if (Array.isArray(value)) {
			$$invalidate(3, value = value.map(selection => findItem(selection) || selection));
		} else {
			$$invalidate(3, value = findItem() || value);
		}
	}

	async function handleMultiItemClear(i) {
		const itemToRemove = value[i];

		if (value.length === 1) {
			$$invalidate(3, value = undefined);
		} else {
			$$invalidate(3, value = value.filter(item => {
				return item !== itemToRemove;
			}));
		}

		dispatch('clear', itemToRemove);
	}

	function handleKeyDown(e) {
		if (!focused) return;
		e.stopPropagation();

		switch (e.key) {
			case 'Escape':
				e.preventDefault();
				closeList();
				break;
			case 'Enter':
				e.preventDefault();
				if (listOpen) {
					if (filteredItems.length === 0) break;
					const hoverItem = filteredItems[hoverItemIndex];

					if (value && !multiple && value[itemId] === hoverItem[itemId]) {
						closeList();
						break;
					} else {
						handleSelect(filteredItems[hoverItemIndex]);
					}
				}
				break;
			case 'ArrowDown':
				e.preventDefault();
				if (listOpen) {
					setHoverIndex(1);
				} else {
					$$invalidate(6, listOpen = true);
					$$invalidate(26, activeValue = undefined);
				}
				break;
			case 'ArrowUp':
				e.preventDefault();
				if (listOpen) {
					setHoverIndex(-1);
				} else {
					$$invalidate(6, listOpen = true);
					$$invalidate(26, activeValue = undefined);
				}
				break;
			case 'Tab':
				if (listOpen && focused) {
					if (filteredItems.length === 0 || value && value[itemId] === filteredItems[hoverItemIndex][itemId]) return closeList();
					e.preventDefault();
					handleSelect(filteredItems[hoverItemIndex]);
					closeList();
				}
				break;
			case 'Backspace':
				if (!multiple || filterText.length > 0) return;
				if (multiple && value && value.length > 0) {
					handleMultiItemClear(activeValue !== undefined
					? activeValue
					: value.length - 1);

					if (activeValue === 0 || activeValue === undefined) break;
					$$invalidate(26, activeValue = value.length > activeValue ? activeValue - 1 : undefined);
				}
				break;
			case 'ArrowLeft':
				if (!value || !multiple || filterText.length > 0) return;
				if (activeValue === undefined) {
					$$invalidate(26, activeValue = value.length - 1);
				} else if (value.length > activeValue && activeValue !== 0) {
					$$invalidate(26, activeValue -= 1);
				}
				break;
			case 'ArrowRight':
				if (!value || !multiple || filterText.length > 0 || activeValue === undefined) return;
				if (activeValue === value.length - 1) {
					$$invalidate(26, activeValue = undefined);
				} else if (activeValue < value.length - 1) {
					$$invalidate(26, activeValue += 1);
				}
				break;
		}
	}

	function handleFocus(e) {
		if (focused && input === document?.activeElement) return;
		if (e) dispatch('focus', e);
		input.focus();
		$$invalidate(2, focused = true);
	}

	async function handleBlur(e) {
		if (isScrolling || itemEventInProgress) return;

		if (listOpen || focused) {
			dispatch('blur', e);
			closeList();
			$$invalidate(2, focused = false);
			$$invalidate(26, activeValue = undefined);
			input.blur();
		}
	}

	function handleClick() {
		if (disabled) return;
		$$invalidate(6, listOpen = !listOpen);
	}

	function handleClear() {
		dispatch('clear', value);
		$$invalidate(3, value = undefined);
		closeList();
		handleFocus();
	}

	(0,svelte__WEBPACK_IMPORTED_MODULE_1__.onMount)(() => {
		if (listOpen) $$invalidate(2, focused = true);
		if (focused && input) input.focus();
	});

	function itemSelected(selection) {
		if (selection) {
			$$invalidate(4, filterText = '');
			const item = Object.assign({}, selection);
			if (item.groupHeader && !item.selectable) return;

			$$invalidate(3, value = multiple
			? value ? value.concat([item]) : [item]
			: $$invalidate(3, value = item));

			setTimeout(() => {
				if (closeListOnChange) closeList();
				$$invalidate(26, activeValue = undefined);
				dispatch('change', value);
				dispatch('select', selection);
			});
		}
	}

	function closeList() {
		$$invalidate(4, filterText = '');
		$$invalidate(6, listOpen = false);
	}

	let { ariaValues = values => {
		return `Option ${values}, selected.`;
	} } = $$props;

	let { ariaListOpen = (label, count) => {
		return `You are currently focused on option ${label}. There are ${count} results available.`;
	} } = $$props;

	let { ariaFocused = () => {
		return `Select is focused, type to refine list, press down to open the menu.`;
	} } = $$props;

	function handleAriaSelection(_multiple) {
		let selected = undefined;

		if (_multiple && value.length > 0) {
			selected = value.map(v => v[label]).join(', ');
		} else {
			selected = value[label];
		}

		return ariaValues(selected);
	}

	function handleAriaContent() {
		if (!filteredItems || filteredItems.length === 0) return '';
		let _item = filteredItems[hoverItemIndex];

		if (listOpen && _item) {
			let count = filteredItems ? filteredItems.length : 0;
			return ariaListOpen(_item[label], count);
		} else {
			return ariaFocused();
		}
	}

	let list = null;
	let isScrollingTimer;

	function handleListScroll() {
		clearTimeout(isScrollingTimer);

		isScrollingTimer = setTimeout(
			() => {
				isScrolling = false;
			},
			100
		);
	}

	function handleClickOutside(event) {
		if (!listOpen && !focused && container && !container.contains(event.target) && !list?.contains(event.target)) {
			handleBlur();
		}
	}

	(0,svelte__WEBPACK_IMPORTED_MODULE_1__.onDestroy)(() => {
		list?.remove();
	});

	let isScrolling = false;

	function handleSelect(item) {
		if (!item || item.selectable === false) return;
		itemSelected(item);
	}

	function handleHover(i) {
		if (isScrolling) return;
		$$invalidate(7, hoverItemIndex = i);
	}

	function handleItemClick(args) {
		const { item, i } = args;
		if (item?.selectable === false) return;
		if (value && !multiple && value[itemId] === item[itemId]) return closeList();

		if (isItemSelectable(item)) {
			$$invalidate(7, hoverItemIndex = i);
			handleSelect(item);
		}

		itemEventInProgress = false;
	}

	function setHoverIndex(increment) {
		let selectableFilteredItems = filteredItems.filter(item => !Object.hasOwn(item, 'selectable') || item.selectable === true);

		if (selectableFilteredItems.length === 0) {
			return $$invalidate(7, hoverItemIndex = 0);
		}

		if (increment > 0 && hoverItemIndex === filteredItems.length - 1) {
			$$invalidate(7, hoverItemIndex = 0);
		} else if (increment < 0 && hoverItemIndex === 0) {
			$$invalidate(7, hoverItemIndex = filteredItems.length - 1);
		} else {
			$$invalidate(7, hoverItemIndex = hoverItemIndex + increment);
		}

		const hover = filteredItems[hoverItemIndex];

		if (hover && hover.selectable === false) {
			if (increment === 1 || increment === -1) setHoverIndex(increment);
			return;
		}
	}

	function isItemActive(item, value, itemId) {
		if (multiple) return;
		return value && value[itemId] === item[itemId];
	}

	const activeScroll = scrollAction;
	const hoverScroll = scrollAction;

	function scrollAction(node) {
		return {
			update(args) {
				if (args.scroll) {
					handleListScroll();
					node.scrollIntoView({ behavior: 'auto', block: 'nearest' });
				}
			}
		};
	}

	function setListWidth() {
		const { width } = container.getBoundingClientRect();
		$$invalidate(23, list.style.width = listAutoWidth ? width + 'px' : 'auto', list);
	}

	let _floatingConfig = {
		strategy: 'absolute',
		placement: 'bottom-start',
		middleware: [(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_8__.offset)(listOffset), (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_8__.flip)(), (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_8__.shift)()],
		autoUpdate: false
	};

	const [floatingRef, floatingContent, floatingUpdate] = (0,svelte_floating_ui__WEBPACK_IMPORTED_MODULE_2__.createFloatingActions)(_floatingConfig);
	let prefloat = true;

	function listMounted(list, listOpen) {
		if (!list || !listOpen) return $$invalidate(28, prefloat = true);

		setTimeout(
			() => {
				$$invalidate(28, prefloat = false);
			},
			0
		);
	}

	let itemEventInProgress = false;

	function handlePointerDown() {
		itemEventInProgress = true;
	}

	const writable_props = [
		'justValue',
		'filter',
		'getItems',
		'id',
		'name',
		'container',
		'input',
		'multiple',
		'multiFullItemClearable',
		'disabled',
		'focused',
		'value',
		'filterText',
		'placeholder',
		'placeholderAlwaysShow',
		'items',
		'label',
		'itemFilter',
		'groupBy',
		'groupFilter',
		'groupHeaderSelectable',
		'itemId',
		'loadOptions',
		'containerStyles',
		'hasError',
		'filterSelectedItems',
		'required',
		'closeListOnChange',
		'createGroupHeaderItem',
		'searchable',
		'inputStyles',
		'clearable',
		'loading',
		'listOpen',
		'debounce',
		'debounceWait',
		'hideEmptyState',
		'inputAttributes',
		'listAutoWidth',
		'showChevron',
		'listOffset',
		'hoverItemIndex',
		'floatingConfig',
		'class',
		'ariaValues',
		'ariaListOpen',
		'ariaFocused'
	];

	Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Select> was created with unknown prop '${key}'`);
	});

	function mousedown_handler(event) {
		svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bubble.call(this, $$self, event);
	}

	function keydown_handler_1(event) {
		svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bubble.call(this, $$self, event);
	}

	function pointerup_handler(event) {
		svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bubble.call(this, $$self, event);
	}

	function keydown_handler(event) {
		svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bubble.call(this, $$self, event);
	}

	const mouseover_handler = i => handleHover(i);
	const focus_handler = i => handleHover(i);
	const click_handler = (item, i) => handleItemClick({ item, i });

	function div_binding($$value) {
		svelte_internal__WEBPACK_IMPORTED_MODULE_0__.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			list = $$value;
			$$invalidate(23, list);
		});
	}

	const pointerup_handler_1 = i => handleMultiItemClear(i);
	const click_handler_1 = i => multiFullItemClearable ? handleMultiItemClear(i) : {};

	function input0_binding($$value) {
		svelte_internal__WEBPACK_IMPORTED_MODULE_0__.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			input = $$value;
			$$invalidate(1, input);
		});
	}

	function input0_input_handler() {
		filterText = this.value;
		$$invalidate(4, filterText);
	}

	function div3_binding($$value) {
		svelte_internal__WEBPACK_IMPORTED_MODULE_0__.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			container = $$value;
			$$invalidate(0, container);
		});
	}

	$$self.$$set = $$props => {
		if ('justValue' in $$props) $$invalidate(53, justValue = $$props.justValue);
		if ('filter' in $$props) $$invalidate(54, filter = $$props.filter);
		if ('getItems' in $$props) $$invalidate(55, getItems = $$props.getItems);
		if ('id' in $$props) $$invalidate(56, id = $$props.id);
		if ('name' in $$props) $$invalidate(8, name = $$props.name);
		if ('container' in $$props) $$invalidate(0, container = $$props.container);
		if ('input' in $$props) $$invalidate(1, input = $$props.input);
		if ('multiple' in $$props) $$invalidate(9, multiple = $$props.multiple);
		if ('multiFullItemClearable' in $$props) $$invalidate(10, multiFullItemClearable = $$props.multiFullItemClearable);
		if ('disabled' in $$props) $$invalidate(11, disabled = $$props.disabled);
		if ('focused' in $$props) $$invalidate(2, focused = $$props.focused);
		if ('value' in $$props) $$invalidate(3, value = $$props.value);
		if ('filterText' in $$props) $$invalidate(4, filterText = $$props.filterText);
		if ('placeholder' in $$props) $$invalidate(57, placeholder = $$props.placeholder);
		if ('placeholderAlwaysShow' in $$props) $$invalidate(58, placeholderAlwaysShow = $$props.placeholderAlwaysShow);
		if ('items' in $$props) $$invalidate(52, items = $$props.items);
		if ('label' in $$props) $$invalidate(12, label = $$props.label);
		if ('itemFilter' in $$props) $$invalidate(59, itemFilter = $$props.itemFilter);
		if ('groupBy' in $$props) $$invalidate(60, groupBy = $$props.groupBy);
		if ('groupFilter' in $$props) $$invalidate(61, groupFilter = $$props.groupFilter);
		if ('groupHeaderSelectable' in $$props) $$invalidate(62, groupHeaderSelectable = $$props.groupHeaderSelectable);
		if ('itemId' in $$props) $$invalidate(13, itemId = $$props.itemId);
		if ('loadOptions' in $$props) $$invalidate(63, loadOptions = $$props.loadOptions);
		if ('containerStyles' in $$props) $$invalidate(14, containerStyles = $$props.containerStyles);
		if ('hasError' in $$props) $$invalidate(15, hasError = $$props.hasError);
		if ('filterSelectedItems' in $$props) $$invalidate(64, filterSelectedItems = $$props.filterSelectedItems);
		if ('required' in $$props) $$invalidate(16, required = $$props.required);
		if ('closeListOnChange' in $$props) $$invalidate(65, closeListOnChange = $$props.closeListOnChange);
		if ('createGroupHeaderItem' in $$props) $$invalidate(66, createGroupHeaderItem = $$props.createGroupHeaderItem);
		if ('searchable' in $$props) $$invalidate(17, searchable = $$props.searchable);
		if ('inputStyles' in $$props) $$invalidate(18, inputStyles = $$props.inputStyles);
		if ('clearable' in $$props) $$invalidate(68, clearable = $$props.clearable);
		if ('loading' in $$props) $$invalidate(5, loading = $$props.loading);
		if ('listOpen' in $$props) $$invalidate(6, listOpen = $$props.listOpen);
		if ('debounce' in $$props) $$invalidate(69, debounce = $$props.debounce);
		if ('debounceWait' in $$props) $$invalidate(70, debounceWait = $$props.debounceWait);
		if ('hideEmptyState' in $$props) $$invalidate(19, hideEmptyState = $$props.hideEmptyState);
		if ('inputAttributes' in $$props) $$invalidate(71, inputAttributes = $$props.inputAttributes);
		if ('listAutoWidth' in $$props) $$invalidate(72, listAutoWidth = $$props.listAutoWidth);
		if ('showChevron' in $$props) $$invalidate(20, showChevron = $$props.showChevron);
		if ('listOffset' in $$props) $$invalidate(73, listOffset = $$props.listOffset);
		if ('hoverItemIndex' in $$props) $$invalidate(7, hoverItemIndex = $$props.hoverItemIndex);
		if ('floatingConfig' in $$props) $$invalidate(74, floatingConfig = $$props.floatingConfig);
		if ('class' in $$props) $$invalidate(21, containerClasses = $$props.class);
		if ('ariaValues' in $$props) $$invalidate(75, ariaValues = $$props.ariaValues);
		if ('ariaListOpen' in $$props) $$invalidate(76, ariaListOpen = $$props.ariaListOpen);
		if ('ariaFocused' in $$props) $$invalidate(77, ariaFocused = $$props.ariaFocused);
		if ('$$scope' in $$props) $$invalidate(82, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		beforeUpdate: svelte__WEBPACK_IMPORTED_MODULE_1__.beforeUpdate,
		createEventDispatcher: svelte__WEBPACK_IMPORTED_MODULE_1__.createEventDispatcher,
		onDestroy: svelte__WEBPACK_IMPORTED_MODULE_1__.onDestroy,
		onMount: svelte__WEBPACK_IMPORTED_MODULE_1__.onMount,
		offset: _floating_ui_dom__WEBPACK_IMPORTED_MODULE_8__.offset,
		flip: _floating_ui_dom__WEBPACK_IMPORTED_MODULE_8__.flip,
		shift: _floating_ui_dom__WEBPACK_IMPORTED_MODULE_8__.shift,
		createFloatingActions: svelte_floating_ui__WEBPACK_IMPORTED_MODULE_2__.createFloatingActions,
		dispatch,
		_filter: _filter__WEBPACK_IMPORTED_MODULE_3__["default"],
		_getItems: _get_items__WEBPACK_IMPORTED_MODULE_4__["default"],
		ChevronIcon: _ChevronIcon_svelte__WEBPACK_IMPORTED_MODULE_5__["default"],
		ClearIcon: _ClearIcon_svelte__WEBPACK_IMPORTED_MODULE_6__["default"],
		LoadingIcon: _LoadingIcon_svelte__WEBPACK_IMPORTED_MODULE_7__["default"],
		justValue,
		filter,
		getItems,
		id,
		name,
		container,
		input,
		multiple,
		multiFullItemClearable,
		disabled,
		focused,
		value,
		filterText,
		placeholder,
		placeholderAlwaysShow,
		items,
		label,
		itemFilter,
		groupBy,
		groupFilter,
		groupHeaderSelectable,
		itemId,
		loadOptions,
		containerStyles,
		hasError,
		filterSelectedItems,
		required,
		closeListOnChange,
		createGroupHeaderItem,
		getFilteredItems,
		searchable,
		inputStyles,
		clearable,
		loading,
		listOpen,
		timeout,
		debounce,
		debounceWait,
		hideEmptyState,
		inputAttributes,
		listAutoWidth,
		showChevron,
		listOffset,
		hoverItemIndex,
		floatingConfig,
		containerClasses,
		activeValue,
		prev_value,
		prev_filterText,
		prev_multiple,
		setValue,
		_inputAttributes,
		assignInputAttributes,
		convertStringItemsToObjects,
		filterGroupedItems,
		dispatchSelectedItem,
		setupMulti,
		setupSingle,
		setValueIndexAsHoverIndex,
		dispatchHover,
		checkHoverSelectable,
		setupFilterText,
		handleFilterEvent,
		computeJustValue,
		checkValueForDuplicates,
		findItem,
		updateValueDisplay,
		handleMultiItemClear,
		handleKeyDown,
		handleFocus,
		handleBlur,
		handleClick,
		handleClear,
		itemSelected,
		closeList,
		ariaValues,
		ariaListOpen,
		ariaFocused,
		handleAriaSelection,
		handleAriaContent,
		list,
		isScrollingTimer,
		handleListScroll,
		handleClickOutside,
		isScrolling,
		handleSelect,
		handleHover,
		handleItemClick,
		setHoverIndex,
		isItemActive,
		isItemFirst,
		isItemSelectable,
		activeScroll,
		hoverScroll,
		scrollAction,
		setListWidth,
		_floatingConfig,
		floatingRef,
		floatingContent,
		floatingUpdate,
		prefloat,
		listMounted,
		itemEventInProgress,
		handlePointerDown,
		filteredItems,
		scrollToHoverItem,
		listDom,
		ariaContext,
		ariaSelection,
		placeholderText,
		hasValue,
		showClear,
		hideSelectedItem
	});

	$$self.$inject_state = $$props => {
		if ('justValue' in $$props) $$invalidate(53, justValue = $$props.justValue);
		if ('filter' in $$props) $$invalidate(54, filter = $$props.filter);
		if ('getItems' in $$props) $$invalidate(55, getItems = $$props.getItems);
		if ('id' in $$props) $$invalidate(56, id = $$props.id);
		if ('name' in $$props) $$invalidate(8, name = $$props.name);
		if ('container' in $$props) $$invalidate(0, container = $$props.container);
		if ('input' in $$props) $$invalidate(1, input = $$props.input);
		if ('multiple' in $$props) $$invalidate(9, multiple = $$props.multiple);
		if ('multiFullItemClearable' in $$props) $$invalidate(10, multiFullItemClearable = $$props.multiFullItemClearable);
		if ('disabled' in $$props) $$invalidate(11, disabled = $$props.disabled);
		if ('focused' in $$props) $$invalidate(2, focused = $$props.focused);
		if ('value' in $$props) $$invalidate(3, value = $$props.value);
		if ('filterText' in $$props) $$invalidate(4, filterText = $$props.filterText);
		if ('placeholder' in $$props) $$invalidate(57, placeholder = $$props.placeholder);
		if ('placeholderAlwaysShow' in $$props) $$invalidate(58, placeholderAlwaysShow = $$props.placeholderAlwaysShow);
		if ('items' in $$props) $$invalidate(52, items = $$props.items);
		if ('label' in $$props) $$invalidate(12, label = $$props.label);
		if ('itemFilter' in $$props) $$invalidate(59, itemFilter = $$props.itemFilter);
		if ('groupBy' in $$props) $$invalidate(60, groupBy = $$props.groupBy);
		if ('groupFilter' in $$props) $$invalidate(61, groupFilter = $$props.groupFilter);
		if ('groupHeaderSelectable' in $$props) $$invalidate(62, groupHeaderSelectable = $$props.groupHeaderSelectable);
		if ('itemId' in $$props) $$invalidate(13, itemId = $$props.itemId);
		if ('loadOptions' in $$props) $$invalidate(63, loadOptions = $$props.loadOptions);
		if ('containerStyles' in $$props) $$invalidate(14, containerStyles = $$props.containerStyles);
		if ('hasError' in $$props) $$invalidate(15, hasError = $$props.hasError);
		if ('filterSelectedItems' in $$props) $$invalidate(64, filterSelectedItems = $$props.filterSelectedItems);
		if ('required' in $$props) $$invalidate(16, required = $$props.required);
		if ('closeListOnChange' in $$props) $$invalidate(65, closeListOnChange = $$props.closeListOnChange);
		if ('createGroupHeaderItem' in $$props) $$invalidate(66, createGroupHeaderItem = $$props.createGroupHeaderItem);
		if ('searchable' in $$props) $$invalidate(17, searchable = $$props.searchable);
		if ('inputStyles' in $$props) $$invalidate(18, inputStyles = $$props.inputStyles);
		if ('clearable' in $$props) $$invalidate(68, clearable = $$props.clearable);
		if ('loading' in $$props) $$invalidate(5, loading = $$props.loading);
		if ('listOpen' in $$props) $$invalidate(6, listOpen = $$props.listOpen);
		if ('timeout' in $$props) timeout = $$props.timeout;
		if ('debounce' in $$props) $$invalidate(69, debounce = $$props.debounce);
		if ('debounceWait' in $$props) $$invalidate(70, debounceWait = $$props.debounceWait);
		if ('hideEmptyState' in $$props) $$invalidate(19, hideEmptyState = $$props.hideEmptyState);
		if ('inputAttributes' in $$props) $$invalidate(71, inputAttributes = $$props.inputAttributes);
		if ('listAutoWidth' in $$props) $$invalidate(72, listAutoWidth = $$props.listAutoWidth);
		if ('showChevron' in $$props) $$invalidate(20, showChevron = $$props.showChevron);
		if ('listOffset' in $$props) $$invalidate(73, listOffset = $$props.listOffset);
		if ('hoverItemIndex' in $$props) $$invalidate(7, hoverItemIndex = $$props.hoverItemIndex);
		if ('floatingConfig' in $$props) $$invalidate(74, floatingConfig = $$props.floatingConfig);
		if ('containerClasses' in $$props) $$invalidate(21, containerClasses = $$props.containerClasses);
		if ('activeValue' in $$props) $$invalidate(26, activeValue = $$props.activeValue);
		if ('prev_value' in $$props) $$invalidate(78, prev_value = $$props.prev_value);
		if ('prev_filterText' in $$props) $$invalidate(79, prev_filterText = $$props.prev_filterText);
		if ('prev_multiple' in $$props) $$invalidate(80, prev_multiple = $$props.prev_multiple);
		if ('_inputAttributes' in $$props) $$invalidate(27, _inputAttributes = $$props._inputAttributes);
		if ('ariaValues' in $$props) $$invalidate(75, ariaValues = $$props.ariaValues);
		if ('ariaListOpen' in $$props) $$invalidate(76, ariaListOpen = $$props.ariaListOpen);
		if ('ariaFocused' in $$props) $$invalidate(77, ariaFocused = $$props.ariaFocused);
		if ('list' in $$props) $$invalidate(23, list = $$props.list);
		if ('isScrollingTimer' in $$props) isScrollingTimer = $$props.isScrollingTimer;
		if ('isScrolling' in $$props) isScrolling = $$props.isScrolling;
		if ('_floatingConfig' in $$props) $$invalidate(81, _floatingConfig = $$props._floatingConfig);
		if ('prefloat' in $$props) $$invalidate(28, prefloat = $$props.prefloat);
		if ('itemEventInProgress' in $$props) itemEventInProgress = $$props.itemEventInProgress;
		if ('filteredItems' in $$props) $$invalidate(24, filteredItems = $$props.filteredItems);
		if ('scrollToHoverItem' in $$props) $$invalidate(29, scrollToHoverItem = $$props.scrollToHoverItem);
		if ('listDom' in $$props) $$invalidate(30, listDom = $$props.listDom);
		if ('ariaContext' in $$props) $$invalidate(31, ariaContext = $$props.ariaContext);
		if ('ariaSelection' in $$props) $$invalidate(32, ariaSelection = $$props.ariaSelection);
		if ('placeholderText' in $$props) $$invalidate(33, placeholderText = $$props.placeholderText);
		if ('hasValue' in $$props) $$invalidate(25, hasValue = $$props.hasValue);
		if ('showClear' in $$props) $$invalidate(34, showClear = $$props.showClear);
		if ('hideSelectedItem' in $$props) $$invalidate(35, hideSelectedItem = $$props.hideSelectedItem);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*value*/ 8 | $$self.$$.dirty[1] & /*items*/ 2097152) {
			$: if ((items, value)) setValue();
		}

		if ($$self.$$.dirty[0] & /*searchable*/ 131072 | $$self.$$.dirty[2] & /*inputAttributes*/ 512) {
			$: if (inputAttributes || !searchable) assignInputAttributes();
		}

		if ($$self.$$.dirty[0] & /*multiple*/ 512) {
			$: if (multiple) setupMulti();
		}

		if ($$self.$$.dirty[0] & /*multiple*/ 512 | $$self.$$.dirty[2] & /*prev_multiple*/ 262144) {
			$: if (prev_multiple && !multiple) setupSingle();
		}

		if ($$self.$$.dirty[0] & /*multiple, value*/ 520) {
			$: if (multiple && value && value.length > 1) checkValueForDuplicates();
		}

		if ($$self.$$.dirty[0] & /*value*/ 8) {
			$: if (value) dispatchSelectedItem();
		}

		if ($$self.$$.dirty[0] & /*value, multiple*/ 520 | $$self.$$.dirty[2] & /*prev_value*/ 65536) {
			$: if (!value && multiple && prev_value) dispatch('input', value);
		}

		if ($$self.$$.dirty[0] & /*focused, input*/ 6) {
			$: if (!focused && input) closeList();
		}

		if ($$self.$$.dirty[0] & /*filterText*/ 16 | $$self.$$.dirty[2] & /*prev_filterText*/ 131072) {
			$: if (filterText !== prev_filterText) setupFilterText();
		}

		if ($$self.$$.dirty[0] & /*filterText, multiple, value, itemId, label*/ 12824 | $$self.$$.dirty[1] & /*filter, items, groupBy, itemFilter*/ 815792128 | $$self.$$.dirty[2] & /*loadOptions, filterSelectedItems*/ 6) {
			$: $$invalidate(24, filteredItems = filter({
				loadOptions,
				filterText,
				items,
				multiple,
				value,
				itemId,
				groupBy,
				label,
				filterSelectedItems,
				itemFilter,
				convertStringItemsToObjects,
				filterGroupedItems
			}));
		}

		if ($$self.$$.dirty[0] & /*multiple, listOpen, value, filteredItems*/ 16777800) {
			$: if (!multiple && listOpen && value && filteredItems) setValueIndexAsHoverIndex();
		}

		if ($$self.$$.dirty[0] & /*listOpen, multiple*/ 576) {
			$: if (listOpen && multiple) $$invalidate(7, hoverItemIndex = 0);
		}

		if ($$self.$$.dirty[0] & /*filterText*/ 16) {
			$: if (filterText) $$invalidate(7, hoverItemIndex = 0);
		}

		if ($$self.$$.dirty[0] & /*hoverItemIndex*/ 128) {
			$: dispatchHover(hoverItemIndex);
		}

		if ($$self.$$.dirty[0] & /*multiple, value*/ 520) {
			$: $$invalidate(25, hasValue = multiple ? value && value.length > 0 : value);
		}

		if ($$self.$$.dirty[0] & /*hasValue, filterText*/ 33554448) {
			$: $$invalidate(35, hideSelectedItem = hasValue && filterText.length > 0);
		}

		if ($$self.$$.dirty[0] & /*hasValue, disabled, loading*/ 33556512 | $$self.$$.dirty[2] & /*clearable*/ 64) {
			$: $$invalidate(34, showClear = hasValue && clearable && !disabled && !loading);
		}

		if ($$self.$$.dirty[0] & /*multiple, value*/ 520 | $$self.$$.dirty[1] & /*placeholderAlwaysShow, placeholder*/ 201326592) {
			$: $$invalidate(33, placeholderText = placeholderAlwaysShow && multiple
			? placeholder
			: multiple && value?.length === 0
				? placeholder
				: value ? '' : placeholder);
		}

		if ($$self.$$.dirty[0] & /*value, multiple*/ 520) {
			$: $$invalidate(32, ariaSelection = value ? handleAriaSelection(multiple) : '');
		}

		if ($$self.$$.dirty[0] & /*filteredItems, hoverItemIndex, focused, listOpen*/ 16777412) {
			$: $$invalidate(31, ariaContext = handleAriaContent({
				filteredItems,
				hoverItemIndex,
				focused,
				listOpen
			}));
		}

		if ($$self.$$.dirty[1] & /*items*/ 2097152) {
			$: updateValueDisplay(items);
		}

		if ($$self.$$.dirty[0] & /*multiple, value, itemId*/ 8712) {
			$: $$invalidate(53, justValue = computeJustValue(multiple, value, itemId));
		}

		if ($$self.$$.dirty[0] & /*multiple, value*/ 520 | $$self.$$.dirty[2] & /*prev_value*/ 65536) {
			$: if (!multiple && prev_value && !value) dispatch('input', value);
		}

		if ($$self.$$.dirty[0] & /*listOpen, filteredItems, multiple, value*/ 16777800) {
			$: if (listOpen && filteredItems && !multiple && !value) checkHoverSelectable();
		}

		if ($$self.$$.dirty[0] & /*filteredItems*/ 16777216) {
			$: handleFilterEvent(filteredItems);
		}

		if ($$self.$$.dirty[0] & /*container*/ 1 | $$self.$$.dirty[2] & /*floatingConfig*/ 4096) {
			$: if (container && floatingConfig?.autoUpdate === undefined) {
				$$invalidate(81, _floatingConfig.autoUpdate = true, _floatingConfig);
			}
		}

		if ($$self.$$.dirty[0] & /*container*/ 1 | $$self.$$.dirty[2] & /*floatingConfig, _floatingConfig*/ 528384) {
			$: if (container && floatingConfig) floatingUpdate(Object.assign(_floatingConfig, floatingConfig));
		}

		if ($$self.$$.dirty[0] & /*list*/ 8388608) {
			$: $$invalidate(30, listDom = !!list);
		}

		if ($$self.$$.dirty[0] & /*list, listOpen*/ 8388672) {
			$: listMounted(list, listOpen);
		}

		if ($$self.$$.dirty[0] & /*listOpen, container, list*/ 8388673) {
			$: if (listOpen && container && list) setListWidth();
		}

		if ($$self.$$.dirty[0] & /*hoverItemIndex*/ 128) {
			$: $$invalidate(29, scrollToHoverItem = hoverItemIndex);
		}

		if ($$self.$$.dirty[0] & /*input, listOpen, focused*/ 70) {
			$: if (input && listOpen && !focused) handleFocus();
		}
	};

	return [
		container,
		input,
		focused,
		value,
		filterText,
		loading,
		listOpen,
		hoverItemIndex,
		name,
		multiple,
		multiFullItemClearable,
		disabled,
		label,
		itemId,
		containerStyles,
		hasError,
		required,
		searchable,
		inputStyles,
		hideEmptyState,
		showChevron,
		containerClasses,
		handleClear,
		list,
		filteredItems,
		hasValue,
		activeValue,
		_inputAttributes,
		prefloat,
		scrollToHoverItem,
		listDom,
		ariaContext,
		ariaSelection,
		placeholderText,
		showClear,
		hideSelectedItem,
		handleMultiItemClear,
		handleKeyDown,
		handleFocus,
		handleBlur,
		handleClick,
		handleListScroll,
		handleClickOutside,
		handleHover,
		handleItemClick,
		isItemActive,
		activeScroll,
		hoverScroll,
		floatingRef,
		floatingContent,
		handlePointerDown,
		$$slots,
		items,
		justValue,
		filter,
		getItems,
		id,
		placeholder,
		placeholderAlwaysShow,
		itemFilter,
		groupBy,
		groupFilter,
		groupHeaderSelectable,
		loadOptions,
		filterSelectedItems,
		closeListOnChange,
		createGroupHeaderItem,
		getFilteredItems,
		clearable,
		debounce,
		debounceWait,
		inputAttributes,
		listAutoWidth,
		listOffset,
		floatingConfig,
		ariaValues,
		ariaListOpen,
		ariaFocused,
		prev_value,
		prev_filterText,
		prev_multiple,
		_floatingConfig,
		$$scope,
		slots,
		mousedown_handler,
		keydown_handler_1,
		pointerup_handler,
		keydown_handler,
		mouseover_handler,
		focus_handler,
		click_handler,
		div_binding,
		pointerup_handler_1,
		click_handler_1,
		input0_binding,
		input0_input_handler,
		div3_binding
	];
}

class Select extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {
	constructor(options) {
		super(options);

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(
			this,
			options,
			instance,
			create_fragment,
			svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal,
			{
				justValue: 53,
				filter: 54,
				getItems: 55,
				id: 56,
				name: 8,
				container: 0,
				input: 1,
				multiple: 9,
				multiFullItemClearable: 10,
				disabled: 11,
				focused: 2,
				value: 3,
				filterText: 4,
				placeholder: 57,
				placeholderAlwaysShow: 58,
				items: 52,
				label: 12,
				itemFilter: 59,
				groupBy: 60,
				groupFilter: 61,
				groupHeaderSelectable: 62,
				itemId: 13,
				loadOptions: 63,
				containerStyles: 14,
				hasError: 15,
				filterSelectedItems: 64,
				required: 16,
				closeListOnChange: 65,
				createGroupHeaderItem: 66,
				getFilteredItems: 67,
				searchable: 17,
				inputStyles: 18,
				clearable: 68,
				loading: 5,
				listOpen: 6,
				debounce: 69,
				debounceWait: 70,
				hideEmptyState: 19,
				inputAttributes: 71,
				listAutoWidth: 72,
				showChevron: 20,
				listOffset: 73,
				hoverItemIndex: 7,
				floatingConfig: 74,
				class: 21,
				handleClear: 22,
				ariaValues: 75,
				ariaListOpen: 76,
				ariaFocused: 77
			},
			add_css,
			[-1, -1, -1, -1, -1]
		);

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "Select",
			options,
			id: create_fragment.name
		});
	}

	get justValue() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set justValue(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get filter() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set filter(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getItems() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getItems(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get container() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set container(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get input() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set input(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get multiple() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set multiple(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get multiFullItemClearable() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set multiFullItemClearable(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get focused() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set focused(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get filterText() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set filterText(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placeholder() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placeholder(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placeholderAlwaysShow() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placeholderAlwaysShow(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get items() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get itemFilter() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set itemFilter(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get groupBy() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set groupBy(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get groupFilter() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set groupFilter(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get groupHeaderSelectable() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set groupHeaderSelectable(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get itemId() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set itemId(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get loadOptions() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set loadOptions(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get containerStyles() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set containerStyles(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hasError() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hasError(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get filterSelectedItems() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set filterSelectedItems(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get required() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set required(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeListOnChange() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeListOnChange(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get createGroupHeaderItem() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set createGroupHeaderItem(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getFilteredItems() {
		return this.$$.ctx[67];
	}

	set getFilteredItems(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get searchable() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set searchable(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputStyles() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputStyles(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get clearable() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set clearable(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get loading() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set loading(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get listOpen() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set listOpen(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get debounce() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set debounce(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get debounceWait() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set debounceWait(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideEmptyState() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideEmptyState(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputAttributes() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputAttributes(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get listAutoWidth() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set listAutoWidth(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get showChevron() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set showChevron(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get listOffset() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set listOffset(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hoverItemIndex() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hoverItemIndex(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get floatingConfig() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set floatingConfig(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get handleClear() {
		return this.$$.ctx[22];
	}

	set handleClear(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaValues() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaValues(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaListOpen() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaListOpen(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaFocused() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaFocused(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

if (module && module.hot) {}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Select);



/***/ }),

/***/ "./node_modules/svelte-loader/lib/hot-api.js":
/*!***************************************************!*\
  !*** ./node_modules/svelte-loader/lib/hot-api.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyHmr: () => (/* binding */ applyHmr)
/* harmony export */ });
/* harmony import */ var svelte_hmr_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte-hmr/runtime */ "./node_modules/svelte-hmr/runtime/index.js");


// eslint-disable-next-line no-undef
const g = typeof window !== 'undefined' ? window : __webpack_require__.g;

const globalKey =
	typeof Symbol !== 'undefined'
		? Symbol('SVELTE_LOADER_HOT')
		: '__SVELTE_LOADER_HOT';

if (!g[globalKey]) {
	// do updating refs counting to know when a full update has been applied
	let updatingCount = 0;

	const notifyStart = () => {
		updatingCount++;
	};

	const notifyError = reload => err => {
		const errString = (err && err.stack) || err;
		// eslint-disable-next-line no-console
		console.error(
			'[HMR] Failed to accept update (nollup compat mode)',
			errString
		);
		reload();
		notifyEnd();
	};

	const notifyEnd = () => {
		updatingCount--;
		if (updatingCount === 0) {
			// NOTE this message is important for timing in tests
			// eslint-disable-next-line no-console
			console.log('[HMR:Svelte] Up to date');
		}
	};

	g[globalKey] = {
		hotStates: {},
		notifyStart,
		notifyError,
		notifyEnd,
	};
}

const runAcceptHandlers = acceptHandlers => {
	const queue = [...acceptHandlers];
	const next = () => {
		const cur = queue.shift();
		if (cur) {
			return cur(null).then(next);
		} else {
			return Promise.resolve(null);
		}
	};
	return next();
};

const applyHmr = (0,svelte_hmr_runtime__WEBPACK_IMPORTED_MODULE_0__.makeApplyHmr)(args => {
	const { notifyStart, notifyError, notifyEnd } = g[globalKey];
	const { m, reload } = args;

	let acceptHandlers = (m.hot.data && m.hot.data.acceptHandlers) || [];
	let nextAcceptHandlers = [];

	m.hot.dispose(data => {
		data.acceptHandlers = nextAcceptHandlers;
	});

	const dispose = (...args) => m.hot.dispose(...args);

	const accept = handler => {
		if (nextAcceptHandlers.length === 0) {
			m.hot.accept();
		}
		nextAcceptHandlers.push(handler);
	};

	const check = status => {
		if (status === 'ready') {
			notifyStart();
		} else if (status === 'idle') {
			runAcceptHandlers(acceptHandlers)
				.then(notifyEnd)
				.catch(notifyError(reload));
		}
	};

	m.hot.addStatusHandler(check);

	m.hot.dispose(() => {
		m.hot.removeStatusHandler(check);
	});

	const hot = {
		data: m.hot.data,
		dispose,
		accept,
	};

	return { ...args, hot };
});


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/***/ ((module) => {

function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/***/ ((module) => {

function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");
function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return arrayLikeToArray(r);
}
module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/***/ ((module) => {

function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}
module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toPropertyKey = __webpack_require__(/*! ./toPropertyKey.js */ "./node_modules/@babel/runtime/helpers/toPropertyKey.js");
function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArray.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArray.js ***!
  \****************************************************************/
/***/ ((module) => {

function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*********************************************************************/
/***/ ((module) => {

function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/***/ ((module) => {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableSpread.js ***!
  \******************************************************************/
/***/ ((module) => {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/regeneratorRuntime.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/regeneratorRuntime.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = (__webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/typeof.js")["default"]);
function _regeneratorRuntime() {
  "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
    return e;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function define(t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function value(t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(_typeof(e) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function complete(t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function finish(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    "catch": function _catch(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles.js */ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js");
var iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit.js */ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js");
var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");
var nonIterableRest = __webpack_require__(/*! ./nonIterableRest.js */ "./node_modules/@babel/runtime/helpers/nonIterableRest.js");
function _slicedToArray(r, e) {
  return arrayWithHoles(r) || iterableToArrayLimit(r, e) || unsupportedIterableToArray(r, e) || nonIterableRest();
}
module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toConsumableArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toConsumableArray.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayWithoutHoles = __webpack_require__(/*! ./arrayWithoutHoles.js */ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js");
var iterableToArray = __webpack_require__(/*! ./iterableToArray.js */ "./node_modules/@babel/runtime/helpers/iterableToArray.js");
var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");
var nonIterableSpread = __webpack_require__(/*! ./nonIterableSpread.js */ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js");
function _toConsumableArray(r) {
  return arrayWithoutHoles(r) || iterableToArray(r) || unsupportedIterableToArray(r) || nonIterableSpread();
}
module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toPrimitive.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toPrimitive.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = (__webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/typeof.js")["default"]);
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toPropertyKey.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toPropertyKey.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = (__webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/typeof.js")["default"]);
var toPrimitive = __webpack_require__(/*! ./toPrimitive.js */ "./node_modules/@babel/runtime/helpers/toPrimitive.js");
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/***/ ((module) => {

function _typeof(o) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(o);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? arrayLikeToArray(r, a) : void 0;
  }
}
module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// TODO(Babel 8): Remove this file.

var runtime = __webpack_require__(/*! ../helpers/regeneratorRuntime */ "./node_modules/@babel/runtime/helpers/regeneratorRuntime.js")();
module.exports = runtime;

// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}


/***/ }),

/***/ "./node_modules/svelte-floating-ui/index.js":
/*!**************************************************!*\
  !*** ./node_modules/svelte-floating-ui/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arrow: () => (/* binding */ arrow),
/* harmony export */   createFloatingActions: () => (/* binding */ createFloatingActions)
/* harmony export */ });
/* harmony import */ var _floating_ui_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @floating-ui/core */ "./node_modules/@floating-ui/core/dist/floating-ui.core.umd.js");
/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/dom */ "./node_modules/@floating-ui/dom/dist/floating-ui.dom.umd.js");
/* harmony import */ var svelte_store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/store */ "./node_modules/svelte/store/index.mjs");
/* harmony import */ var svelte__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte */ "./node_modules/svelte/index.mjs");
//@ts-ignore




function createFloatingActions(initOptions) {
    let referenceElement;
    let floatingElement;
    const defaultOptions = {
        autoUpdate: true
    };
    let options = initOptions;
    const getOptions = (mixin) => {
        return { ...defaultOptions, ...(initOptions || {}), ...(mixin || {}) };
    };
    const updatePosition = (updateOptions) => {
        if (referenceElement && floatingElement) {
            options = getOptions(updateOptions);
            (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.computePosition)(referenceElement, floatingElement, options)
                .then(v => {
                Object.assign(floatingElement.style, {
                    position: v.strategy,
                    left: `${v.x}px`,
                    top: `${v.y}px`,
                });
                options?.onComputed && options.onComputed(v);
            });
        }
    };
    const referenceAction = node => {
        if ('subscribe' in node) {
            setupVirtualElementObserver(node);
            return {};
        }
        else {
            referenceElement = node;
            updatePosition();
        }
    };
    const contentAction = (node, contentOptions) => {
        let autoUpdateDestroy;
        floatingElement = node;
        options = getOptions(contentOptions);
        setTimeout(() => updatePosition(contentOptions), 0); //tick doesn't work
        updatePosition(contentOptions);
        const destroyAutoUpdate = () => {
            if (autoUpdateDestroy) {
                autoUpdateDestroy();
                autoUpdateDestroy = undefined;
            }
        };
        const initAutoUpdate = ({ autoUpdate } = options || {}) => {
            destroyAutoUpdate();
            if (autoUpdate !== false) {
                return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.autoUpdate)(referenceElement, floatingElement, () => updatePosition(options), (autoUpdate === true ? {} : autoUpdate));
            }
            return;
        };
        autoUpdateDestroy = initAutoUpdate();
        return {
            update(contentOptions) {
                updatePosition(contentOptions);
                autoUpdateDestroy = initAutoUpdate(contentOptions);
            },
            destroy() {
                destroyAutoUpdate();
            }
        };
    };
    const setupVirtualElementObserver = (node) => {
        const unsubscribe = node.subscribe(($node) => {
            if (referenceElement === undefined) {
                referenceElement = $node;
                updatePosition();
            }
            else {
                // Preserve the reference to the virtual element.
                Object.assign(referenceElement, $node);
                updatePosition();
            }
        });
        (0,svelte__WEBPACK_IMPORTED_MODULE_1__.onDestroy)(unsubscribe);
    };
    return [
        referenceAction,
        contentAction,
        updatePosition
    ];
}
function arrow(options) {
    return {
        name: "arrow",
        options,
        fn(args) {
            const element = (0,svelte_store__WEBPACK_IMPORTED_MODULE_0__.get)(options.element);
            if (element) {
                return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_3__.arrow)({
                    element,
                    padding: options.padding
                }).fn(args);
            }
            return {};
        }
    };
}


/***/ }),

/***/ "./node_modules/svelte-select/filter.js":
/*!**********************************************!*\
  !*** ./node_modules/svelte-select/filter.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ filter)
/* harmony export */ });
function filter({
    loadOptions,
    filterText,
    items,
    multiple,
    value,
    itemId,
    groupBy,
    filterSelectedItems,
    itemFilter,
    convertStringItemsToObjects,
    filterGroupedItems,
    label,
}) {
    if (items && loadOptions) return items;
    if (!items) return [];

    if (items && items.length > 0 && typeof items[0] !== 'object') {
        items = convertStringItemsToObjects(items);
    }

    let filterResults = items.filter((item) => {
        let matchesFilter = itemFilter(item[label], filterText, item);
        if (matchesFilter && multiple && value?.length) {
            matchesFilter = !value.some((x) => {
                return filterSelectedItems ? x[itemId] === item[itemId] : false;
            });
        }

        return matchesFilter;
    });

    if (groupBy) {
        filterResults = filterGroupedItems(filterResults);
    }

    return filterResults;
}


/***/ }),

/***/ "./node_modules/svelte-select/get-items.js":
/*!*************************************************!*\
  !*** ./node_modules/svelte-select/get-items.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getItems)
/* harmony export */ });
async function getItems({ dispatch, loadOptions, convertStringItemsToObjects, filterText }) {
    let res = await loadOptions(filterText).catch((err) => {
        console.warn('svelte-select loadOptions error :>> ', err);
        dispatch('error', { type: 'loadOptions', details: err });
    });

    if (res && !res.cancelled) {        
        if (res) {
            if (res && res.length > 0 && typeof res[0] !== 'object') {
                res = convertStringItemsToObjects(res);
            }
            
            dispatch('loaded', { items: res });
        } else {
            res = [];
        }

        return {
            filteredItems: res,
            loading: false,
            focused: true,
            listOpen: true,
        };
    }
}


/***/ }),

/***/ "./node_modules/svelte-select/index.js":
/*!*********************************************!*\
  !*** ./node_modules/svelte-select/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _Select_svelte__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _Select_svelte__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Select.svelte */ "./node_modules/svelte-select/Select.svelte");



/***/ }),

/***/ "./node_modules/svelte/easing/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/svelte/easing/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   backIn: () => (/* binding */ backIn),
/* harmony export */   backInOut: () => (/* binding */ backInOut),
/* harmony export */   backOut: () => (/* binding */ backOut),
/* harmony export */   bounceIn: () => (/* binding */ bounceIn),
/* harmony export */   bounceInOut: () => (/* binding */ bounceInOut),
/* harmony export */   bounceOut: () => (/* binding */ bounceOut),
/* harmony export */   circIn: () => (/* binding */ circIn),
/* harmony export */   circInOut: () => (/* binding */ circInOut),
/* harmony export */   circOut: () => (/* binding */ circOut),
/* harmony export */   cubicIn: () => (/* binding */ cubicIn),
/* harmony export */   cubicInOut: () => (/* binding */ cubicInOut),
/* harmony export */   cubicOut: () => (/* binding */ cubicOut),
/* harmony export */   elasticIn: () => (/* binding */ elasticIn),
/* harmony export */   elasticInOut: () => (/* binding */ elasticInOut),
/* harmony export */   elasticOut: () => (/* binding */ elasticOut),
/* harmony export */   expoIn: () => (/* binding */ expoIn),
/* harmony export */   expoInOut: () => (/* binding */ expoInOut),
/* harmony export */   expoOut: () => (/* binding */ expoOut),
/* harmony export */   linear: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.identity),
/* harmony export */   quadIn: () => (/* binding */ quadIn),
/* harmony export */   quadInOut: () => (/* binding */ quadInOut),
/* harmony export */   quadOut: () => (/* binding */ quadOut),
/* harmony export */   quartIn: () => (/* binding */ quartIn),
/* harmony export */   quartInOut: () => (/* binding */ quartInOut),
/* harmony export */   quartOut: () => (/* binding */ quartOut),
/* harmony export */   quintIn: () => (/* binding */ quintIn),
/* harmony export */   quintInOut: () => (/* binding */ quintInOut),
/* harmony export */   quintOut: () => (/* binding */ quintOut),
/* harmony export */   sineIn: () => (/* binding */ sineIn),
/* harmony export */   sineInOut: () => (/* binding */ sineInOut),
/* harmony export */   sineOut: () => (/* binding */ sineOut)
/* harmony export */ });
/* harmony import */ var _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/index.mjs */ "./node_modules/svelte/internal/index.mjs");


/*
Adapted from https://github.com/mattdesl
Distributed under MIT License https://github.com/mattdesl/eases/blob/master/LICENSE.md
*/
function backInOut(t) {
    const s = 1.70158 * 1.525;
    if ((t *= 2) < 1)
        return 0.5 * (t * t * ((s + 1) * t - s));
    return 0.5 * ((t -= 2) * t * ((s + 1) * t + s) + 2);
}
function backIn(t) {
    const s = 1.70158;
    return t * t * ((s + 1) * t - s);
}
function backOut(t) {
    const s = 1.70158;
    return --t * t * ((s + 1) * t + s) + 1;
}
function bounceOut(t) {
    const a = 4.0 / 11.0;
    const b = 8.0 / 11.0;
    const c = 9.0 / 10.0;
    const ca = 4356.0 / 361.0;
    const cb = 35442.0 / 1805.0;
    const cc = 16061.0 / 1805.0;
    const t2 = t * t;
    return t < a
        ? 7.5625 * t2
        : t < b
            ? 9.075 * t2 - 9.9 * t + 3.4
            : t < c
                ? ca * t2 - cb * t + cc
                : 10.8 * t * t - 20.52 * t + 10.72;
}
function bounceInOut(t) {
    return t < 0.5
        ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))
        : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;
}
function bounceIn(t) {
    return 1.0 - bounceOut(1.0 - t);
}
function circInOut(t) {
    if ((t *= 2) < 1)
        return -0.5 * (Math.sqrt(1 - t * t) - 1);
    return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
}
function circIn(t) {
    return 1.0 - Math.sqrt(1.0 - t * t);
}
function circOut(t) {
    return Math.sqrt(1 - --t * t);
}
function cubicInOut(t) {
    return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0;
}
function cubicIn(t) {
    return t * t * t;
}
function cubicOut(t) {
    const f = t - 1.0;
    return f * f * f + 1.0;
}
function elasticInOut(t) {
    return t < 0.5
        ? 0.5 *
            Math.sin(((+13.0 * Math.PI) / 2) * 2.0 * t) *
            Math.pow(2.0, 10.0 * (2.0 * t - 1.0))
        : 0.5 *
            Math.sin(((-13.0 * Math.PI) / 2) * (2.0 * t - 1.0 + 1.0)) *
            Math.pow(2.0, -10.0 * (2.0 * t - 1.0)) +
            1.0;
}
function elasticIn(t) {
    return Math.sin((13.0 * t * Math.PI) / 2) * Math.pow(2.0, 10.0 * (t - 1.0));
}
function elasticOut(t) {
    return (Math.sin((-13.0 * (t + 1.0) * Math.PI) / 2) * Math.pow(2.0, -10.0 * t) + 1.0);
}
function expoInOut(t) {
    return t === 0.0 || t === 1.0
        ? t
        : t < 0.5
            ? +0.5 * Math.pow(2.0, 20.0 * t - 10.0)
            : -0.5 * Math.pow(2.0, 10.0 - t * 20.0) + 1.0;
}
function expoIn(t) {
    return t === 0.0 ? t : Math.pow(2.0, 10.0 * (t - 1.0));
}
function expoOut(t) {
    return t === 1.0 ? t : 1.0 - Math.pow(2.0, -10.0 * t);
}
function quadInOut(t) {
    t /= 0.5;
    if (t < 1)
        return 0.5 * t * t;
    t--;
    return -0.5 * (t * (t - 2) - 1);
}
function quadIn(t) {
    return t * t;
}
function quadOut(t) {
    return -t * (t - 2.0);
}
function quartInOut(t) {
    return t < 0.5
        ? +8.0 * Math.pow(t, 4.0)
        : -8.0 * Math.pow(t - 1.0, 4.0) + 1.0;
}
function quartIn(t) {
    return Math.pow(t, 4.0);
}
function quartOut(t) {
    return Math.pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;
}
function quintInOut(t) {
    if ((t *= 2) < 1)
        return 0.5 * t * t * t * t * t;
    return 0.5 * ((t -= 2) * t * t * t * t + 2);
}
function quintIn(t) {
    return t * t * t * t * t;
}
function quintOut(t) {
    return --t * t * t * t * t + 1;
}
function sineInOut(t) {
    return -0.5 * (Math.cos(Math.PI * t) - 1);
}
function sineIn(t) {
    const v = Math.cos(t * Math.PI * 0.5);
    if (Math.abs(v) < 1e-14)
        return 1;
    else
        return 1 - v;
}
function sineOut(t) {
    return Math.sin((t * Math.PI) / 2);
}




/***/ }),

/***/ "./node_modules/svelte/index.mjs":
/*!***************************************!*\
  !*** ./node_modules/svelte/index.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SvelteComponent: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev),
/* harmony export */   SvelteComponentTyped: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentTyped),
/* harmony export */   afterUpdate: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.afterUpdate),
/* harmony export */   beforeUpdate: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.beforeUpdate),
/* harmony export */   createEventDispatcher: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.createEventDispatcher),
/* harmony export */   getAllContexts: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.getAllContexts),
/* harmony export */   getContext: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.getContext),
/* harmony export */   hasContext: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.hasContext),
/* harmony export */   onDestroy: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.onDestroy),
/* harmony export */   onMount: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.onMount),
/* harmony export */   setContext: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.setContext),
/* harmony export */   tick: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.tick)
/* harmony export */ });
/* harmony import */ var _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/index.mjs */ "./node_modules/svelte/internal/index.mjs");



/***/ }),

/***/ "./node_modules/svelte/internal/index.mjs":
/*!************************************************!*\
  !*** ./node_modules/svelte/internal/index.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HtmlTag: () => (/* binding */ HtmlTag),
/* harmony export */   HtmlTagHydration: () => (/* binding */ HtmlTagHydration),
/* harmony export */   ResizeObserverSingleton: () => (/* binding */ ResizeObserverSingleton),
/* harmony export */   SvelteComponent: () => (/* binding */ SvelteComponent),
/* harmony export */   SvelteComponentDev: () => (/* binding */ SvelteComponentDev),
/* harmony export */   SvelteComponentTyped: () => (/* binding */ SvelteComponentTyped),
/* harmony export */   SvelteElement: () => (/* binding */ SvelteElement),
/* harmony export */   action_destroyer: () => (/* binding */ action_destroyer),
/* harmony export */   add_attribute: () => (/* binding */ add_attribute),
/* harmony export */   add_classes: () => (/* binding */ add_classes),
/* harmony export */   add_flush_callback: () => (/* binding */ add_flush_callback),
/* harmony export */   add_iframe_resize_listener: () => (/* binding */ add_iframe_resize_listener),
/* harmony export */   add_location: () => (/* binding */ add_location),
/* harmony export */   add_render_callback: () => (/* binding */ add_render_callback),
/* harmony export */   add_styles: () => (/* binding */ add_styles),
/* harmony export */   add_transform: () => (/* binding */ add_transform),
/* harmony export */   afterUpdate: () => (/* binding */ afterUpdate),
/* harmony export */   append: () => (/* binding */ append),
/* harmony export */   append_dev: () => (/* binding */ append_dev),
/* harmony export */   append_empty_stylesheet: () => (/* binding */ append_empty_stylesheet),
/* harmony export */   append_hydration: () => (/* binding */ append_hydration),
/* harmony export */   append_hydration_dev: () => (/* binding */ append_hydration_dev),
/* harmony export */   append_styles: () => (/* binding */ append_styles),
/* harmony export */   assign: () => (/* binding */ assign),
/* harmony export */   attr: () => (/* binding */ attr),
/* harmony export */   attr_dev: () => (/* binding */ attr_dev),
/* harmony export */   attribute_to_object: () => (/* binding */ attribute_to_object),
/* harmony export */   beforeUpdate: () => (/* binding */ beforeUpdate),
/* harmony export */   bind: () => (/* binding */ bind),
/* harmony export */   binding_callbacks: () => (/* binding */ binding_callbacks),
/* harmony export */   blank_object: () => (/* binding */ blank_object),
/* harmony export */   bubble: () => (/* binding */ bubble),
/* harmony export */   check_outros: () => (/* binding */ check_outros),
/* harmony export */   children: () => (/* binding */ children),
/* harmony export */   claim_comment: () => (/* binding */ claim_comment),
/* harmony export */   claim_component: () => (/* binding */ claim_component),
/* harmony export */   claim_element: () => (/* binding */ claim_element),
/* harmony export */   claim_html_tag: () => (/* binding */ claim_html_tag),
/* harmony export */   claim_space: () => (/* binding */ claim_space),
/* harmony export */   claim_svg_element: () => (/* binding */ claim_svg_element),
/* harmony export */   claim_text: () => (/* binding */ claim_text),
/* harmony export */   clear_loops: () => (/* binding */ clear_loops),
/* harmony export */   comment: () => (/* binding */ comment),
/* harmony export */   component_subscribe: () => (/* binding */ component_subscribe),
/* harmony export */   compute_rest_props: () => (/* binding */ compute_rest_props),
/* harmony export */   compute_slots: () => (/* binding */ compute_slots),
/* harmony export */   construct_svelte_component: () => (/* binding */ construct_svelte_component),
/* harmony export */   construct_svelte_component_dev: () => (/* binding */ construct_svelte_component_dev),
/* harmony export */   contenteditable_truthy_values: () => (/* binding */ contenteditable_truthy_values),
/* harmony export */   createEventDispatcher: () => (/* binding */ createEventDispatcher),
/* harmony export */   create_animation: () => (/* binding */ create_animation),
/* harmony export */   create_bidirectional_transition: () => (/* binding */ create_bidirectional_transition),
/* harmony export */   create_component: () => (/* binding */ create_component),
/* harmony export */   create_in_transition: () => (/* binding */ create_in_transition),
/* harmony export */   create_out_transition: () => (/* binding */ create_out_transition),
/* harmony export */   create_slot: () => (/* binding */ create_slot),
/* harmony export */   create_ssr_component: () => (/* binding */ create_ssr_component),
/* harmony export */   current_component: () => (/* binding */ current_component),
/* harmony export */   custom_event: () => (/* binding */ custom_event),
/* harmony export */   dataset_dev: () => (/* binding */ dataset_dev),
/* harmony export */   debug: () => (/* binding */ debug),
/* harmony export */   destroy_block: () => (/* binding */ destroy_block),
/* harmony export */   destroy_component: () => (/* binding */ destroy_component),
/* harmony export */   destroy_each: () => (/* binding */ destroy_each),
/* harmony export */   detach: () => (/* binding */ detach),
/* harmony export */   detach_after_dev: () => (/* binding */ detach_after_dev),
/* harmony export */   detach_before_dev: () => (/* binding */ detach_before_dev),
/* harmony export */   detach_between_dev: () => (/* binding */ detach_between_dev),
/* harmony export */   detach_dev: () => (/* binding */ detach_dev),
/* harmony export */   dirty_components: () => (/* binding */ dirty_components),
/* harmony export */   dispatch_dev: () => (/* binding */ dispatch_dev),
/* harmony export */   each: () => (/* binding */ each),
/* harmony export */   element: () => (/* binding */ element),
/* harmony export */   element_is: () => (/* binding */ element_is),
/* harmony export */   empty: () => (/* binding */ empty),
/* harmony export */   end_hydrating: () => (/* binding */ end_hydrating),
/* harmony export */   escape: () => (/* binding */ escape),
/* harmony export */   escape_attribute_value: () => (/* binding */ escape_attribute_value),
/* harmony export */   escape_object: () => (/* binding */ escape_object),
/* harmony export */   exclude_internal_props: () => (/* binding */ exclude_internal_props),
/* harmony export */   fix_and_destroy_block: () => (/* binding */ fix_and_destroy_block),
/* harmony export */   fix_and_outro_and_destroy_block: () => (/* binding */ fix_and_outro_and_destroy_block),
/* harmony export */   fix_position: () => (/* binding */ fix_position),
/* harmony export */   flush: () => (/* binding */ flush),
/* harmony export */   flush_render_callbacks: () => (/* binding */ flush_render_callbacks),
/* harmony export */   getAllContexts: () => (/* binding */ getAllContexts),
/* harmony export */   getContext: () => (/* binding */ getContext),
/* harmony export */   get_all_dirty_from_scope: () => (/* binding */ get_all_dirty_from_scope),
/* harmony export */   get_binding_group_value: () => (/* binding */ get_binding_group_value),
/* harmony export */   get_current_component: () => (/* binding */ get_current_component),
/* harmony export */   get_custom_elements_slots: () => (/* binding */ get_custom_elements_slots),
/* harmony export */   get_root_for_style: () => (/* binding */ get_root_for_style),
/* harmony export */   get_slot_changes: () => (/* binding */ get_slot_changes),
/* harmony export */   get_spread_object: () => (/* binding */ get_spread_object),
/* harmony export */   get_spread_update: () => (/* binding */ get_spread_update),
/* harmony export */   get_store_value: () => (/* binding */ get_store_value),
/* harmony export */   globals: () => (/* binding */ globals),
/* harmony export */   group_outros: () => (/* binding */ group_outros),
/* harmony export */   handle_promise: () => (/* binding */ handle_promise),
/* harmony export */   hasContext: () => (/* binding */ hasContext),
/* harmony export */   has_prop: () => (/* binding */ has_prop),
/* harmony export */   head_selector: () => (/* binding */ head_selector),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   init_binding_group: () => (/* binding */ init_binding_group),
/* harmony export */   init_binding_group_dynamic: () => (/* binding */ init_binding_group_dynamic),
/* harmony export */   insert: () => (/* binding */ insert),
/* harmony export */   insert_dev: () => (/* binding */ insert_dev),
/* harmony export */   insert_hydration: () => (/* binding */ insert_hydration),
/* harmony export */   insert_hydration_dev: () => (/* binding */ insert_hydration_dev),
/* harmony export */   intros: () => (/* binding */ intros),
/* harmony export */   invalid_attribute_name_character: () => (/* binding */ invalid_attribute_name_character),
/* harmony export */   is_client: () => (/* binding */ is_client),
/* harmony export */   is_crossorigin: () => (/* binding */ is_crossorigin),
/* harmony export */   is_empty: () => (/* binding */ is_empty),
/* harmony export */   is_function: () => (/* binding */ is_function),
/* harmony export */   is_promise: () => (/* binding */ is_promise),
/* harmony export */   is_void: () => (/* binding */ is_void),
/* harmony export */   listen: () => (/* binding */ listen),
/* harmony export */   listen_dev: () => (/* binding */ listen_dev),
/* harmony export */   loop: () => (/* binding */ loop),
/* harmony export */   loop_guard: () => (/* binding */ loop_guard),
/* harmony export */   merge_ssr_styles: () => (/* binding */ merge_ssr_styles),
/* harmony export */   missing_component: () => (/* binding */ missing_component),
/* harmony export */   mount_component: () => (/* binding */ mount_component),
/* harmony export */   noop: () => (/* binding */ noop),
/* harmony export */   not_equal: () => (/* binding */ not_equal),
/* harmony export */   now: () => (/* binding */ now),
/* harmony export */   null_to_empty: () => (/* binding */ null_to_empty),
/* harmony export */   object_without_properties: () => (/* binding */ object_without_properties),
/* harmony export */   onDestroy: () => (/* binding */ onDestroy),
/* harmony export */   onMount: () => (/* binding */ onMount),
/* harmony export */   once: () => (/* binding */ once),
/* harmony export */   outro_and_destroy_block: () => (/* binding */ outro_and_destroy_block),
/* harmony export */   prevent_default: () => (/* binding */ prevent_default),
/* harmony export */   prop_dev: () => (/* binding */ prop_dev),
/* harmony export */   query_selector_all: () => (/* binding */ query_selector_all),
/* harmony export */   raf: () => (/* binding */ raf),
/* harmony export */   resize_observer_border_box: () => (/* binding */ resize_observer_border_box),
/* harmony export */   resize_observer_content_box: () => (/* binding */ resize_observer_content_box),
/* harmony export */   resize_observer_device_pixel_content_box: () => (/* binding */ resize_observer_device_pixel_content_box),
/* harmony export */   run: () => (/* binding */ run),
/* harmony export */   run_all: () => (/* binding */ run_all),
/* harmony export */   safe_not_equal: () => (/* binding */ safe_not_equal),
/* harmony export */   schedule_update: () => (/* binding */ schedule_update),
/* harmony export */   select_multiple_value: () => (/* binding */ select_multiple_value),
/* harmony export */   select_option: () => (/* binding */ select_option),
/* harmony export */   select_options: () => (/* binding */ select_options),
/* harmony export */   select_value: () => (/* binding */ select_value),
/* harmony export */   self: () => (/* binding */ self),
/* harmony export */   setContext: () => (/* binding */ setContext),
/* harmony export */   set_attributes: () => (/* binding */ set_attributes),
/* harmony export */   set_current_component: () => (/* binding */ set_current_component),
/* harmony export */   set_custom_element_data: () => (/* binding */ set_custom_element_data),
/* harmony export */   set_custom_element_data_map: () => (/* binding */ set_custom_element_data_map),
/* harmony export */   set_data: () => (/* binding */ set_data),
/* harmony export */   set_data_contenteditable: () => (/* binding */ set_data_contenteditable),
/* harmony export */   set_data_contenteditable_dev: () => (/* binding */ set_data_contenteditable_dev),
/* harmony export */   set_data_dev: () => (/* binding */ set_data_dev),
/* harmony export */   set_data_maybe_contenteditable: () => (/* binding */ set_data_maybe_contenteditable),
/* harmony export */   set_data_maybe_contenteditable_dev: () => (/* binding */ set_data_maybe_contenteditable_dev),
/* harmony export */   set_dynamic_element_data: () => (/* binding */ set_dynamic_element_data),
/* harmony export */   set_input_type: () => (/* binding */ set_input_type),
/* harmony export */   set_input_value: () => (/* binding */ set_input_value),
/* harmony export */   set_now: () => (/* binding */ set_now),
/* harmony export */   set_raf: () => (/* binding */ set_raf),
/* harmony export */   set_store_value: () => (/* binding */ set_store_value),
/* harmony export */   set_style: () => (/* binding */ set_style),
/* harmony export */   set_svg_attributes: () => (/* binding */ set_svg_attributes),
/* harmony export */   space: () => (/* binding */ space),
/* harmony export */   split_css_unit: () => (/* binding */ split_css_unit),
/* harmony export */   spread: () => (/* binding */ spread),
/* harmony export */   src_url_equal: () => (/* binding */ src_url_equal),
/* harmony export */   start_hydrating: () => (/* binding */ start_hydrating),
/* harmony export */   stop_immediate_propagation: () => (/* binding */ stop_immediate_propagation),
/* harmony export */   stop_propagation: () => (/* binding */ stop_propagation),
/* harmony export */   subscribe: () => (/* binding */ subscribe),
/* harmony export */   svg_element: () => (/* binding */ svg_element),
/* harmony export */   text: () => (/* binding */ text),
/* harmony export */   tick: () => (/* binding */ tick),
/* harmony export */   time_ranges_to_array: () => (/* binding */ time_ranges_to_array),
/* harmony export */   to_number: () => (/* binding */ to_number),
/* harmony export */   toggle_class: () => (/* binding */ toggle_class),
/* harmony export */   transition_in: () => (/* binding */ transition_in),
/* harmony export */   transition_out: () => (/* binding */ transition_out),
/* harmony export */   trusted: () => (/* binding */ trusted),
/* harmony export */   update_await_block_branch: () => (/* binding */ update_await_block_branch),
/* harmony export */   update_keyed_each: () => (/* binding */ update_keyed_each),
/* harmony export */   update_slot: () => (/* binding */ update_slot),
/* harmony export */   update_slot_base: () => (/* binding */ update_slot_base),
/* harmony export */   validate_component: () => (/* binding */ validate_component),
/* harmony export */   validate_dynamic_element: () => (/* binding */ validate_dynamic_element),
/* harmony export */   validate_each_argument: () => (/* binding */ validate_each_argument),
/* harmony export */   validate_each_keys: () => (/* binding */ validate_each_keys),
/* harmony export */   validate_slots: () => (/* binding */ validate_slots),
/* harmony export */   validate_store: () => (/* binding */ validate_store),
/* harmony export */   validate_void_dynamic_element: () => (/* binding */ validate_void_dynamic_element),
/* harmony export */   xlink_attr: () => (/* binding */ xlink_attr)
/* harmony export */ });
function noop() { }
const identity = x => x;
function assign(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
// Adapted from https://github.com/then/is-promise/blob/master/index.js
// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE
function is_promise(value) {
    return !!value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function';
}
function add_location(element, file, line, column, char) {
    element.__svelte_meta = {
        loc: { file, line, column, char }
    };
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
let src_url_equal_anchor;
function src_url_equal(element_src, url) {
    if (!src_url_equal_anchor) {
        src_url_equal_anchor = document.createElement('a');
    }
    src_url_equal_anchor.href = url;
    return element_src === src_url_equal_anchor.href;
}
function not_equal(a, b) {
    return a != a ? b == b : a !== b;
}
function is_empty(obj) {
    return Object.keys(obj).length === 0;
}
function validate_store(store, name) {
    if (store != null && typeof store.subscribe !== 'function') {
        throw new Error(`'${name}' is not a store with a 'subscribe' method`);
    }
}
function subscribe(store, ...callbacks) {
    if (store == null) {
        return noop;
    }
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
    let value;
    subscribe(store, _ => value = _)();
    return value;
}
function component_subscribe(component, store, callback) {
    component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
    }
}
function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn
        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
        : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty === undefined) {
            return lets;
        }
        if (typeof lets === 'object') {
            const merged = [];
            const len = Math.max($$scope.dirty.length, lets.length);
            for (let i = 0; i < len; i += 1) {
                merged[i] = $$scope.dirty[i] | lets[i];
            }
            return merged;
        }
        return $$scope.dirty | lets;
    }
    return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
    if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
    }
}
function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);
}
function get_all_dirty_from_scope($$scope) {
    if ($$scope.ctx.length > 32) {
        const dirty = [];
        const length = $$scope.ctx.length / 32;
        for (let i = 0; i < length; i++) {
            dirty[i] = -1;
        }
        return dirty;
    }
    return -1;
}
function exclude_internal_props(props) {
    const result = {};
    for (const k in props)
        if (k[0] !== '$')
            result[k] = props[k];
    return result;
}
function compute_rest_props(props, keys) {
    const rest = {};
    keys = new Set(keys);
    for (const k in props)
        if (!keys.has(k) && k[0] !== '$')
            rest[k] = props[k];
    return rest;
}
function compute_slots(slots) {
    const result = {};
    for (const key in slots) {
        result[key] = true;
    }
    return result;
}
function once(fn) {
    let ran = false;
    return function (...args) {
        if (ran)
            return;
        ran = true;
        fn.call(this, ...args);
    };
}
function null_to_empty(value) {
    return value == null ? '' : value;
}
function set_store_value(store, ret, value) {
    store.set(value);
    return ret;
}
const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
function action_destroyer(action_result) {
    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}
function split_css_unit(value) {
    const split = typeof value === 'string' && value.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
    return split ? [parseFloat(split[1]), split[2] || 'px'] : [value, 'px'];
}
const contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];

const is_client = typeof window !== 'undefined';
let now = is_client
    ? () => window.performance.now()
    : () => Date.now();
let raf = is_client ? cb => requestAnimationFrame(cb) : noop;
// used internally for testing
function set_now(fn) {
    now = fn;
}
function set_raf(fn) {
    raf = fn;
}

const tasks = new Set();
function run_tasks(now) {
    tasks.forEach(task => {
        if (!task.c(now)) {
            tasks.delete(task);
            task.f();
        }
    });
    if (tasks.size !== 0)
        raf(run_tasks);
}
/**
 * For testing purposes only!
 */
function clear_loops() {
    tasks.clear();
}
/**
 * Creates a new task that runs on each raf frame
 * until it returns a falsy value or is aborted
 */
function loop(callback) {
    let task;
    if (tasks.size === 0)
        raf(run_tasks);
    return {
        promise: new Promise(fulfill => {
            tasks.add(task = { c: callback, f: fulfill });
        }),
        abort() {
            tasks.delete(task);
        }
    };
}

const globals = (typeof window !== 'undefined'
    ? window
    : typeof globalThis !== 'undefined'
        ? globalThis
        : global);

/**
 * Resize observer singleton.
 * One listener per element only!
 * https://groups.google.com/a/chromium.org/g/blink-dev/c/z6ienONUb5A/m/F5-VcUZtBAAJ
 */
class ResizeObserverSingleton {
    constructor(options) {
        this.options = options;
        this._listeners = 'WeakMap' in globals ? new WeakMap() : undefined;
    }
    observe(element, listener) {
        this._listeners.set(element, listener);
        this._getObserver().observe(element, this.options);
        return () => {
            this._listeners.delete(element);
            this._observer.unobserve(element); // this line can probably be removed
        };
    }
    _getObserver() {
        var _a;
        return (_a = this._observer) !== null && _a !== void 0 ? _a : (this._observer = new ResizeObserver((entries) => {
            var _a;
            for (const entry of entries) {
                ResizeObserverSingleton.entries.set(entry.target, entry);
                (_a = this._listeners.get(entry.target)) === null || _a === void 0 ? void 0 : _a(entry);
            }
        }));
    }
}
// Needs to be written like this to pass the tree-shake-test
ResizeObserverSingleton.entries = 'WeakMap' in globals ? new WeakMap() : undefined;

// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM
// at the end of hydration without touching the remaining nodes.
let is_hydrating = false;
function start_hydrating() {
    is_hydrating = true;
}
function end_hydrating() {
    is_hydrating = false;
}
function upper_bound(low, high, key, value) {
    // Return first index of value larger than input value in the range [low, high)
    while (low < high) {
        const mid = low + ((high - low) >> 1);
        if (key(mid) <= value) {
            low = mid + 1;
        }
        else {
            high = mid;
        }
    }
    return low;
}
function init_hydrate(target) {
    if (target.hydrate_init)
        return;
    target.hydrate_init = true;
    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>
    let children = target.childNodes;
    // If target is <head>, there may be children without claim_order
    if (target.nodeName === 'HEAD') {
        const myChildren = [];
        for (let i = 0; i < children.length; i++) {
            const node = children[i];
            if (node.claim_order !== undefined) {
                myChildren.push(node);
            }
        }
        children = myChildren;
    }
    /*
    * Reorder claimed children optimally.
    * We can reorder claimed children optimally by finding the longest subsequence of
    * nodes that are already claimed in order and only moving the rest. The longest
    * subsequence of nodes that are claimed in order can be found by
    * computing the longest increasing subsequence of .claim_order values.
    *
    * This algorithm is optimal in generating the least amount of reorder operations
    * possible.
    *
    * Proof:
    * We know that, given a set of reordering operations, the nodes that do not move
    * always form an increasing subsequence, since they do not move among each other
    * meaning that they must be already ordered among each other. Thus, the maximal
    * set of nodes that do not move form a longest increasing subsequence.
    */
    // Compute longest increasing subsequence
    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j
    const m = new Int32Array(children.length + 1);
    // Predecessor indices + 1
    const p = new Int32Array(children.length);
    m[0] = -1;
    let longest = 0;
    for (let i = 0; i < children.length; i++) {
        const current = children[i].claim_order;
        // Find the largest subsequence length such that it ends in a value less than our current value
        // upper_bound returns first greater value, so we subtract one
        // with fast path for when we are on the current longest subsequence
        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;
        p[i] = m[seqLen] + 1;
        const newLen = seqLen + 1;
        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.
        m[newLen] = i;
        longest = Math.max(newLen, longest);
    }
    // The longest increasing subsequence of nodes (initially reversed)
    const lis = [];
    // The rest of the nodes, nodes that will be moved
    const toMove = [];
    let last = children.length - 1;
    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {
        lis.push(children[cur - 1]);
        for (; last >= cur; last--) {
            toMove.push(children[last]);
        }
        last--;
    }
    for (; last >= 0; last--) {
        toMove.push(children[last]);
    }
    lis.reverse();
    // We sort the nodes being moved to guarantee that their insertion order matches the claim order
    toMove.sort((a, b) => a.claim_order - b.claim_order);
    // Finally, we move the nodes
    for (let i = 0, j = 0; i < toMove.length; i++) {
        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {
            j++;
        }
        const anchor = j < lis.length ? lis[j] : null;
        target.insertBefore(toMove[i], anchor);
    }
}
function append(target, node) {
    target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
    const append_styles_to = get_root_for_style(target);
    if (!append_styles_to.getElementById(style_sheet_id)) {
        const style = element('style');
        style.id = style_sheet_id;
        style.textContent = styles;
        append_stylesheet(append_styles_to, style);
    }
}
function get_root_for_style(node) {
    if (!node)
        return document;
    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
    if (root && root.host) {
        return root;
    }
    return node.ownerDocument;
}
function append_empty_stylesheet(node) {
    const style_element = element('style');
    append_stylesheet(get_root_for_style(node), style_element);
    return style_element.sheet;
}
function append_stylesheet(node, style) {
    append(node.head || node, style);
    return style.sheet;
}
function append_hydration(target, node) {
    if (is_hydrating) {
        init_hydrate(target);
        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentNode !== target))) {
            target.actual_end_child = target.firstChild;
        }
        // Skip nodes of undefined ordering
        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {
            target.actual_end_child = target.actual_end_child.nextSibling;
        }
        if (node !== target.actual_end_child) {
            // We only insert if the ordering of this node should be modified or the parent node is not target
            if (node.claim_order !== undefined || node.parentNode !== target) {
                target.insertBefore(node, target.actual_end_child);
            }
        }
        else {
            target.actual_end_child = node.nextSibling;
        }
    }
    else if (node.parentNode !== target || node.nextSibling !== null) {
        target.appendChild(node);
    }
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function insert_hydration(target, node, anchor) {
    if (is_hydrating && !anchor) {
        append_hydration(target, node);
    }
    else if (node.parentNode !== target || node.nextSibling != anchor) {
        target.insertBefore(node, anchor || null);
    }
}
function detach(node) {
    if (node.parentNode) {
        node.parentNode.removeChild(node);
    }
}
function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
            iterations[i].d(detaching);
    }
}
function element(name) {
    return document.createElement(name);
}
function element_is(name, is) {
    return document.createElement(name, { is });
}
function object_without_properties(obj, exclude) {
    const target = {};
    for (const k in obj) {
        if (has_prop(obj, k)
            // @ts-ignore
            && exclude.indexOf(k) === -1) {
            // @ts-ignore
            target[k] = obj[k];
        }
    }
    return target;
}
function svg_element(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
}
function text(data) {
    return document.createTextNode(data);
}
function space() {
    return text(' ');
}
function empty() {
    return text('');
}
function comment(content) {
    return document.createComment(content);
}
function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
    return function (event) {
        event.preventDefault();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function stop_propagation(fn) {
    return function (event) {
        event.stopPropagation();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function stop_immediate_propagation(fn) {
    return function (event) {
        event.stopImmediatePropagation();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function self(fn) {
    return function (event) {
        // @ts-ignore
        if (event.target === this)
            fn.call(this, event);
    };
}
function trusted(fn) {
    return function (event) {
        // @ts-ignore
        if (event.isTrusted)
            fn.call(this, event);
    };
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
/**
 * List of attributes that should always be set through the attr method,
 * because updating them through the property setter doesn't work reliably.
 * In the example of `width`/`height`, the problem is that the setter only
 * accepts numeric values, but the attribute can also be set to a string like `50%`.
 * If this list becomes too big, rethink this approach.
 */
const always_set_through_set_attribute = ['width', 'height'];
function set_attributes(node, attributes) {
    // @ts-ignore
    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
    for (const key in attributes) {
        if (attributes[key] == null) {
            node.removeAttribute(key);
        }
        else if (key === 'style') {
            node.style.cssText = attributes[key];
        }
        else if (key === '__value') {
            node.value = node[key] = attributes[key];
        }
        else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {
            node[key] = attributes[key];
        }
        else {
            attr(node, key, attributes[key]);
        }
    }
}
function set_svg_attributes(node, attributes) {
    for (const key in attributes) {
        attr(node, key, attributes[key]);
    }
}
function set_custom_element_data_map(node, data_map) {
    Object.keys(data_map).forEach((key) => {
        set_custom_element_data(node, key, data_map[key]);
    });
}
function set_custom_element_data(node, prop, value) {
    if (prop in node) {
        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
    }
    else {
        attr(node, prop, value);
    }
}
function set_dynamic_element_data(tag) {
    return (/-/.test(tag)) ? set_custom_element_data_map : set_attributes;
}
function xlink_attr(node, attribute, value) {
    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
}
function get_binding_group_value(group, __value, checked) {
    const value = new Set();
    for (let i = 0; i < group.length; i += 1) {
        if (group[i].checked)
            value.add(group[i].__value);
    }
    if (!checked) {
        value.delete(__value);
    }
    return Array.from(value);
}
function init_binding_group(group) {
    let _inputs;
    return {
        /* push */ p(...inputs) {
            _inputs = inputs;
            _inputs.forEach(input => group.push(input));
        },
        /* remove */ r() {
            _inputs.forEach(input => group.splice(group.indexOf(input), 1));
        }
    };
}
function init_binding_group_dynamic(group, indexes) {
    let _group = get_binding_group(group);
    let _inputs;
    function get_binding_group(group) {
        for (let i = 0; i < indexes.length; i++) {
            group = group[indexes[i]] = group[indexes[i]] || [];
        }
        return group;
    }
    function push() {
        _inputs.forEach(input => _group.push(input));
    }
    function remove() {
        _inputs.forEach(input => _group.splice(_group.indexOf(input), 1));
    }
    return {
        /* update */ u(new_indexes) {
            indexes = new_indexes;
            const new_group = get_binding_group(group);
            if (new_group !== _group) {
                remove();
                _group = new_group;
                push();
            }
        },
        /* push */ p(...inputs) {
            _inputs = inputs;
            push();
        },
        /* remove */ r: remove
    };
}
function to_number(value) {
    return value === '' ? null : +value;
}
function time_ranges_to_array(ranges) {
    const array = [];
    for (let i = 0; i < ranges.length; i += 1) {
        array.push({ start: ranges.start(i), end: ranges.end(i) });
    }
    return array;
}
function children(element) {
    return Array.from(element.childNodes);
}
function init_claim_info(nodes) {
    if (nodes.claim_info === undefined) {
        nodes.claim_info = { last_index: 0, total_claimed: 0 };
    }
}
function claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {
    // Try to find nodes in an order such that we lengthen the longest increasing subsequence
    init_claim_info(nodes);
    const resultNode = (() => {
        // We first try to find an element after the previous one
        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {
            const node = nodes[i];
            if (predicate(node)) {
                const replacement = processNode(node);
                if (replacement === undefined) {
                    nodes.splice(i, 1);
                }
                else {
                    nodes[i] = replacement;
                }
                if (!dontUpdateLastIndex) {
                    nodes.claim_info.last_index = i;
                }
                return node;
            }
        }
        // Otherwise, we try to find one before
        // We iterate in reverse so that we don't go too far back
        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {
            const node = nodes[i];
            if (predicate(node)) {
                const replacement = processNode(node);
                if (replacement === undefined) {
                    nodes.splice(i, 1);
                }
                else {
                    nodes[i] = replacement;
                }
                if (!dontUpdateLastIndex) {
                    nodes.claim_info.last_index = i;
                }
                else if (replacement === undefined) {
                    // Since we spliced before the last_index, we decrease it
                    nodes.claim_info.last_index--;
                }
                return node;
            }
        }
        // If we can't find any matching node, we create a new one
        return createNode();
    })();
    resultNode.claim_order = nodes.claim_info.total_claimed;
    nodes.claim_info.total_claimed += 1;
    return resultNode;
}
function claim_element_base(nodes, name, attributes, create_element) {
    return claim_node(nodes, (node) => node.nodeName === name, (node) => {
        const remove = [];
        for (let j = 0; j < node.attributes.length; j++) {
            const attribute = node.attributes[j];
            if (!attributes[attribute.name]) {
                remove.push(attribute.name);
            }
        }
        remove.forEach(v => node.removeAttribute(v));
        return undefined;
    }, () => create_element(name));
}
function claim_element(nodes, name, attributes) {
    return claim_element_base(nodes, name, attributes, element);
}
function claim_svg_element(nodes, name, attributes) {
    return claim_element_base(nodes, name, attributes, svg_element);
}
function claim_text(nodes, data) {
    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {
        const dataStr = '' + data;
        if (node.data.startsWith(dataStr)) {
            if (node.data.length !== dataStr.length) {
                return node.splitText(dataStr.length);
            }
        }
        else {
            node.data = dataStr;
        }
    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements
    );
}
function claim_space(nodes) {
    return claim_text(nodes, ' ');
}
function claim_comment(nodes, data) {
    return claim_node(nodes, (node) => node.nodeType === 8, (node) => {
        node.data = '' + data;
        return undefined;
    }, () => comment(data), true);
}
function find_comment(nodes, text, start) {
    for (let i = start; i < nodes.length; i += 1) {
        const node = nodes[i];
        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {
            return i;
        }
    }
    return nodes.length;
}
function claim_html_tag(nodes, is_svg) {
    // find html opening tag
    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);
    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);
    if (start_index === end_index) {
        return new HtmlTagHydration(undefined, is_svg);
    }
    init_claim_info(nodes);
    const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);
    detach(html_tag_nodes[0]);
    detach(html_tag_nodes[html_tag_nodes.length - 1]);
    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);
    for (const n of claimed_nodes) {
        n.claim_order = nodes.claim_info.total_claimed;
        nodes.claim_info.total_claimed += 1;
    }
    return new HtmlTagHydration(claimed_nodes, is_svg);
}
function set_data(text, data) {
    data = '' + data;
    if (text.data === data)
        return;
    text.data = data;
}
function set_data_contenteditable(text, data) {
    data = '' + data;
    if (text.wholeText === data)
        return;
    text.data = data;
}
function set_data_maybe_contenteditable(text, data, attr_value) {
    if (~contenteditable_truthy_values.indexOf(attr_value)) {
        set_data_contenteditable(text, data);
    }
    else {
        set_data(text, data);
    }
}
function set_input_value(input, value) {
    input.value = value == null ? '' : value;
}
function set_input_type(input, type) {
    try {
        input.type = type;
    }
    catch (e) {
        // do nothing
    }
}
function set_style(node, key, value, important) {
    if (value == null) {
        node.style.removeProperty(key);
    }
    else {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
}
function select_option(select, value, mounting) {
    for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];
        if (option.__value === value) {
            option.selected = true;
            return;
        }
    }
    if (!mounting || value !== undefined) {
        select.selectedIndex = -1; // no option should be selected
    }
}
function select_options(select, value) {
    for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];
        option.selected = ~value.indexOf(option.__value);
    }
}
function select_value(select) {
    const selected_option = select.querySelector(':checked');
    return selected_option && selected_option.__value;
}
function select_multiple_value(select) {
    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);
}
// unfortunately this can't be a constant as that wouldn't be tree-shakeable
// so we cache the result instead
let crossorigin;
function is_crossorigin() {
    if (crossorigin === undefined) {
        crossorigin = false;
        try {
            if (typeof window !== 'undefined' && window.parent) {
                void window.parent.document;
            }
        }
        catch (error) {
            crossorigin = true;
        }
    }
    return crossorigin;
}
function add_iframe_resize_listener(node, fn) {
    const computed_style = getComputedStyle(node);
    if (computed_style.position === 'static') {
        node.style.position = 'relative';
    }
    const iframe = element('iframe');
    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +
        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
    iframe.setAttribute('aria-hidden', 'true');
    iframe.tabIndex = -1;
    const crossorigin = is_crossorigin();
    let unsubscribe;
    if (crossorigin) {
        iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
        unsubscribe = listen(window, 'message', (event) => {
            if (event.source === iframe.contentWindow)
                fn();
        });
    }
    else {
        iframe.src = 'about:blank';
        iframe.onload = () => {
            unsubscribe = listen(iframe.contentWindow, 'resize', fn);
            // make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)
            // see https://github.com/sveltejs/svelte/issues/4233
            fn();
        };
    }
    append(node, iframe);
    return () => {
        if (crossorigin) {
            unsubscribe();
        }
        else if (unsubscribe && iframe.contentWindow) {
            unsubscribe();
        }
        detach(iframe);
    };
}
const resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({ box: 'content-box' });
const resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({ box: 'border-box' });
const resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton({ box: 'device-pixel-content-box' });
function toggle_class(element, name, toggle) {
    element.classList[toggle ? 'add' : 'remove'](name);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, bubbles, cancelable, detail);
    return e;
}
function query_selector_all(selector, parent = document.body) {
    return Array.from(parent.querySelectorAll(selector));
}
function head_selector(nodeId, head) {
    const result = [];
    let started = 0;
    for (const node of head.childNodes) {
        if (node.nodeType === 8 /* comment node */) {
            const comment = node.textContent.trim();
            if (comment === `HEAD_${nodeId}_END`) {
                started -= 1;
                result.push(node);
            }
            else if (comment === `HEAD_${nodeId}_START`) {
                started += 1;
                result.push(node);
            }
        }
        else if (started > 0) {
            result.push(node);
        }
    }
    return result;
}
class HtmlTag {
    constructor(is_svg = false) {
        this.is_svg = false;
        this.is_svg = is_svg;
        this.e = this.n = null;
    }
    c(html) {
        this.h(html);
    }
    m(html, target, anchor = null) {
        if (!this.e) {
            if (this.is_svg)
                this.e = svg_element(target.nodeName);
            /** #7364  target for <template> may be provided as #document-fragment(11) */
            else
                this.e = element((target.nodeType === 11 ? 'TEMPLATE' : target.nodeName));
            this.t = target.tagName !== 'TEMPLATE' ? target : target.content;
            this.c(html);
        }
        this.i(anchor);
    }
    h(html) {
        this.e.innerHTML = html;
        this.n = Array.from(this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes);
    }
    i(anchor) {
        for (let i = 0; i < this.n.length; i += 1) {
            insert(this.t, this.n[i], anchor);
        }
    }
    p(html) {
        this.d();
        this.h(html);
        this.i(this.a);
    }
    d() {
        this.n.forEach(detach);
    }
}
class HtmlTagHydration extends HtmlTag {
    constructor(claimed_nodes, is_svg = false) {
        super(is_svg);
        this.e = this.n = null;
        this.l = claimed_nodes;
    }
    c(html) {
        if (this.l) {
            this.n = this.l;
        }
        else {
            super.c(html);
        }
    }
    i(anchor) {
        for (let i = 0; i < this.n.length; i += 1) {
            insert_hydration(this.t, this.n[i], anchor);
        }
    }
}
function attribute_to_object(attributes) {
    const result = {};
    for (const attribute of attributes) {
        result[attribute.name] = attribute.value;
    }
    return result;
}
function get_custom_elements_slots(element) {
    const result = {};
    element.childNodes.forEach((node) => {
        result[node.slot || 'default'] = true;
    });
    return result;
}
function construct_svelte_component(component, props) {
    return new component(props);
}

// we need to store the information for multiple documents because a Svelte application could also contain iframes
// https://github.com/sveltejs/svelte/issues/3624
const managed_styles = new Map();
let active = 0;
// https://github.com/darkskyapp/string-hash/blob/master/index.js
function hash(str) {
    let hash = 5381;
    let i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return hash >>> 0;
}
function create_style_information(doc, node) {
    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
    managed_styles.set(doc, info);
    return info;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
    const step = 16.666 / duration;
    let keyframes = '{\n';
    for (let p = 0; p <= 1; p += step) {
        const t = a + (b - a) * ease(p);
        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
    }
    const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
    const name = `__svelte_${hash(rule)}_${uid}`;
    const doc = get_root_for_style(node);
    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
    if (!rules[name]) {
        rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
    }
    const animation = node.style.animation || '';
    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
    active += 1;
    return name;
}
function delete_rule(node, name) {
    const previous = (node.style.animation || '').split(', ');
    const next = previous.filter(name
        ? anim => anim.indexOf(name) < 0 // remove specific animation
        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
    );
    const deleted = previous.length - next.length;
    if (deleted) {
        node.style.animation = next.join(', ');
        active -= deleted;
        if (!active)
            clear_rules();
    }
}
function clear_rules() {
    raf(() => {
        if (active)
            return;
        managed_styles.forEach(info => {
            const { ownerNode } = info.stylesheet;
            // there is no ownerNode if it runs on jsdom.
            if (ownerNode)
                detach(ownerNode);
        });
        managed_styles.clear();
    });
}

function create_animation(node, from, fn, params) {
    if (!from)
        return noop;
    const to = node.getBoundingClientRect();
    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
        return noop;
    const { delay = 0, duration = 300, easing = identity, 
    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
    start: start_time = now() + delay, 
    // @ts-ignore todo:
    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);
    let running = true;
    let started = false;
    let name;
    function start() {
        if (css) {
            name = create_rule(node, 0, 1, duration, delay, easing, css);
        }
        if (!delay) {
            started = true;
        }
    }
    function stop() {
        if (css)
            delete_rule(node, name);
        running = false;
    }
    loop(now => {
        if (!started && now >= start_time) {
            started = true;
        }
        if (started && now >= end) {
            tick(1, 0);
            stop();
        }
        if (!running) {
            return false;
        }
        if (started) {
            const p = now - start_time;
            const t = 0 + 1 * easing(p / duration);
            tick(t, 1 - t);
        }
        return true;
    });
    start();
    tick(0, 1);
    return stop;
}
function fix_position(node) {
    const style = getComputedStyle(node);
    if (style.position !== 'absolute' && style.position !== 'fixed') {
        const { width, height } = style;
        const a = node.getBoundingClientRect();
        node.style.position = 'absolute';
        node.style.width = width;
        node.style.height = height;
        add_transform(node, a);
    }
}
function add_transform(node, a) {
    const b = node.getBoundingClientRect();
    if (a.left !== b.left || a.top !== b.top) {
        const style = getComputedStyle(node);
        const transform = style.transform === 'none' ? '' : style.transform;
        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
    }
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error('Function called outside component initialization');
    return current_component;
}
/**
 * Schedules a callback to run immediately before the component is updated after any state change.
 *
 * The first time the callback runs will be before the initial `onMount`
 *
 * https://svelte.dev/docs#run-time-svelte-beforeupdate
 */
function beforeUpdate(fn) {
    get_current_component().$$.before_update.push(fn);
}
/**
 * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
 * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
 * it can be called from an external module).
 *
 * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).
 *
 * https://svelte.dev/docs#run-time-svelte-onmount
 */
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}
/**
 * Schedules a callback to run immediately after the component has been updated.
 *
 * The first time the callback runs will be after the initial `onMount`
 */
function afterUpdate(fn) {
    get_current_component().$$.after_update.push(fn);
}
/**
 * Schedules a callback to run immediately before the component is unmounted.
 *
 * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
 * only one that runs inside a server-side component.
 *
 * https://svelte.dev/docs#run-time-svelte-ondestroy
 */
function onDestroy(fn) {
    get_current_component().$$.on_destroy.push(fn);
}
/**
 * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).
 * Event dispatchers are functions that can take two arguments: `name` and `detail`.
 *
 * Component events created with `createEventDispatcher` create a
 * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
 * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
 * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
 * property and can contain any type of data.
 *
 * https://svelte.dev/docs#run-time-svelte-createeventdispatcher
 */
function createEventDispatcher() {
    const component = get_current_component();
    return (type, detail, { cancelable = false } = {}) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
            // TODO are there situations where events could be dispatched
            // in a server (non-DOM) environment?
            const event = custom_event(type, detail, { cancelable });
            callbacks.slice().forEach(fn => {
                fn.call(component, event);
            });
            return !event.defaultPrevented;
        }
        return true;
    };
}
/**
 * Associates an arbitrary `context` object with the current component and the specified `key`
 * and returns that object. The context is then available to children of the component
 * (including slotted content) with `getContext`.
 *
 * Like lifecycle functions, this must be called during component initialisation.
 *
 * https://svelte.dev/docs#run-time-svelte-setcontext
 */
function setContext(key, context) {
    get_current_component().$$.context.set(key, context);
    return context;
}
/**
 * Retrieves the context that belongs to the closest parent component with the specified `key`.
 * Must be called during component initialisation.
 *
 * https://svelte.dev/docs#run-time-svelte-getcontext
 */
function getContext(key) {
    return get_current_component().$$.context.get(key);
}
/**
 * Retrieves the whole context map that belongs to the closest parent component.
 * Must be called during component initialisation. Useful, for example, if you
 * programmatically create a component and want to pass the existing context to it.
 *
 * https://svelte.dev/docs#run-time-svelte-getallcontexts
 */
function getAllContexts() {
    return get_current_component().$$.context;
}
/**
 * Checks whether a given `key` has been set in the context of a parent component.
 * Must be called during component initialisation.
 *
 * https://svelte.dev/docs#run-time-svelte-hascontext
 */
function hasContext(key) {
    return get_current_component().$$.context.has(key);
}
// TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism
function bubble(component, event) {
    const callbacks = component.$$.callbacks[event.type];
    if (callbacks) {
        // @ts-ignore
        callbacks.slice().forEach(fn => fn.call(this, event));
    }
}

const dirty_components = [];
const intros = { enabled: false };
const binding_callbacks = [];
let render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = /* @__PURE__ */ Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function tick() {
    schedule_update();
    return resolved_promise;
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
function add_flush_callback(fn) {
    flush_callbacks.push(fn);
}
// flush() calls callbacks in this order:
// 1. All beforeUpdate callbacks, in order: parents before children
// 2. All bind:this callbacks, in reverse order: children before parents.
// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
//    for afterUpdates called during the initial onMount, which are called in
//    reverse order: children before parents.
// Since callbacks might update component values, which could trigger another
// call to flush(), the following steps guard against this:
// 1. During beforeUpdate, any updated components will be added to the
//    dirty_components array and will cause a reentrant call to flush(). Because
//    the flush index is kept outside the function, the reentrant call will pick
//    up where the earlier call left off and go through all dirty components. The
//    current_component value is saved and restored so that the reentrant call will
//    not interfere with the "parent" flush() call.
// 2. bind:this callbacks cannot trigger new flush() calls.
// 3. During afterUpdate, any updated components will NOT have their afterUpdate
//    callback called a second time; the seen_callbacks set, outside the flush()
//    function, guarantees this behavior.
const seen_callbacks = new Set();
let flushidx = 0; // Do *not* move this inside the flush() function
function flush() {
    // Do not reenter flush while dirty components are updated, as this can
    // result in an infinite loop. Instead, let the inner flush handle it.
    // Reentrancy is ok afterwards for bindings etc.
    if (flushidx !== 0) {
        return;
    }
    const saved_component = current_component;
    do {
        // first, call beforeUpdate functions
        // and update components
        try {
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update(component.$$);
            }
        }
        catch (e) {
            // reset dirty state to not end up in a deadlocked state and then rethrow
            dirty_components.length = 0;
            flushidx = 0;
            throw e;
        }
        set_current_component(null);
        dirty_components.length = 0;
        flushidx = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    seen_callbacks.clear();
    set_current_component(saved_component);
}
function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}
/**
 * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.
 */
function flush_render_callbacks(fns) {
    const filtered = [];
    const targets = [];
    render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
    targets.forEach((c) => c());
    render_callbacks = filtered;
}

let promise;
function wait() {
    if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
            promise = null;
        });
    }
    return promise;
}
function dispatch(node, direction, kind) {
    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
}
const outroing = new Set();
let outros;
function group_outros() {
    outros = {
        r: 0,
        c: [],
        p: outros // parent group
    };
}
function check_outros() {
    if (!outros.r) {
        run_all(outros.c);
    }
    outros = outros.p;
}
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function transition_out(block, local, detach, callback) {
    if (block && block.o) {
        if (outroing.has(block))
            return;
        outroing.add(block);
        outros.c.push(() => {
            outroing.delete(block);
            if (callback) {
                if (detach)
                    block.d(1);
                callback();
            }
        });
        block.o(local);
    }
    else if (callback) {
        callback();
    }
}
const null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
    const options = { direction: 'in' };
    let config = fn(node, params, options);
    let running = false;
    let animation_name;
    let task;
    let uid = 0;
    function cleanup() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function go() {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        if (css)
            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
        tick(0, 1);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        if (task)
            task.abort();
        running = true;
        add_render_callback(() => dispatch(node, true, 'start'));
        task = loop(now => {
            if (running) {
                if (now >= end_time) {
                    tick(1, 0);
                    dispatch(node, true, 'end');
                    cleanup();
                    return running = false;
                }
                if (now >= start_time) {
                    const t = easing((now - start_time) / duration);
                    tick(t, 1 - t);
                }
            }
            return running;
        });
    }
    let started = false;
    return {
        start() {
            if (started)
                return;
            started = true;
            delete_rule(node);
            if (is_function(config)) {
                config = config(options);
                wait().then(go);
            }
            else {
                go();
            }
        },
        invalidate() {
            started = false;
        },
        end() {
            if (running) {
                cleanup();
                running = false;
            }
        }
    };
}
function create_out_transition(node, fn, params) {
    const options = { direction: 'out' };
    let config = fn(node, params, options);
    let running = true;
    let animation_name;
    const group = outros;
    group.r += 1;
    function go() {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        if (css)
            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        add_render_callback(() => dispatch(node, false, 'start'));
        loop(now => {
            if (running) {
                if (now >= end_time) {
                    tick(0, 1);
                    dispatch(node, false, 'end');
                    if (!--group.r) {
                        // this will result in `end()` being called,
                        // so we don't need to clean up here
                        run_all(group.c);
                    }
                    return false;
                }
                if (now >= start_time) {
                    const t = easing((now - start_time) / duration);
                    tick(1 - t, t);
                }
            }
            return running;
        });
    }
    if (is_function(config)) {
        wait().then(() => {
            // @ts-ignore
            config = config(options);
            go();
        });
    }
    else {
        go();
    }
    return {
        end(reset) {
            if (reset && config.tick) {
                config.tick(1, 0);
            }
            if (running) {
                if (animation_name)
                    delete_rule(node, animation_name);
                running = false;
            }
        }
    };
}
function create_bidirectional_transition(node, fn, params, intro) {
    const options = { direction: 'both' };
    let config = fn(node, params, options);
    let t = intro ? 0 : 1;
    let running_program = null;
    let pending_program = null;
    let animation_name = null;
    function clear_animation() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function init(program, duration) {
        const d = (program.b - t);
        duration *= Math.abs(d);
        return {
            a: t,
            b: program.b,
            d,
            duration,
            start: program.start,
            end: program.start + duration,
            group: program.group
        };
    }
    function go(b) {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        const program = {
            start: now() + delay,
            b
        };
        if (!b) {
            // @ts-ignore todo: improve typings
            program.group = outros;
            outros.r += 1;
        }
        if (running_program || pending_program) {
            pending_program = program;
        }
        else {
            // if this is an intro, and there's a delay, we need to do
            // an initial tick and/or apply CSS animation immediately
            if (css) {
                clear_animation();
                animation_name = create_rule(node, t, b, duration, delay, easing, css);
            }
            if (b)
                tick(0, 1);
            running_program = init(program, duration);
            add_render_callback(() => dispatch(node, b, 'start'));
            loop(now => {
                if (pending_program && now > pending_program.start) {
                    running_program = init(pending_program, duration);
                    pending_program = null;
                    dispatch(node, running_program.b, 'start');
                    if (css) {
                        clear_animation();
                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                    }
                }
                if (running_program) {
                    if (now >= running_program.end) {
                        tick(t = running_program.b, 1 - t);
                        dispatch(node, running_program.b, 'end');
                        if (!pending_program) {
                            // we're done
                            if (running_program.b) {
                                // intro — we can tidy up immediately
                                clear_animation();
                            }
                            else {
                                // outro — needs to be coordinated
                                if (!--running_program.group.r)
                                    run_all(running_program.group.c);
                            }
                        }
                        running_program = null;
                    }
                    else if (now >= running_program.start) {
                        const p = now - running_program.start;
                        t = running_program.a + running_program.d * easing(p / running_program.duration);
                        tick(t, 1 - t);
                    }
                }
                return !!(running_program || pending_program);
            });
        }
    }
    return {
        run(b) {
            if (is_function(config)) {
                wait().then(() => {
                    // @ts-ignore
                    config = config(options);
                    go(b);
                });
            }
            else {
                go(b);
            }
        },
        end() {
            clear_animation();
            running_program = pending_program = null;
        }
    };
}

function handle_promise(promise, info) {
    const token = info.token = {};
    function update(type, index, key, value) {
        if (info.token !== token)
            return;
        info.resolved = value;
        let child_ctx = info.ctx;
        if (key !== undefined) {
            child_ctx = child_ctx.slice();
            child_ctx[key] = value;
        }
        const block = type && (info.current = type)(child_ctx);
        let needs_flush = false;
        if (info.block) {
            if (info.blocks) {
                info.blocks.forEach((block, i) => {
                    if (i !== index && block) {
                        group_outros();
                        transition_out(block, 1, 1, () => {
                            if (info.blocks[i] === block) {
                                info.blocks[i] = null;
                            }
                        });
                        check_outros();
                    }
                });
            }
            else {
                info.block.d(1);
            }
            block.c();
            transition_in(block, 1);
            block.m(info.mount(), info.anchor);
            needs_flush = true;
        }
        info.block = block;
        if (info.blocks)
            info.blocks[index] = block;
        if (needs_flush) {
            flush();
        }
    }
    if (is_promise(promise)) {
        const current_component = get_current_component();
        promise.then(value => {
            set_current_component(current_component);
            update(info.then, 1, info.value, value);
            set_current_component(null);
        }, error => {
            set_current_component(current_component);
            update(info.catch, 2, info.error, error);
            set_current_component(null);
            if (!info.hasCatch) {
                throw error;
            }
        });
        // if we previously had a then/catch block, destroy it
        if (info.current !== info.pending) {
            update(info.pending, 0);
            return true;
        }
    }
    else {
        if (info.current !== info.then) {
            update(info.then, 1, info.value, promise);
            return true;
        }
        info.resolved = promise;
    }
}
function update_await_block_branch(info, ctx, dirty) {
    const child_ctx = ctx.slice();
    const { resolved } = info;
    if (info.current === info.then) {
        child_ctx[info.value] = resolved;
    }
    if (info.current === info.catch) {
        child_ctx[info.error] = resolved;
    }
    info.block.p(child_ctx, dirty);
}

function destroy_block(block, lookup) {
    block.d(1);
    lookup.delete(block.key);
}
function outro_and_destroy_block(block, lookup) {
    transition_out(block, 1, 1, () => {
        lookup.delete(block.key);
    });
}
function fix_and_destroy_block(block, lookup) {
    block.f();
    destroy_block(block, lookup);
}
function fix_and_outro_and_destroy_block(block, lookup) {
    block.f();
    outro_and_destroy_block(block, lookup);
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
    let o = old_blocks.length;
    let n = list.length;
    let i = o;
    const old_indexes = {};
    while (i--)
        old_indexes[old_blocks[i].key] = i;
    const new_blocks = [];
    const new_lookup = new Map();
    const deltas = new Map();
    const updates = [];
    i = n;
    while (i--) {
        const child_ctx = get_context(ctx, list, i);
        const key = get_key(child_ctx);
        let block = lookup.get(key);
        if (!block) {
            block = create_each_block(key, child_ctx);
            block.c();
        }
        else if (dynamic) {
            // defer updates until all the DOM shuffling is done
            updates.push(() => block.p(child_ctx, dirty));
        }
        new_lookup.set(key, new_blocks[i] = block);
        if (key in old_indexes)
            deltas.set(key, Math.abs(i - old_indexes[key]));
    }
    const will_move = new Set();
    const did_move = new Set();
    function insert(block) {
        transition_in(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n--;
    }
    while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;
        if (new_block === old_block) {
            // do nothing
            next = new_block.first;
            o--;
            n--;
        }
        else if (!new_lookup.has(old_key)) {
            // remove old block
            destroy(old_block, lookup);
            o--;
        }
        else if (!lookup.has(new_key) || will_move.has(new_key)) {
            insert(new_block);
        }
        else if (did_move.has(old_key)) {
            o--;
        }
        else if (deltas.get(new_key) > deltas.get(old_key)) {
            did_move.add(new_key);
            insert(new_block);
        }
        else {
            will_move.add(old_key);
            o--;
        }
    }
    while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key))
            destroy(old_block, lookup);
    }
    while (n)
        insert(new_blocks[n - 1]);
    run_all(updates);
    return new_blocks;
}
function validate_each_keys(ctx, list, get_context, get_key) {
    const keys = new Set();
    for (let i = 0; i < list.length; i++) {
        const key = get_key(get_context(ctx, list, i));
        if (keys.has(key)) {
            throw new Error('Cannot have duplicate keys in a keyed each');
        }
        keys.add(key);
    }
}

function get_spread_update(levels, updates) {
    const update = {};
    const to_null_out = {};
    const accounted_for = { $$scope: 1 };
    let i = levels.length;
    while (i--) {
        const o = levels[i];
        const n = updates[i];
        if (n) {
            for (const key in o) {
                if (!(key in n))
                    to_null_out[key] = 1;
            }
            for (const key in n) {
                if (!accounted_for[key]) {
                    update[key] = n[key];
                    accounted_for[key] = 1;
                }
            }
            levels[i] = n;
        }
        else {
            for (const key in o) {
                accounted_for[key] = 1;
            }
        }
    }
    for (const key in to_null_out) {
        if (!(key in update))
            update[key] = undefined;
    }
    return update;
}
function get_spread_object(spread_props) {
    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
}

const _boolean_attributes = [
    'allowfullscreen',
    'allowpaymentrequest',
    'async',
    'autofocus',
    'autoplay',
    'checked',
    'controls',
    'default',
    'defer',
    'disabled',
    'formnovalidate',
    'hidden',
    'inert',
    'ismap',
    'loop',
    'multiple',
    'muted',
    'nomodule',
    'novalidate',
    'open',
    'playsinline',
    'readonly',
    'required',
    'reversed',
    'selected'
];
/**
 * List of HTML boolean attributes (e.g. `<input disabled>`).
 * Source: https://html.spec.whatwg.org/multipage/indices.html
 */
const boolean_attributes = new Set([..._boolean_attributes]);

/** regex of all html void element names */
const void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;
function is_void(name) {
    return void_element_names.test(name) || name.toLowerCase() === '!doctype';
}

const invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
// https://infra.spec.whatwg.org/#noncharacter
function spread(args, attrs_to_add) {
    const attributes = Object.assign({}, ...args);
    if (attrs_to_add) {
        const classes_to_add = attrs_to_add.classes;
        const styles_to_add = attrs_to_add.styles;
        if (classes_to_add) {
            if (attributes.class == null) {
                attributes.class = classes_to_add;
            }
            else {
                attributes.class += ' ' + classes_to_add;
            }
        }
        if (styles_to_add) {
            if (attributes.style == null) {
                attributes.style = style_object_to_string(styles_to_add);
            }
            else {
                attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));
            }
        }
    }
    let str = '';
    Object.keys(attributes).forEach(name => {
        if (invalid_attribute_name_character.test(name))
            return;
        const value = attributes[name];
        if (value === true)
            str += ' ' + name;
        else if (boolean_attributes.has(name.toLowerCase())) {
            if (value)
                str += ' ' + name;
        }
        else if (value != null) {
            str += ` ${name}="${value}"`;
        }
    });
    return str;
}
function merge_ssr_styles(style_attribute, style_directive) {
    const style_object = {};
    for (const individual_style of style_attribute.split(';')) {
        const colon_index = individual_style.indexOf(':');
        const name = individual_style.slice(0, colon_index).trim();
        const value = individual_style.slice(colon_index + 1).trim();
        if (!name)
            continue;
        style_object[name] = value;
    }
    for (const name in style_directive) {
        const value = style_directive[name];
        if (value) {
            style_object[name] = value;
        }
        else {
            delete style_object[name];
        }
    }
    return style_object;
}
const ATTR_REGEX = /[&"]/g;
const CONTENT_REGEX = /[&<]/g;
/**
 * Note: this method is performance sensitive and has been optimized
 * https://github.com/sveltejs/svelte/pull/5701
 */
function escape(value, is_attr = false) {
    const str = String(value);
    const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;
    pattern.lastIndex = 0;
    let escaped = '';
    let last = 0;
    while (pattern.test(str)) {
        const i = pattern.lastIndex - 1;
        const ch = str[i];
        escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : (ch === '"' ? '&quot;' : '&lt;'));
        last = i + 1;
    }
    return escaped + str.substring(last);
}
function escape_attribute_value(value) {
    // keep booleans, null, and undefined for the sake of `spread`
    const should_escape = typeof value === 'string' || (value && typeof value === 'object');
    return should_escape ? escape(value, true) : value;
}
function escape_object(obj) {
    const result = {};
    for (const key in obj) {
        result[key] = escape_attribute_value(obj[key]);
    }
    return result;
}
function each(items, fn) {
    let str = '';
    for (let i = 0; i < items.length; i += 1) {
        str += fn(items[i], i);
    }
    return str;
}
const missing_component = {
    $$render: () => ''
};
function validate_component(component, name) {
    if (!component || !component.$$render) {
        if (name === 'svelte:component')
            name += ' this={...}';
        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name}>.`);
    }
    return component;
}
function debug(file, line, column, values) {
    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console
    console.log(values); // eslint-disable-line no-console
    return '';
}
let on_destroy;
function create_ssr_component(fn) {
    function $$render(result, props, bindings, slots, context) {
        const parent_component = current_component;
        const $$ = {
            on_destroy,
            context: new Map(context || (parent_component ? parent_component.$$.context : [])),
            // these will be immediately discarded
            on_mount: [],
            before_update: [],
            after_update: [],
            callbacks: blank_object()
        };
        set_current_component({ $$ });
        const html = fn(result, props, bindings, slots);
        set_current_component(parent_component);
        return html;
    }
    return {
        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
            on_destroy = [];
            const result = { title: '', head: '', css: new Set() };
            const html = $$render(result, props, {}, $$slots, context);
            run_all(on_destroy);
            return {
                html,
                css: {
                    code: Array.from(result.css).map(css => css.code).join('\n'),
                    map: null // TODO
                },
                head: result.title + result.head
            };
        },
        $$render
    };
}
function add_attribute(name, value, boolean) {
    if (value == null || (boolean && !value))
        return '';
    const assignment = (boolean && value === true) ? '' : `="${escape(value, true)}"`;
    return ` ${name}${assignment}`;
}
function add_classes(classes) {
    return classes ? ` class="${classes}"` : '';
}
function style_object_to_string(style_object) {
    return Object.keys(style_object)
        .filter(key => style_object[key])
        .map(key => `${key}: ${escape_attribute_value(style_object[key])};`)
        .join(' ');
}
function add_styles(style_object) {
    const styles = style_object_to_string(style_object);
    return styles ? ` style="${styles}"` : '';
}

function bind(component, name, callback) {
    const index = component.$$.props[name];
    if (index !== undefined) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
    }
}
function create_component(block) {
    block && block.c();
}
function claim_component(block, parent_nodes) {
    block && block.l(parent_nodes);
}
function mount_component(component, target, anchor, customElement) {
    const { fragment, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    if (!customElement) {
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
            // if the component was destroyed immediately
            // it will update the `$$.on_destroy` reference to `null`.
            // the destructured on_destroy may still reference to the old array
            if (component.$$.on_destroy) {
                component.$$.on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
    }
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        flush_render_callbacks($$.after_update);
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
        fragment: null,
        ctx: [],
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false,
        root: options.target || parent_component.$$.root
    };
    append_styles && append_styles($$.root);
    let ready = false;
    $$.ctx = instance
        ? instance(component, options.props || {}, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            start_hydrating();
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor, options.customElement);
        end_hydrating();
        flush();
    }
    set_current_component(parent_component);
}
let SvelteElement;
if (typeof HTMLElement === 'function') {
    SvelteElement = class extends HTMLElement {
        constructor() {
            super();
            this.attachShadow({ mode: 'open' });
        }
        connectedCallback() {
            const { on_mount } = this.$$;
            this.$$.on_disconnect = on_mount.map(run).filter(is_function);
            // @ts-ignore todo: improve typings
            for (const key in this.$$.slotted) {
                // @ts-ignore todo: improve typings
                this.appendChild(this.$$.slotted[key]);
            }
        }
        attributeChangedCallback(attr, _oldValue, newValue) {
            this[attr] = newValue;
        }
        disconnectedCallback() {
            run_all(this.$$.on_disconnect);
        }
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            // TODO should this delegate to addEventListener?
            if (!is_function(callback)) {
                return noop;
            }
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    };
}
/**
 * Base class for Svelte components. Used when dev=false.
 */
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        if (!is_function(callback)) {
            return noop;
        }
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

function dispatch_dev(type, detail) {
    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.59.2' }, detail), { bubbles: true }));
}
function append_dev(target, node) {
    dispatch_dev('SvelteDOMInsert', { target, node });
    append(target, node);
}
function append_hydration_dev(target, node) {
    dispatch_dev('SvelteDOMInsert', { target, node });
    append_hydration(target, node);
}
function insert_dev(target, node, anchor) {
    dispatch_dev('SvelteDOMInsert', { target, node, anchor });
    insert(target, node, anchor);
}
function insert_hydration_dev(target, node, anchor) {
    dispatch_dev('SvelteDOMInsert', { target, node, anchor });
    insert_hydration(target, node, anchor);
}
function detach_dev(node) {
    dispatch_dev('SvelteDOMRemove', { node });
    detach(node);
}
function detach_between_dev(before, after) {
    while (before.nextSibling && before.nextSibling !== after) {
        detach_dev(before.nextSibling);
    }
}
function detach_before_dev(after) {
    while (after.previousSibling) {
        detach_dev(after.previousSibling);
    }
}
function detach_after_dev(before) {
    while (before.nextSibling) {
        detach_dev(before.nextSibling);
    }
}
function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {
    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
    if (has_prevent_default)
        modifiers.push('preventDefault');
    if (has_stop_propagation)
        modifiers.push('stopPropagation');
    if (has_stop_immediate_propagation)
        modifiers.push('stopImmediatePropagation');
    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
    const dispose = listen(node, event, handler, options);
    return () => {
        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
        dispose();
    };
}
function attr_dev(node, attribute, value) {
    attr(node, attribute, value);
    if (value == null)
        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
    else
        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
}
function prop_dev(node, property, value) {
    node[property] = value;
    dispatch_dev('SvelteDOMSetProperty', { node, property, value });
}
function dataset_dev(node, property, value) {
    node.dataset[property] = value;
    dispatch_dev('SvelteDOMSetDataset', { node, property, value });
}
function set_data_dev(text, data) {
    data = '' + data;
    if (text.data === data)
        return;
    dispatch_dev('SvelteDOMSetData', { node: text, data });
    text.data = data;
}
function set_data_contenteditable_dev(text, data) {
    data = '' + data;
    if (text.wholeText === data)
        return;
    dispatch_dev('SvelteDOMSetData', { node: text, data });
    text.data = data;
}
function set_data_maybe_contenteditable_dev(text, data, attr_value) {
    if (~contenteditable_truthy_values.indexOf(attr_value)) {
        set_data_contenteditable_dev(text, data);
    }
    else {
        set_data_dev(text, data);
    }
}
function validate_each_argument(arg) {
    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
        let msg = '{#each} only iterates over array-like objects.';
        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
            msg += ' You can use a spread to convert this iterable into an array.';
        }
        throw new Error(msg);
    }
}
function validate_slots(name, slot, keys) {
    for (const slot_key of Object.keys(slot)) {
        if (!~keys.indexOf(slot_key)) {
            console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
        }
    }
}
function validate_dynamic_element(tag) {
    const is_string = typeof tag === 'string';
    if (tag && !is_string) {
        throw new Error('<svelte:element> expects "this" attribute to be a string.');
    }
}
function validate_void_dynamic_element(tag) {
    if (tag && is_void(tag)) {
        console.warn(`<svelte:element this="${tag}"> is self-closing and cannot have content.`);
    }
}
function construct_svelte_component_dev(component, props) {
    const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';
    try {
        const instance = new component(props);
        if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {
            throw new Error(error_message);
        }
        return instance;
    }
    catch (err) {
        const { message } = err;
        if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {
            throw new Error(error_message);
        }
        else {
            throw err;
        }
    }
}
/**
 * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
 */
class SvelteComponentDev extends SvelteComponent {
    constructor(options) {
        if (!options || (!options.target && !options.$$inline)) {
            throw new Error("'target' is a required option");
        }
        super();
    }
    $destroy() {
        super.$destroy();
        this.$destroy = () => {
            console.warn('Component was already destroyed'); // eslint-disable-line no-console
        };
    }
    $capture_state() { }
    $inject_state() { }
}
/**
 * Base class to create strongly typed Svelte components.
 * This only exists for typing purposes and should be used in `.d.ts` files.
 *
 * ### Example:
 *
 * You have component library on npm called `component-library`, from which
 * you export a component called `MyComponent`. For Svelte+TypeScript users,
 * you want to provide typings. Therefore you create a `index.d.ts`:
 * ```ts
 * import { SvelteComponentTyped } from "svelte";
 * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}
 * ```
 * Typing this makes it possible for IDEs like VS Code with the Svelte extension
 * to provide intellisense and to use the component like this in a Svelte file
 * with TypeScript:
 * ```svelte
 * <script lang="ts">
 * 	import { MyComponent } from "component-library";
 * </script>
 * <MyComponent foo={'bar'} />
 * ```
 *
 * #### Why not make this part of `SvelteComponent(Dev)`?
 * Because
 * ```ts
 * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}
 * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;
 * ```
 * will throw a type error, so we need to separate the more strictly typed class.
 */
class SvelteComponentTyped extends SvelteComponentDev {
    constructor(options) {
        super(options);
    }
}
function loop_guard(timeout) {
    const start = Date.now();
    return () => {
        if (Date.now() - start > timeout) {
            throw new Error('Infinite loop detected');
        }
    };
}




/***/ }),

/***/ "./node_modules/svelte/motion/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/svelte/motion/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   spring: () => (/* binding */ spring),
/* harmony export */   tweened: () => (/* binding */ tweened)
/* harmony export */ });
/* harmony import */ var _store_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../store/index.mjs */ "./node_modules/svelte/store/index.mjs");
/* harmony import */ var _internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal/index.mjs */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var _easing_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../easing/index.mjs */ "./node_modules/svelte/easing/index.mjs");




function is_date(obj) {
    return Object.prototype.toString.call(obj) === '[object Date]';
}

function tick_spring(ctx, last_value, current_value, target_value) {
    if (typeof current_value === 'number' || is_date(current_value)) {
        // @ts-ignore
        const delta = target_value - current_value;
        // @ts-ignore
        const velocity = (current_value - last_value) / (ctx.dt || 1 / 60); // guard div by 0
        const spring = ctx.opts.stiffness * delta;
        const damper = ctx.opts.damping * velocity;
        const acceleration = (spring - damper) * ctx.inv_mass;
        const d = (velocity + acceleration) * ctx.dt;
        if (Math.abs(d) < ctx.opts.precision && Math.abs(delta) < ctx.opts.precision) {
            return target_value; // settled
        }
        else {
            ctx.settled = false; // signal loop to keep ticking
            // @ts-ignore
            return is_date(current_value) ?
                new Date(current_value.getTime() + d) : current_value + d;
        }
    }
    else if (Array.isArray(current_value)) {
        // @ts-ignore
        return current_value.map((_, i) => tick_spring(ctx, last_value[i], current_value[i], target_value[i]));
    }
    else if (typeof current_value === 'object') {
        const next_value = {};
        for (const k in current_value) {
            // @ts-ignore
            next_value[k] = tick_spring(ctx, last_value[k], current_value[k], target_value[k]);
        }
        // @ts-ignore
        return next_value;
    }
    else {
        throw new Error(`Cannot spring ${typeof current_value} values`);
    }
}
function spring(value, opts = {}) {
    const store = (0,_store_index_mjs__WEBPACK_IMPORTED_MODULE_0__.writable)(value);
    const { stiffness = 0.15, damping = 0.8, precision = 0.01 } = opts;
    let last_time;
    let task;
    let current_token;
    let last_value = value;
    let target_value = value;
    let inv_mass = 1;
    let inv_mass_recovery_rate = 0;
    let cancel_task = false;
    function set(new_value, opts = {}) {
        target_value = new_value;
        const token = current_token = {};
        if (value == null || opts.hard || (spring.stiffness >= 1 && spring.damping >= 1)) {
            cancel_task = true; // cancel any running animation
            last_time = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.now)();
            last_value = new_value;
            store.set(value = target_value);
            return Promise.resolve();
        }
        else if (opts.soft) {
            const rate = opts.soft === true ? .5 : +opts.soft;
            inv_mass_recovery_rate = 1 / (rate * 60);
            inv_mass = 0; // infinite mass, unaffected by spring forces
        }
        if (!task) {
            last_time = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.now)();
            cancel_task = false;
            task = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.loop)(now => {
                if (cancel_task) {
                    cancel_task = false;
                    task = null;
                    return false;
                }
                inv_mass = Math.min(inv_mass + inv_mass_recovery_rate, 1);
                const ctx = {
                    inv_mass,
                    opts: spring,
                    settled: true,
                    dt: (now - last_time) * 60 / 1000
                };
                const next_value = tick_spring(ctx, last_value, value, target_value);
                last_time = now;
                last_value = value;
                store.set(value = next_value);
                if (ctx.settled) {
                    task = null;
                }
                return !ctx.settled;
            });
        }
        return new Promise(fulfil => {
            task.promise.then(() => {
                if (token === current_token)
                    fulfil();
            });
        });
    }
    const spring = {
        set,
        update: (fn, opts) => set(fn(target_value, value), opts),
        subscribe: store.subscribe,
        stiffness,
        damping,
        precision
    };
    return spring;
}

function get_interpolator(a, b) {
    if (a === b || a !== a)
        return () => a;
    const type = typeof a;
    if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
        throw new Error('Cannot interpolate values of different type');
    }
    if (Array.isArray(a)) {
        const arr = b.map((bi, i) => {
            return get_interpolator(a[i], bi);
        });
        return t => arr.map(fn => fn(t));
    }
    if (type === 'object') {
        if (!a || !b)
            throw new Error('Object cannot be null');
        if (is_date(a) && is_date(b)) {
            a = a.getTime();
            b = b.getTime();
            const delta = b - a;
            return t => new Date(a + t * delta);
        }
        const keys = Object.keys(b);
        const interpolators = {};
        keys.forEach(key => {
            interpolators[key] = get_interpolator(a[key], b[key]);
        });
        return t => {
            const result = {};
            keys.forEach(key => {
                result[key] = interpolators[key](t);
            });
            return result;
        };
    }
    if (type === 'number') {
        const delta = b - a;
        return t => a + t * delta;
    }
    throw new Error(`Cannot interpolate ${type} values`);
}
function tweened(value, defaults = {}) {
    const store = (0,_store_index_mjs__WEBPACK_IMPORTED_MODULE_0__.writable)(value);
    let task;
    let target_value = value;
    function set(new_value, opts) {
        if (value == null) {
            store.set(value = new_value);
            return Promise.resolve();
        }
        target_value = new_value;
        let previous_task = task;
        let started = false;
        let { delay = 0, duration = 400, easing = _easing_index_mjs__WEBPACK_IMPORTED_MODULE_2__.linear, interpolate = get_interpolator } = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)((0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)({}, defaults), opts);
        if (duration === 0) {
            if (previous_task) {
                previous_task.abort();
                previous_task = null;
            }
            store.set(value = target_value);
            return Promise.resolve();
        }
        const start = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.now)() + delay;
        let fn;
        task = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.loop)(now => {
            if (now < start)
                return true;
            if (!started) {
                fn = interpolate(value, new_value);
                if (typeof duration === 'function')
                    duration = duration(value, new_value);
                started = true;
            }
            if (previous_task) {
                previous_task.abort();
                previous_task = null;
            }
            const elapsed = now - start;
            if (elapsed > duration) {
                store.set(value = new_value);
                return false;
            }
            // @ts-ignore
            store.set(value = fn(easing(elapsed / duration)));
            return true;
        });
        return task.promise;
    }
    return {
        set,
        update: (fn, opts) => set(fn(target_value, value), opts),
        subscribe: store.subscribe
    };
}




/***/ }),

/***/ "./node_modules/svelte/store/index.mjs":
/*!*********************************************!*\
  !*** ./node_modules/svelte/store/index.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   derived: () => (/* binding */ derived),
/* harmony export */   get: () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.get_store_value),
/* harmony export */   readable: () => (/* binding */ readable),
/* harmony export */   readonly: () => (/* binding */ readonly),
/* harmony export */   writable: () => (/* binding */ writable)
/* harmony export */ });
/* harmony import */ var _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/index.mjs */ "./node_modules/svelte/internal/index.mjs");



const subscriber_queue = [];
/**
 * Creates a `Readable` store that allows reading by subscription.
 * @param value initial value
 * @param {StartStopNotifier} [start]
 */
function readable(value, start) {
    return {
        subscribe: writable(value, start).subscribe
    };
}
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=} start
 */
function writable(value, start = _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop) {
    let stop;
    const subscribers = new Set();
    function set(new_value) {
        if ((0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal)(value, new_value)) {
            value = new_value;
            if (stop) { // store is ready
                const run_queue = !subscriber_queue.length;
                for (const subscriber of subscribers) {
                    subscriber[1]();
                    subscriber_queue.push(subscriber, value);
                }
                if (run_queue) {
                    for (let i = 0; i < subscriber_queue.length; i += 2) {
                        subscriber_queue[i][0](subscriber_queue[i + 1]);
                    }
                    subscriber_queue.length = 0;
                }
            }
        }
    }
    function update(fn) {
        set(fn(value));
    }
    function subscribe(run, invalidate = _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop) {
        const subscriber = [run, invalidate];
        subscribers.add(subscriber);
        if (subscribers.size === 1) {
            stop = start(set) || _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop;
        }
        run(value);
        return () => {
            subscribers.delete(subscriber);
            if (subscribers.size === 0 && stop) {
                stop();
                stop = null;
            }
        };
    }
    return { set, update, subscribe };
}
function derived(stores, fn, initial_value) {
    const single = !Array.isArray(stores);
    const stores_array = single
        ? [stores]
        : stores;
    const auto = fn.length < 2;
    return readable(initial_value, (set) => {
        let started = false;
        const values = [];
        let pending = 0;
        let cleanup = _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop;
        const sync = () => {
            if (pending) {
                return;
            }
            cleanup();
            const result = fn(single ? values[0] : values, set);
            if (auto) {
                set(result);
            }
            else {
                cleanup = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.is_function)(result) ? result : _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop;
            }
        };
        const unsubscribers = stores_array.map((store, i) => (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.subscribe)(store, (value) => {
            values[i] = value;
            pending &= ~(1 << i);
            if (started) {
                sync();
            }
        }, () => {
            pending |= (1 << i);
        }));
        started = true;
        sync();
        return function stop() {
            (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.run_all)(unsubscribers);
            cleanup();
            // We need to set this to false because callbacks can still happen despite having unsubscribed:
            // Callbacks might already be placed in the queue which doesn't know it should no longer
            // invoke this derived store.
            started = false;
        };
    });
}
/**
 * Takes a store and returns a new one derived from the old one that is readable.
 *
 * @param store - store to make readonly
 */
function readonly(store) {
    return {
        subscribe: store.subscribe.bind(store)
    };
}




/***/ }),

/***/ "./node_modules/svelte/transition/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/svelte/transition/index.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   blur: () => (/* binding */ blur),
/* harmony export */   crossfade: () => (/* binding */ crossfade),
/* harmony export */   draw: () => (/* binding */ draw),
/* harmony export */   fade: () => (/* binding */ fade),
/* harmony export */   fly: () => (/* binding */ fly),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   slide: () => (/* binding */ slide)
/* harmony export */ });
/* harmony import */ var _easing_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../easing/index.mjs */ "./node_modules/svelte/easing/index.mjs");
/* harmony import */ var _internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal/index.mjs */ "./node_modules/svelte/internal/index.mjs");



/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function blur(node, { delay = 0, duration = 400, easing = _easing_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cubicInOut, amount = 5, opacity = 0 } = {}) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const f = style.filter === 'none' ? '' : style.filter;
    const od = target_opacity * (1 - opacity);
    const [value, unit] = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.split_css_unit)(amount);
    return {
        delay,
        duration,
        easing,
        css: (_t, u) => `opacity: ${target_opacity - (od * u)}; filter: ${f} blur(${u * value}${unit});`
    };
}
function fade(node, { delay = 0, duration = 400, easing = _easing_index_mjs__WEBPACK_IMPORTED_MODULE_0__.linear } = {}) {
    const o = +getComputedStyle(node).opacity;
    return {
        delay,
        duration,
        easing,
        css: t => `opacity: ${t * o}`
    };
}
function fly(node, { delay = 0, duration = 400, easing = _easing_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cubicOut, x = 0, y = 0, opacity = 0 } = {}) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const transform = style.transform === 'none' ? '' : style.transform;
    const od = target_opacity * (1 - opacity);
    const [xValue, xUnit] = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.split_css_unit)(x);
    const [yValue, yUnit] = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.split_css_unit)(y);
    return {
        delay,
        duration,
        easing,
        css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * xValue}${xUnit}, ${(1 - t) * yValue}${yUnit});
			opacity: ${target_opacity - (od * u)}`
    };
}
function slide(node, { delay = 0, duration = 400, easing = _easing_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cubicOut, axis = 'y' } = {}) {
    const style = getComputedStyle(node);
    const opacity = +style.opacity;
    const primary_property = axis === 'y' ? 'height' : 'width';
    const primary_property_value = parseFloat(style[primary_property]);
    const secondary_properties = axis === 'y' ? ['top', 'bottom'] : ['left', 'right'];
    const capitalized_secondary_properties = secondary_properties.map((e) => `${e[0].toUpperCase()}${e.slice(1)}`);
    const padding_start_value = parseFloat(style[`padding${capitalized_secondary_properties[0]}`]);
    const padding_end_value = parseFloat(style[`padding${capitalized_secondary_properties[1]}`]);
    const margin_start_value = parseFloat(style[`margin${capitalized_secondary_properties[0]}`]);
    const margin_end_value = parseFloat(style[`margin${capitalized_secondary_properties[1]}`]);
    const border_width_start_value = parseFloat(style[`border${capitalized_secondary_properties[0]}Width`]);
    const border_width_end_value = parseFloat(style[`border${capitalized_secondary_properties[1]}Width`]);
    return {
        delay,
        duration,
        easing,
        css: t => 'overflow: hidden;' +
            `opacity: ${Math.min(t * 20, 1) * opacity};` +
            `${primary_property}: ${t * primary_property_value}px;` +
            `padding-${secondary_properties[0]}: ${t * padding_start_value}px;` +
            `padding-${secondary_properties[1]}: ${t * padding_end_value}px;` +
            `margin-${secondary_properties[0]}: ${t * margin_start_value}px;` +
            `margin-${secondary_properties[1]}: ${t * margin_end_value}px;` +
            `border-${secondary_properties[0]}-width: ${t * border_width_start_value}px;` +
            `border-${secondary_properties[1]}-width: ${t * border_width_end_value}px;`
    };
}
function scale(node, { delay = 0, duration = 400, easing = _easing_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cubicOut, start = 0, opacity = 0 } = {}) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const transform = style.transform === 'none' ? '' : style.transform;
    const sd = 1 - start;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (_t, u) => `
			transform: ${transform} scale(${1 - (sd * u)});
			opacity: ${target_opacity - (od * u)}
		`
    };
}
function draw(node, { delay = 0, speed, duration, easing = _easing_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cubicInOut } = {}) {
    let len = node.getTotalLength();
    const style = getComputedStyle(node);
    if (style.strokeLinecap !== 'butt') {
        len += parseInt(style.strokeWidth);
    }
    if (duration === undefined) {
        if (speed === undefined) {
            duration = 800;
        }
        else {
            duration = len / speed;
        }
    }
    else if (typeof duration === 'function') {
        duration = duration(len);
    }
    return {
        delay,
        duration,
        easing,
        css: (_, u) => `
			stroke-dasharray: ${len};
			stroke-dashoffset: ${u * len};
		`
    };
}
function crossfade(_a) {
    var { fallback } = _a, defaults = __rest(_a, ["fallback"]);
    const to_receive = new Map();
    const to_send = new Map();
    function crossfade(from_node, node, params) {
        const { delay = 0, duration = d => Math.sqrt(d) * 30, easing = _easing_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cubicOut } = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)((0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)({}, defaults), params);
        const from = from_node.getBoundingClientRect();
        const to = node.getBoundingClientRect();
        const dx = from.left - to.left;
        const dy = from.top - to.top;
        const dw = from.width / to.width;
        const dh = from.height / to.height;
        const d = Math.sqrt(dx * dx + dy * dy);
        const style = getComputedStyle(node);
        const transform = style.transform === 'none' ? '' : style.transform;
        const opacity = +style.opacity;
        return {
            delay,
            duration: (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.is_function)(duration) ? duration(d) : duration,
            easing,
            css: (t, u) => `
				opacity: ${t * opacity};
				transform-origin: top left;
				transform: ${transform} translate(${u * dx}px,${u * dy}px) scale(${t + (1 - t) * dw}, ${t + (1 - t) * dh});
			`
        };
    }
    function transition(items, counterparts, intro) {
        return (node, params) => {
            items.set(params.key, node);
            return () => {
                if (counterparts.has(params.key)) {
                    const other_node = counterparts.get(params.key);
                    counterparts.delete(params.key);
                    return crossfade(other_node, node, params);
                }
                // if the node is disappearing altogether
                // (i.e. wasn't claimed by the other list)
                // then we need to supply an outro
                items.delete(params.key);
                return fallback && fallback(node, params, intro);
            };
        };
    }
    return [
        transition(to_send, to_receive, false),
        transition(to_receive, to_send, true)
    ];
}




/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!********************!*\
  !*** ./JS/main.ts ***!
  \********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   app: () => (/* binding */ app),
/* harmony export */   lookups: () => (/* binding */ lookups),
/* harmony export */   utils: () => (/* binding */ utils)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./style.css */ "./JS/style.css");
/* harmony import */ var _functions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./functions */ "./JS/functions.ts");
/* harmony import */ var svelte_store__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! svelte/store */ "./node_modules/svelte/store/index.mjs");
/* harmony import */ var _Components_EditorApp_svelte__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Components/EditorApp.svelte */ "./JS/Components/EditorApp.svelte");
/* harmony import */ var _stores__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./stores */ "./JS/stores.ts");
/* harmony import */ var _excel__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./excel */ "./JS/excel.ts");
/* harmony import */ var _persist__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./persist */ "./JS/persist.ts");
/* harmony import */ var _menus__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./menus */ "./JS/menus.ts");










Office.onReady( /*#__PURE__*/function () {
  var _ref = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee(info) {
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return Office.addin.setStartupBehavior(Office.StartupBehavior.load);
        case 2:
          _context.next = 4;
          return (0,_menus__WEBPACK_IMPORTED_MODULE_9__.initMenus)();
        case 4:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function (_x) {
    return _ref.apply(this, arguments);
  };
}());
var app = {
  init: function init(lib, version) {
    __webpack_require__.g.blazorLib = lib;
    var target = document.getElementById("editor-app");
    new _Components_EditorApp_svelte__WEBPACK_IMPORTED_MODULE_5__["default"]({
      target: target,
      props: {
        version: version
      }
    });
  },
  login: function login(flag) {
    return _stores__WEBPACK_IMPORTED_MODULE_6__.stateStore.login(flag);
  },
  authenticated: function authenticated(context) {
    _stores__WEBPACK_IMPORTED_MODULE_6__.serversStore.update(context);
    _stores__WEBPACK_IMPORTED_MODULE_6__.stateStore.last();
    _stores__WEBPACK_IMPORTED_MODULE_6__.stateStore.login(false);
  },
  setServers: function setServers(servers) {
    console.log("Set Servers");
    console.log(servers);
    _stores__WEBPACK_IMPORTED_MODULE_6__.serversStore.set(servers);
  },
  updateCql: function updateCql(data) {
    _stores__WEBPACK_IMPORTED_MODULE_6__.cqlStore.update(data);
    _stores__WEBPACK_IMPORTED_MODULE_6__.cqlStore.edit(data);
  },
  deleteCql: function deleteCql(id) {
    return _stores__WEBPACK_IMPORTED_MODULE_6__.cqlStore["delete"](id);
  },
  setCqlDetails: function () {
    var _setCqlDetails = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee2(data, results) {
      var d;
      return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            d = _stores__WEBPACK_IMPORTED_MODULE_6__.cqlStore.get(data.id);
            _context2.next = 3;
            return (0,_persist__WEBPACK_IMPORTED_MODULE_8__.setItem)("cql-".concat(data.id), {
              results: results
            });
          case 3:
            if (d.autoUpdate) {
              (0,_excel__WEBPACK_IMPORTED_MODULE_7__.insertData)(d);
            }
          case 4:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    function setCqlDetails(_x2, _x3) {
      return _setCqlDetails.apply(this, arguments);
    }
    return setCqlDetails;
  }(),
  updateCsl: function updateCsl(data) {
    Object.keys(data).forEach(function (k) {
      if (data[k] === null) delete data[k];
    });
    _stores__WEBPACK_IMPORTED_MODULE_6__.cslStateStore.set(data);
    _stores__WEBPACK_IMPORTED_MODULE_6__.cslStore.edit(data);
  },
  setScriptResponse: function setScriptResponse(response) {
    Object.keys(response).forEach(function (k) {
      if (response[k] === null) delete response[k];
    });
    _stores__WEBPACK_IMPORTED_MODULE_6__.cslResponseStateStore.set(response);
    _stores__WEBPACK_IMPORTED_MODULE_6__.cslResponseStore.add(response);
  },
  clearScriptResponse: function clearScriptResponse(id) {
    _stores__WEBPACK_IMPORTED_MODULE_6__.cslProgressStore.clear(id);
    _stores__WEBPACK_IMPORTED_MODULE_6__.cslResponseStore.clear(id);
  },
  setScriptStatus: function setScriptStatus(status) {
    _stores__WEBPACK_IMPORTED_MODULE_6__.cslProgressStore.update(status);
  },
  getQueryInfo: function getQueryInfo(id) {
    var data = (0,svelte_store__WEBPACK_IMPORTED_MODULE_4__.get)(_stores__WEBPACK_IMPORTED_MODULE_6__.cqlStore).find(function (d) {
      return (d === null || d === void 0 ? void 0 : d.id) === id;
    });
    if (data) {
      var _data$template;
      return {
        qry: (_data$template = data.template) !== null && _data$template !== void 0 ? _data$template : data.query,
        id: data.id
      };
    }
    return {};
  }
};
var lookups = {
  subjectResponse: function subjectResponse(response) {
    return _stores__WEBPACK_IMPORTED_MODULE_6__.subjectStore.set(response);
  },
  subjectDemoResponse: function subjectDemoResponse(response) {
    return _stores__WEBPACK_IMPORTED_MODULE_6__.subjectDemoStore.results(response);
  }
};
var utils = {
  init: function init(lib) {
    return __webpack_require__.g.blazorLib = lib;
  },
  focus: function focus(id) {
    var _document$getElementB;
    return (_document$getElementB = document.getElementById(id)) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.focus();
  },
  defaultFocus: function defaultFocus() {
    if (document.activeElement.tagName === "BODY") {
      var _document$getElementB2;
      (_document$getElementB2 = document.getElementById("defaultElement")) === null || _document$getElementB2 === void 0 || _document$getElementB2.focus();
    }
  },
  notifyError: function notifyError(title, detail, timeout) {
    return _stores__WEBPACK_IMPORTED_MODULE_6__.stateStore.error(title, detail, timeout);
  },
  loginMsg: function loginMsg(msg) {
    return _stores__WEBPACK_IMPORTED_MODULE_6__.stateStore.loginMsg(msg);
  }
};
})();

lib = __webpack_exports__;
/******/ })()
;